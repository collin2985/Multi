/**
 * MessageHandlers.js
 * Game-specific message handling logic
 */

const fs = require('fs');
const { CONFIG } = require('./ServerConfig.js');
const ChunkCoordinates = require('./ServerChunkCoords.js');
const TimeTrackerService = require('./TimeTrackerService.js');
const { clampQuality, enrichStructureWithDurability, DECAY_EXPONENT } = require('./StructureDecayUtils.js');
const { generateBanditTentLoot, generateBanditCampfireLoot, generateBanditDeathLoot } = require('./BanditLootGenerator.js');
const SpawnTasks = require('./SpawnTasks.js');

/**
 * Validate a position array from client (ISSUE-064)
 * @param {any} pos - Position to validate
 * @returns {boolean} - True if valid [x, y, z] with finite numbers
 */
function validatePosition(pos) {
    if (!Array.isArray(pos) || pos.length < 3) return false;
    if (!Number.isFinite(pos[0]) || !Number.isFinite(pos[1]) || !Number.isFinite(pos[2])) return false;
    return true;
}

/**
 * Objects that are procedurally generated by client from seed.
 * These NEED "remove" entries so client knows not to render them.
 * Everything else (player-built, dynamically spawned like logs) can be deleted entirely.
 */
const PROCEDURAL_OBJECTS = new Set([
    // Trees (generated from terrain seed)
    'pine', 'apple', 'oak', 'fir', 'cypress',
    // Rocks (generated from terrain seed)
    'limestone', 'sandstone', 'clay', 'iron',
    // Food/Plants (generated from terrain seed)
    'vegetables', 'hemp',
    // Animal spawners (generated from chunk coordinates)
    'bearden', 'deertree'
]);

/**
 * Structure types for O(1) lookup (instead of 24+ string comparisons)
 */
const STRUCTURE_TYPES = new Set([
    'house', 'crate', 'tent', 'outpost', 'ship', 'campfire',
    'market', 'dock', 'wall', 'tileworks', 'ironworks', 'blacksmith',
    'bakery', 'gardener', 'miner', 'woodcutter', 'stonemason', 'bearden',
    'fisherman', 'boat', 'sailboat', 'ship2', 'cart', 'artillery', 'horse',
    'warehouse'
]);

// Structures that only owner can modify inventory
const OWNER_PROTECTED = new Set(['house', 'tileworks', 'ironworks', 'blacksmith', 'bakery', 'fisherman']);

// Structures that consume firewood (need placedAtTick stamping)
const BURNING_STRUCTURES = new Set(['campfire', 'house', 'tileworks', 'ironworks', 'blacksmith', 'bakery']);

/**
 * Check if an object needs a "remove" entry when deleted.
 * Procedural objects need "remove" so client knows not to render them.
 * Player-built and dynamically spawned objects can be deleted entirely.
 * @param {string} objectName - The object type name
 * @param {object} objectData - The object data (to check flags like isBanditStructure)
 * @returns {boolean} - True if object needs "remove" entry
 */
function needsRemoveEntry(objectName, objectData) {
    // Procedural natural objects always need remove
    if (PROCEDURAL_OBJECTS.has(objectName)) {
        return true;
    }
    // Bandit structures are procedurally spawned from chunk coordinates
    if (objectData?.isBanditStructure) {
        return true;
    }
    // Everything else (player-built, logs) can be deleted entirely
    return false;
}

class MessageHandlers {
    constructor(chunkManager, messageRouter, clients, cookingSystem = null, tileworksSystem = null, ironworksSystem = null, blacksmithSystem = null, bakerySystem = null, fishermanSystem = null, auditLogger = null) {
        this.chunkManager = chunkManager;
        this.messageRouter = messageRouter;
        this.clients = clients;
        this.cookingSystem = cookingSystem;
        this.tileworksSystem = tileworksSystem;
        this.ironworksSystem = ironworksSystem;
        this.blacksmithSystem = blacksmithSystem;
        this.bakerySystem = bakerySystem;
        this.fishermanSystem = fishermanSystem;
        this.auditLogger = auditLogger;

        // Initialize spawn tasks system
        this.spawnTasks = new SpawnTasks(chunkManager, messageRouter);

        // Track claimed mobile entities per client for disconnect cleanup
        // Map<clientId, Array<{entityId, entityType, chunkId, lastPosition}>>
        this.clientMobileEntities = new Map();

        // Track crates currently loaded on carts (server-side occupied tracking)
        // Map<entityId, { clientId, claimedAt, chunkId }>
        this.loadedCrates = new Map();

        // Track mobile entities being claimed (optimistic lock for race condition prevention)
        // Map<entityId, { clientId, claimedAt }>
        this.claimedMobileEntities = new Map();

        // Lease timeout for stale claims (30 seconds)
        this.CLAIM_LEASE_TIMEOUT = 30000;

        // Track apple trees currently being initialized (prevents race condition)
        // Set<structureId>
        this.initializingAppleTrees = new Set();

        // Track structures with pending lock requests (prevents race condition)
        // When two players request lock simultaneously, async gap allows both to pass
        // the lockedBy check before either sets the lock. This Set blocks concurrent attempts.
        this.pendingLocks = new Set();

        // Track processed ship departures to prevent duplicate trades
        // Map<dockId, lastProcessedShipSpawn>
        this.processedShipDepartures = new Map();

        // Track recent ship spawn triggers to prevent race condition duplicates
        // Map<dockId, lastSpawnTriggerTime>
        this.recentShipSpawnTriggers = new Map();

        // Create centralized time tracking service
        this.timeTracker = new TimeTrackerService();

        // Register 1-minute handlers
        // NOTE: Firewood, cooking, tileworks processing, tree growth, structure decay, and ship spawning
        // have all been moved to client-side tick-based calculation
        // (see CrateInventoryUI, EffectManager, MessageRouter, ScheduledShipSystem for client-side implementation)
        this.timeTracker.registerMinuteHandler('playerCleanup', () => this.cleanupStalePlayers());

        // Start the time tracker
        this.timeTracker.start();
    }

    /**
     * Get item size for inventory placement (server-side)
     * Fix 1: Ensures firewood/planks have correct 2x4 dimensions
     */
    _getItemSize(itemType) {
        const woodMaterials = [
            'oakplank', 'pineplank', 'firplank', 'cypressplank', 'appleplank',
            'oakfirewood', 'pinefirewood', 'firfirewood', 'cypressfirewood', 'applefirewood'
        ];
        if (woodMaterials.includes(itemType)) {
            return { width: 2, height: 4 };
        }
        return { width: 1, height: 1 };
    }

    /**
     * Enrich a structure object with owner's display name
     * @param {object} obj - Structure object with potential owner field
     * @returns {Promise<object>} - Object with ownerName added if owner exists
     */
    async enrichWithOwnerName(obj) {
        if (obj.owner && this.authManager) {
            const ownerName = await this.authManager.getUsernameById(obj.owner);
            if (ownerName) {
                return { ...obj, ownerName };
            }
        }
        return obj;
    }

    /**
     * Handle join_chunk message
     */
    async handleJoinChunk(ws, payload) {
        const { chunkId, clientId, accountId } = payload;  // Now accepts accountId

        if (!clientId) {
            console.error('No clientId provided in join_chunk');
            ws.send(JSON.stringify({ type: 'error', message: 'No clientId provided' }));
            return;
        }

        ws.clientId = clientId;
        ws.accountId = accountId || null;  // Track account ID if provided

        // Clean up stale sessions from same account (handles hard refresh race condition)
        // When a player hard refreshes, old WebSocket may not have closed yet
        if (accountId) {
            for (const [existingClientId, existingClientData] of this.clients.entries()) {
                // Skip if same clientId, same ws object (temp entry), or different account
                if (existingClientId !== clientId &&
                    existingClientData.ws !== ws &&  // Don't close our own temp entry!
                    existingClientData.ws?.accountId === accountId) {
                    // Remove stale session from chunk
                    if (existingClientData.currentChunk) {
                        await this.chunkManager.removePlayerFromChunk(
                            existingClientData.currentChunk,
                            existingClientId
                        );
                    }
                    // Close stale WebSocket gracefully
                    if (existingClientData.ws?.readyState === 1) { // WebSocket.OPEN
                        existingClientData.ws.close(1000, 'Session replaced');
                    }
                    // Clean up from maps
                    this.messageRouter.removeClientFromAccount(accountId, existingClientId);
                    this.clients.delete(existingClientId);
                }
            }
        }

        // Check if client already exists (respawn case) - remove from old chunk first
        const existingClient = this.clients.get(clientId);
        if (existingClient && existingClient.currentChunk) {
            await this.chunkManager.removePlayerFromChunk(existingClient.currentChunk, clientId);
        }

        // Clean up temp client ID if this ws was using one (from initial connection)
        if (ws.tempClientId && this.clients.has(ws.tempClientId)) {
            this.clients.delete(ws.tempClientId);
            ws.tempClientId = null;  // Clear so close handler doesn't double-delete
        }

        this.clients.set(clientId, {
            ws,
            currentChunk: chunkId,
            lastChunk: existingClient?.currentChunk || null,
            accountId: accountId || null  // Store for persistence
        });

        // Register account->clientId mapping for friend online status lookups
        if (accountId) {
            this.messageRouter.addClientToAccount(accountId, clientId);
        }

        await this.chunkManager.addPlayerToChunk(chunkId, clientId);
        this.messageRouter.queueProximityUpdate(chunkId);

        // Audit logging for connect and chunk enter
        if (this.auditLogger) {
            const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
            const prevParsed = existingClient?.currentChunk
                ? ChunkCoordinates.parseChunkIdSafe(existingClient.currentChunk)
                : null;

            // Log connect if this is a new client (not a chunk crossing)
            if (!existingClient) {
                this.auditLogger.logConnect(clientId, accountId, ws.ipAddress, ws.username, ws.fingerprintHash);
            }

            // Log chunk entry with spawn type
            this.auditLogger.logChunkEnter(
                parsed?.chunkX, parsed?.chunkZ,
                clientId, accountId,
                prevParsed?.chunkX, prevParsed?.chunkZ,
                ws.username, ws.fingerprintHash,
                { spawn_type: existingClient ? 'respawn' : 'connect' }
            );
        }

        // If accountId provided, load saved player data
        if (accountId && this.authManager) {
            const playerData = await this.authManager.loadPlayerData(accountId);
            if (playerData) {
                ws.send(JSON.stringify({
                    type: 'player_data_loaded',
                    payload: playerData
                }));
            }
        }

        // Send chunk_objects_state for proximity grid
        // Use parallel loading for initial spawn (player is behind loading screen)
        const objectChanges = await this.chunkManager.getObjectChangesInProximity(chunkId, true);

        // Batch-fetch owner data with caching (2 queries instead of 2N)
        const uniqueOwners = new Set();
        objectChanges.forEach(obj => {
            if (obj.owner && obj.action === 'add') {
                uniqueOwners.add(obj.owner);
            }
        });
        let ownerData = new Map();
        if (uniqueOwners.size > 0 && this.authManager) {
            ownerData = await this.authManager.getBatchOwnerData(Array.from(uniqueOwners));
        }

        // Enrich structures with calculated durability values, owner names, and owner factions
        const enrichedObjectChanges = objectChanges.map(obj => {
            // Only enrich actual structures (not natural objects like trees/rocks)
            const isStructure = obj.name && (
                STRUCTURE_TYPES.has(obj.name) ||
                obj.name.includes('construction') ||
                obj.isConstructionSite
            );

            if (isStructure && obj.action === 'add') {
                let enriched = enrichStructureWithDurability(obj);
                if (enriched.owner) {
                    const owner = ownerData.get(enriched.owner);
                    enriched.ownerName = owner?.username ?? null;
                    // Use stored factionId if available, fall back to dynamic lookup
                    enriched.ownerFactionId = enriched.factionId ?? owner?.factionId ?? null;
                }
                return enriched;
            }
            return obj;
        });

        ws.send(JSON.stringify({
            type: 'chunk_objects_state',
            payload: { chunkId, objectChanges: enrichedObjectChanges, serverTick: this.serverTick || 0 }
        }));
    }

    /**
     * Handle chunk_update message
     */
    async handleChunkUpdate(payload) {
        const _timings = { start: Date.now() };

        const { clientId, newChunkId, lastChunkId } = payload;
        const clientData = this.clients.get(clientId);

        if (!clientData) {
            console.error(`Client ${clientId} not found for chunk_update`);
            return;
        }

        // Update client data
        clientData.currentChunk = newChunkId;
        clientData.lastChunk = lastChunkId;

        // Audit log chunk crossing
        if (this.auditLogger) {
            const parsed = ChunkCoordinates.parseChunkIdSafe(newChunkId);
            const prevParsed = lastChunkId ? ChunkCoordinates.parseChunkIdSafe(lastChunkId) : null;
            this.auditLogger.logChunkEnter(
                parsed?.chunkX, parsed?.chunkZ,
                clientId, clientData.accountId,
                prevParsed?.chunkX, prevParsed?.chunkZ,
                clientData.ws.username, clientData.ws.fingerprintHash
            );
        }

        _timings.afterClientUpdate = Date.now();

        // Update chunk data
        if (lastChunkId) {
            await this.chunkManager.removePlayerFromChunk(lastChunkId, clientId);
        }

        await this.chunkManager.addPlayerToChunk(newChunkId, clientId);

        _timings.afterChunkLists = Date.now();

        // Send chunk_objects_state for proximity grid
        const objectChanges = await this.chunkManager.getObjectChangesInProximity(newChunkId);

        _timings.afterProximityLoad = Date.now();

        // Batch-fetch owner data with caching (2 queries instead of 2N)
        const uniqueOwners = new Set();
        objectChanges.forEach(obj => {
            if (obj.owner && obj.action === 'add') {
                uniqueOwners.add(obj.owner);
            }
        });
        let ownerData = new Map();
        if (uniqueOwners.size > 0 && this.authManager) {
            ownerData = await this.authManager.getBatchOwnerData(Array.from(uniqueOwners));
        }

        _timings.afterOwnerFetch = Date.now();

        // Enrich structures with calculated durability values, owner names, and owner factions
        const enrichedObjectChanges = objectChanges.map(obj => {
            // Only enrich actual structures (not natural objects like trees/rocks)
            const isStructure = obj.name && (
                STRUCTURE_TYPES.has(obj.name) ||
                obj.name.includes('construction') ||
                obj.isConstructionSite
            );

            if (isStructure && obj.action === 'add') {
                let enriched = enrichStructureWithDurability(obj);
                if (enriched.owner) {
                    const owner = ownerData.get(enriched.owner);
                    enriched.ownerName = owner?.username ?? null;
                    // Use stored factionId if available, fall back to dynamic lookup
                    enriched.ownerFactionId = enriched.factionId ?? owner?.factionId ?? null;
                }
                return enriched;
            }
            return obj;
        });

        _timings.afterEnrichment = Date.now();

        clientData.ws.send(JSON.stringify({
            type: 'chunk_objects_state',
            payload: { chunkId: newChunkId, objectChanges: enrichedObjectChanges, serverTick: this.serverTick || 0 }
        }));

        _timings.afterSend = Date.now();

        // Queue notifications for both chunks
        this.messageRouter.queueProximityUpdate(newChunkId);
        if (lastChunkId) {
            this.messageRouter.queueProximityUpdate(lastChunkId);
        }

    }

    /**
     * Handle add_object_request message
     */
    async handleAddObject(ws, payload) {
        try {
            const { chunkId, objectType, objectPosition, objectQuality, objectScale, objectId, objectRotation, totalResources, remainingResources } = payload;

            const change = {
                action: 'add',
                id: objectId,
                name: objectType,
                position: objectPosition,
                quality: objectQuality,
                scale: objectScale,
                rotation: objectRotation, // Rotation in radians
                chunkId: chunkId,
                // Use ?? to preserve 0 as valid value (depleted resource)
                totalResources: totalResources ?? null,
                remainingResources: remainingResources ?? null,
                harvestedBy: null,
                harvestStartTime: null
            };

            await this.chunkManager.addObjectChange(chunkId, change);

            // Audit log structure addition
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logStructureAdd(
                    objectType, objectId,
                    parsed?.chunkX, parsed?.chunkZ,
                    ws.clientId, ws.accountId, ws.username, ws.fingerprintHash
                );
            }

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId,
                    objectId,
                    objectType,
                    position: objectPosition,
                    quality: objectQuality,
                    scale: objectScale,
                    rotation: objectRotation, // Rotation in radians
                    totalResources,
                    remainingResources
                }
            });
        } catch (error) {
            console.error('ERROR in add_object_request:', error);
        }
    }

    /**
     * Handle place_construction_site message
     */
    async handlePlaceConstructionSite(ws, payload) {
        try {
            const { position, rotation, scale, targetStructure, finalFoundationY, clientId, accountId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceConstructionSite] Invalid position:', position);
                return;
            }

            // Use accountId for persistent ownership if available, otherwise fall back to clientId
            const ownerId = accountId || clientId;

            // Calculate chunk from position using unified CENTER-BASED system
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Handle instant-build ship placement
            if (targetStructure === 'ship') {
                // Validate water placement (terrain height check would go here if needed)
                // For now, trust client validation

                const shipId = `ship_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const shipPosition = [position[0], 0, position[2]]; // Water level

                const shipChange = {
                    action: 'add',
                    id: shipId,
                    name: 'ship',
                    position: shipPosition,
                    quality: 50,
                    lastRepairTime: Date.now(),  // Track when structure was created
                    scale: 1.0,
                    chunkId: chunkId,
                    totalResources: null,
                    remainingResources: null,
                    harvestedBy: null,
                    harvestStartTime: null,
                    rotation: rotation,
                    owner: ownerId  // Track who built the ship (accountId for persistence)
                };

                await this.chunkManager.addObjectChange(chunkId, shipChange);

                // Calculate durability values for broadcast
                const shipDurabilityInfo = enrichStructureWithDurability(shipChange);

                // Look up owner name for display
                const shipOwnerName = ownerId && this.authManager ? await this.authManager.getUsernameById(ownerId) : null;

                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'object_added',
                    payload: {
                        chunkId,
                        objectId: shipId,
                        objectType: 'ship',
                        position: shipPosition,
                        quality: 50,
                        currentDurability: shipDurabilityInfo.currentDurability,
                        hoursUntilRuin: shipDurabilityInfo.hoursUntilRuin,
                        scale: 1.0,
                        rotation,
                        totalResources: null,
                        remainingResources: null,
                        owner: ownerId,
                        ownerName: shipOwnerName
                    }
                });

                // Audit log ship placement
                if (this.auditLogger) {
                    const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                    this.auditLogger.logStructureAdd(
                        'ship', shipId,
                        parsed?.chunkX, parsed?.chunkZ,
                        clientId, accountId, ws.username, ws.fingerprintHash
                    );
                }
                return;
            }

            // Generate unique ID for construction site
            const constructionId = `construction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Get required materials from config (single source of truth)
            const requiredMaterials = CONFIG.CONSTRUCTION.MATERIALS[targetStructure] || CONFIG.CONSTRUCTION.DEFAULT_MATERIALS;

            // Determine construction model based on target structure
            // Use mapping from config, default to 'construction' if not specified
            const constructionModel = CONFIG.CONSTRUCTION.CONSTRUCTION_MODELS[targetStructure] || 'construction';

            const constructionChange = {
                action: 'add',
                id: constructionId,
                name: constructionModel,
                position: position,
                quality: 50,  // Default quality for construction sites
                lastRepairTime: Date.now(),  // Track when construction site was placed (1-hour lifespan)
                scale: scale,
                chunkId: chunkId,
                totalResources: null,
                remainingResources: null,
                harvestedBy: null,
                harvestStartTime: null,
                isConstructionSite: true,
                targetStructure: targetStructure,
                rotation: rotation,
                requiredMaterials: requiredMaterials,
                materials: {},
                finalFoundationY: finalFoundationY,
                owner: ownerId  // Track who placed the construction site (accountId for persistence)
            };

            await this.chunkManager.addObjectChange(chunkId, constructionChange);

            // Calculate durability values for broadcast (construction sites have 1-hour lifespan)
            const constructionDurabilityInfo = enrichStructureWithDurability(constructionChange);

            // Look up owner name for display
            const ownerName = ownerId && this.authManager ? await this.authManager.getUsernameById(ownerId) : null;

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId,
                    objectId: constructionId,
                    objectType: constructionModel,
                    position,
                    quality: 50,
                    currentDurability: constructionDurabilityInfo.currentDurability,
                    hoursUntilRuin: constructionDurabilityInfo.hoursUntilRuin,
                    scale,
                    rotation,
                    totalResources: null,
                    remainingResources: null,
                    isConstructionSite: true,
                    targetStructure,
                    requiredMaterials,
                    materials: {},
                    finalFoundationY,
                    owner: ownerId,
                    ownerName: ownerName
                }
            });

            // Audit log construction site placement
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logStructureAdd(
                    constructionModel, constructionId,
                    parsed?.chunkX, parsed?.chunkZ,
                    clientId, accountId, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in place_construction_site:', error);
        }
    }

    /**
     * Handle place_road message
     */
    async handlePlaceRoad(ws, payload) {
        try {
            const { position, rotation, materialType } = payload;

            // Calculate chunk from position using unified CENTER-BASED system
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Generate unique ID for road
            const roadId = `road_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Create road change object (stores terrain modification data)
            const roadChange = {
                action: 'add',
                id: roadId,
                name: 'road',  // Type identifier
                position: position,
                rotation: rotation || 0,
                chunkId: chunkId,
                isRoad: true,  // Flag to identify roads for terrain blending
                materialType: materialType || 'limestone'  // sandstone or limestone for visual tint
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, roadChange);

            // Broadcast to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'road_placed',
                payload: {
                    chunkId,
                    roadId,
                    position,
                    rotation: rotation || 0,
                    materialType: materialType || 'limestone'
                }
            });
        } catch (error) {
            console.error('ERROR in place_road:', error);
        }
    }

    /**
     * Handle place_boat message
     * Creates instant-build boat structure in water
     */
    async handlePlaceBoat(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceBoat] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Generate unique ID
            const boatId = `boat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Use accountId for persistent ownership if available
            const ownerId = accountId || clientId;

            // Calculate quality from material
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['boat'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Create boat structure object
            const boatChange = {
                action: 'add',
                id: boatId,
                name: 'boat',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, boatChange);

            // Calculate durability values
            const boatDurabilityInfo = enrichStructureWithDurability(boatChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: boatId,
                    objectType: 'boat',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: boatDurabilityInfo.currentDurability,
                    hoursUntilRuin: boatDurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

        } catch (error) {
            console.error('ERROR in place_boat:', error);
        }
    }

    /**
     * Handle create_corpse message
     * Creates a lootable corpse structure when player/bandit/militia dies
     */
    async handleCreateCorpse(ws, payload) {
        try {
            const {
                position, rotation, fallDirection, shirtColor, modelType,
                corpseType, displayName, inventory, hasRifle, chunkId
            } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[CreateCorpse] Invalid position:', position);
                return;
            }

            // Generate unique corpse ID
            const corpseId = `corpse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Generate loot for bandits/militia, use provided inventory for players
            let corpseInventory;
            if (corpseType === 'player') {
                corpseInventory = inventory;  // Player's actual inventory
            } else {
                // Generate deterministic loot for bandits/militia
                corpseInventory = generateBanditDeathLoot(corpseId, hasRifle !== false);
            }

            // Create corpse structure (quality 1 = ~1 hour lifespan via decay formula)
            const corpseChange = {
                action: 'add',
                id: corpseId,
                name: 'corpse',
                position: position,
                rotation: rotation || 0,
                quality: 1,  // ~1 hour lifespan
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                isCorpse: true,
                fallDirection: fallDirection,
                shirtColor: shirtColor,
                modelType: modelType || 'man',
                corpseType: corpseType || 'bandit',
                displayName: displayName || 'Body',
                inventory: corpseInventory
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, corpseChange);

            // Calculate durability values for broadcast
            const durabilityInfo = enrichStructureWithDurability(corpseChange);

            // Broadcast to clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    ...corpseChange,
                    objectType: 'corpse',
                    objectId: corpseId,
                    currentDurability: durabilityInfo.currentDurability,
                    hoursUntilRuin: durabilityInfo.hoursUntilRuin
                }
            });

        } catch (error) {
            console.error('ERROR in create_corpse:', error);
        }
    }

    /**
     * Handle place_sailboat message
     * Creates instant-build sailboat structure in water
     */
    async handlePlaceSailboat(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceSailboat] Invalid position:', position);
                return;
            }

            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const sailboatId = `sailboat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ownerId = accountId || clientId;

            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['sailboat'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            const sailboatChange = {
                action: 'add',
                id: sailboatId,
                name: 'sailboat',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId
            };

            await this.chunkManager.addObjectChange(chunkId, sailboatChange);

            const sailboatDurabilityInfo = enrichStructureWithDurability(sailboatChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: sailboatId,
                    objectType: 'sailboat',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: sailboatDurabilityInfo.currentDurability,
                    hoursUntilRuin: sailboatDurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

        } catch (error) {
            console.error('ERROR in place_sailboat:', error);
        }
    }

    /**
     * Handle place_ship2 message
     * Creates instant-build ship structure in water
     */
    async handlePlaceShip2(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceShip2] Invalid position:', position);
                return;
            }

            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const ship2Id = `ship2_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ownerId = accountId || clientId;

            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['ship2'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Look up owner name and faction BEFORE creating ship2Change
            // so we can persist factionId on the object
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            const ship2Change = {
                action: 'add',
                id: ship2Id,
                name: 'ship2',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId,
                factionId: ownerFactionId  // Persist builder's faction on the object
            };

            await this.chunkManager.addObjectChange(chunkId, ship2Change);

            const ship2DurabilityInfo = enrichStructureWithDurability(ship2Change);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: ship2Id,
                    objectType: 'ship2',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: ship2DurabilityInfo.currentDurability,
                    hoursUntilRuin: ship2DurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

        } catch (error) {
            console.error('ERROR in place_ship2:', error);
        }
    }

    /**
     * Handle place_horse message (debug/testing)
     * Places a horse at the specified position
     */
    async handlePlaceHorse(ws, payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId, isBanditStructure, objectId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceHorse] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const horseId = objectId || `horse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            // Bandit horses have no owner (can be stolen by anyone)
            const ownerId = isBanditStructure ? null : (accountId || clientId);

            // Calculate quality
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['horse'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Create horse structure object
            const horseChange = {
                action: 'add',
                id: horseId,
                name: 'horse',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId,
                isBanditStructure: isBanditStructure || false
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, horseChange);

            // Calculate durability values
            const horseDurabilityInfo = enrichStructureWithDurability(horseChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: horseId,
                    objectType: 'horse',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: horseDurabilityInfo.currentDurability,
                    hoursUntilRuin: horseDurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId,
                    isBanditStructure: isBanditStructure || false
                }
            });
        } catch (error) {
            console.error('ERROR in place_horse:', error);
        }
    }

    /**
     * Handle place_cart message
     * Creates a cart structure that can be towed by players
     */
    async handlePlaceCart(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceCart] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const cartId = `cart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ownerId = accountId || clientId;

            // Calculate quality with cap
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['cart'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Create cart structure object (no inventory - carts are pure transport)
            const cartChange = {
                action: 'add',
                id: cartId,
                name: 'cart',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, cartChange);

            // Calculate durability values
            const cartDurabilityInfo = enrichStructureWithDurability(cartChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: cartId,
                    objectType: 'cart',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: cartDurabilityInfo.currentDurability,
                    hoursUntilRuin: cartDurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

        } catch (error) {
            console.error('ERROR in place_cart:', error);
        }
    }

    /**
     * Handle claim_towed message (unified cart/artillery towing)
     * Temporarily removes entity from chunk when player attaches to it
     */
    async handleClaimTowed(ws, payload) {
        const entityType = payload.entityType; // 'cart' or 'artillery'
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: entityType,
            chunkKey: payload.chunkKey,
            clientId: payload.clientId
        };
        await this.handleClaimMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle release_towed message (unified cart/artillery towing)
     * Adds entity back to chunk at new position when player detaches
     */
    async handleReleaseTowed(ws, payload) {
        const entityType = payload.entityType; // 'cart' or 'artillery'
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: entityType,
            chunkKey: payload.chunkKey,
            clientId: payload.clientId,
            position: payload.position,
            rotation: payload.rotation,
            quality: payload.quality,
            lastRepairTime: payload.lastRepairTime
        };
        await this.handleReleaseMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle place_artillery message
     * Creates an artillery structure with shell-only inventory (horse-towable)
     */
    async handlePlaceArtillery(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceArtillery] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const artilleryId = `artillery_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ownerId = accountId || clientId;

            // Calculate quality with cap
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['artillery'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Create artillery structure object WITH inventory (4x4 for shells only)
            const artilleryChange = {
                action: 'add',
                id: artilleryId,
                name: 'artillery',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId,
                inventory: { items: [] }  // 4x4 inventory for shells
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, artilleryChange);

            // Calculate durability values
            const artilleryDurabilityInfo = enrichStructureWithDurability(artilleryChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: artilleryId,
                    objectType: 'artillery',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: artilleryDurabilityInfo.currentDurability,
                    hoursUntilRuin: artilleryDurabilityInfo.hoursUntilRuin,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId,
                    inventory: { items: [] }
                }
            });

        } catch (error) {
            console.error('ERROR in place_artillery:', error);
        }
    }

    /**
     * Handle claim_artillery message
     * Temporarily removes artillery from chunk when horse attaches to it
     */
    async handleClaimArtillery(ws, payload) {
        const entityType = payload.entityId.split('_')[0];
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: entityType,
            chunkKey: payload.chunkKey,
            clientId: payload.clientId
        };
        await this.handleClaimMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle release_artillery message
     * Adds artillery back to chunk at new position when horse detaches
     */
    async handleReleaseArtillery(ws, payload) {
        const entityType = payload.entityId.split('_')[0];
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: entityType,
            chunkKey: payload.chunkKey,
            clientId: payload.clientId,
            position: payload.position,
            rotation: payload.rotation,
            quality: payload.quality,
            lastRepairTime: payload.lastRepairTime,
            inventory: payload.inventory,
            hasMilitia: payload.hasMilitia,
            militiaOwner: payload.militiaOwner,
            militiaFaction: payload.militiaFaction,
            militiaType: payload.militiaType
        };
        await this.handleReleaseMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle claim_ship_horse message
     * Removes horse from chunk when loaded onto ship
     */
    async handleClaimShipHorse(ws, payload) {
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: 'horse',
            chunkKey: payload.chunkKey,
            clientId: payload.clientId
        };
        await this.handleClaimMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle release_ship_horse message
     * Adds horse back to chunk when unloaded from ship
     */
    async handleReleaseShipHorse(ws, payload) {
        const mobilePayload = {
            entityId: payload.entityId,
            entityType: 'horse',
            chunkKey: payload.chunkKey,
            clientId: payload.clientId,
            position: payload.position,
            rotation: payload.rotation,
            quality: payload.quality,
            lastRepairTime: payload.lastRepairTime
        };
        await this.handleReleaseMobileEntity(ws, mobilePayload);
    }

    /**
     * Handle place_crate message
     * Creates a mobile crate structure with inventory
     */
    async handlePlaceCrate(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceCrate] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
            const crateId = `crate_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ownerId = accountId || clientId;

            // Calculate quality with cap (crate uses same cap as cart/tent)
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['crate'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Create crate structure object WITH inventory (10x10 like tent)
            const crateChange = {
                action: 'add',
                id: crateId,
                name: 'crate',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                inventory: { items: [] },  // Empty 10x10 inventory
                owner: ownerId
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, crateChange);

            // Calculate durability values
            const crateDurabilityInfo = enrichStructureWithDurability(crateChange);

            // Look up owner name and faction
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: crateId,
                    objectType: 'crate',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: crateDurabilityInfo.currentDurability,
                    hoursUntilRuin: crateDurabilityInfo.hoursUntilRuin,
                    inventory: { items: [] },
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

        } catch (error) {
            console.error('ERROR in place_crate:', error);
        }
    }

    /**
     * Handle claim_crate message
     * Temporarily removes a crate from chunk when player loads it onto cart
     * Now includes lock acquisition and server-side occupied tracking
     */
    async handleClaimCrate(ws, payload) {
        try {
            const { entityId, chunkKey, clientId } = payload;
            const fullChunkId = `chunk_${chunkKey}`;

            // Check if crate is already loaded by someone else (server-side occupied check)
            // This check + set must be synchronous to prevent race conditions
            if (this.loadedCrates.has(entityId)) {
                const existingClaim = this.loadedCrates.get(entityId);
                ws.send(JSON.stringify({
                    type: 'claim_crate_response',
                    payload: {
                        entityId,
                        success: false,
                        reason: 'Crate is already loaded on another cart'
                    }
                }));
                console.warn(`[Crate] Crate ${entityId} already claimed by ${existingClaim.clientId}`);
                return;
            }

            // Optimistic lock: immediately mark as claimed BEFORE async operations
            // This prevents race condition where two clients pass the check simultaneously
            this.loadedCrates.set(entityId, { clientId, pending: true, claimedAt: Date.now() });

            const chunkData = await this.chunkManager.loadChunk(fullChunkId);
            if (!chunkData || !chunkData.objectChanges) {
                this.loadedCrates.delete(entityId); // Release optimistic lock
                ws.send(JSON.stringify({
                    type: 'claim_crate_response',
                    payload: { entityId, success: false, reason: 'Chunk not found' }
                }));
                console.warn(`[Crate] Chunk ${fullChunkId} not found for claim_crate`);
                return;
            }

            // Find the crate
            const crateIndex = chunkData.objectChanges.findIndex(
                obj => obj.id === entityId && obj.action === 'add' && obj.name === 'crate'
            );

            if (crateIndex === -1) {
                this.loadedCrates.delete(entityId); // Release optimistic lock
                ws.send(JSON.stringify({
                    type: 'claim_crate_response',
                    payload: { entityId, success: false, reason: 'Crate not found' }
                }));
                console.warn(`[Crate] Crate ${entityId} not found in chunk ${fullChunkId}`);
                return;
            }

            const crate = chunkData.objectChanges[crateIndex];

            // Check if crate has an inventory lock held by someone else
            if (crate.lockedBy && crate.lockedBy !== clientId && !this.isLockStale(crate)) {
                this.loadedCrates.delete(entityId); // Release optimistic lock
                ws.send(JSON.stringify({
                    type: 'claim_crate_response',
                    payload: {
                        entityId,
                        success: false,
                        reason: 'Crate inventory is being used by another player'
                    }
                }));
                return;
            }

            // Acquire inventory lock on the crate
            crate.lockedBy = clientId;
            crate.lockTime = Date.now();
            crate.claimedBy = clientId;
            crate.claimedAt = Date.now();

            // Save chunk with lock
            await this.chunkManager.saveChunk(fullChunkId, chunkData);

            // Track in server-side loadedCrates Map
            this.loadedCrates.set(entityId, {
                clientId,
                claimedAt: Date.now(),
                chunkId: fullChunkId,
                inventory: crate.inventory || { items: [] }
            });

            // Send success response to client
            ws.send(JSON.stringify({
                type: 'claim_crate_response',
                payload: {
                    entityId,
                    success: true,
                    inventory: crate.inventory || { items: [] }
                }
            }));

            // Broadcast lock state to nearby players (before removal broadcast)
            // This helps prevent race condition where another player tries to open right before removal
            this.messageRouter.broadcastTo3x3GridExcluding(fullChunkId, {
                type: 'structure_lock_changed',
                payload: {
                    structureId: entityId,
                    chunkId: fullChunkId,
                    lockedBy: clientId,
                    locked: true
                }
            }, clientId);

            // Broadcast crate removal (it's now on a cart)
            this.messageRouter.broadcastTo3x3Grid(fullChunkId, {
                type: 'object_removed',
                payload: {
                    chunkId: fullChunkId,
                    objectId: entityId,
                    isMobileClaim: true,
                    claimedBy: clientId
                }
            });

        } catch (error) {
            // Release optimistic lock on any error
            if (payload?.entityId) {
                this.loadedCrates.delete(payload.entityId);
            }
            console.error('ERROR in claim_crate:', error);
            ws.send(JSON.stringify({
                type: 'claim_crate_response',
                payload: { entityId: payload.entityId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Validate crate inventory format to prevent malicious data
     * @param {object} inventory - The inventory to validate
     * @returns {{ valid: boolean, reason?: string, sanitized?: object }}
     */
    validateCrateInventory(inventory) {
        // Must be an object with items array
        if (!inventory || typeof inventory !== 'object') {
            return { valid: true, sanitized: { items: [] } };
        }

        if (!Array.isArray(inventory.items)) {
            return { valid: true, sanitized: { items: [] } };
        }

        // Validate each item
        const sanitizedItems = [];
        const CRATE_COLS = 10;
        const CRATE_ROWS = 10;

        for (const item of inventory.items) {
            // Skip invalid items
            if (!item || typeof item !== 'object') continue;
            if (typeof item.type !== 'string' || item.type.length === 0 || item.type.length > 50) continue;

            // Validate position bounds (client uses x/y, not col/row)
            const x = parseInt(item.x, 10);
            const y = parseInt(item.y, 10);
            if (isNaN(x) || isNaN(y)) continue;
            if (x < 0 || x >= CRATE_COLS || y < 0 || y >= CRATE_ROWS) continue;

            // Validate dimensions
            const width = parseInt(item.width, 10) || 1;
            const height = parseInt(item.height, 10) || 1;
            if (width < 1 || width > 5 || height < 1 || height > 5) continue;
            if (x + width > CRATE_COLS || y + height > CRATE_ROWS) continue;

            // Validate quantity
            const quantity = parseInt(item.quantity, 10) || 1;
            if (quantity < 1 || quantity > 1000) continue;

            // Validate quality and durability
            const quality = Math.max(1, Math.min(100, parseInt(item.quality, 10) || 50));
            const durability = Math.max(0, Math.min(100, parseInt(item.durability, 10) || 100));

            sanitizedItems.push({
                id: item.id,  // Preserve item ID
                type: item.type,
                x,
                y,
                width,
                height,
                quantity,
                quality,
                durability,
                rotation: parseInt(item.rotation, 10) || 0
            });
        }

        return { valid: true, sanitized: { items: sanitizedItems } };
    }

    /**
     * Handle release_crate message
     * Adds crate back to chunk at new position when unloaded from cart
     * Now includes ownership validation, inventory validation, and lock release
     */
    async handleReleaseCrate(ws, payload) {
        try {
            const { entityId, chunkKey, clientId, position, rotation, quality, lastRepairTime, inventory } = payload;

            // Validate ownership - must be the client who claimed it
            const loadedCrate = this.loadedCrates.get(entityId);

            // Use server-tracked chunk for old location (not client-provided chunkKey)
            // This prevents orphaned crates if client sends wrong chunk
            const originalFullChunkId = loadedCrate?.chunkId || `chunk_${chunkKey}`;
            if (!loadedCrate) {
                ws.send(JSON.stringify({
                    type: 'release_crate_response',
                    payload: { entityId, success: false, reason: 'Crate not found in loaded state' }
                }));
                console.warn(`[Crate] Release failed - crate ${entityId} not in loadedCrates`);
                return;
            }

            if (loadedCrate.clientId !== clientId) {
                ws.send(JSON.stringify({
                    type: 'release_crate_response',
                    payload: { entityId, success: false, reason: 'You do not own this loaded crate' }
                }));
                console.warn(`[Crate] Release failed - crate ${entityId} owned by ${loadedCrate.clientId}, not ${clientId}`);
                return;
            }

            // Handle lost crate (boat sank with crate on board)
            // Just remove from tracking, don't place back in world
            if (payload.isLost) {
                // Remove from original chunk data
                const originalChunkData = await this.chunkManager.loadChunk(originalFullChunkId);
                if (originalChunkData && originalChunkData.objectChanges) {
                    const crateIndex = originalChunkData.objectChanges.findIndex(
                        obj => obj.id === entityId && obj.name === 'crate'
                    );
                    if (crateIndex !== -1) {
                        originalChunkData.objectChanges.splice(crateIndex, 1);
                        await this.chunkManager.saveChunk(originalFullChunkId, originalChunkData);
                    }
                }

                // Remove from server-side tracking
                this.loadedCrates.delete(entityId);

                // Send success response (crate is lost, not placed)
                ws.send(JSON.stringify({
                    type: 'release_crate_response',
                    payload: { entityId, success: true, lost: true }
                }));

                return;
            }

            // Validate position (includes world bounds check)
            if (!validatePosition(position)) {
                ws.send(JSON.stringify({
                    type: 'release_crate_response',
                    payload: { entityId, success: false, reason: 'Invalid position' }
                }));
                console.warn(`[Crate] Release failed - invalid position: ${JSON.stringify(position)}`);
                return;
            }

            // Validate and sanitize inventory
            const inventoryValidation = this.validateCrateInventory(inventory);
            const sanitizedInventory = inventoryValidation.sanitized;

            // Calculate new chunk based on drop position
            const newChunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // If same chunk, update in place; if different chunk, move between chunks
            if (newChunkId === originalFullChunkId) {
                // Same chunk - just update position and clear claimed status
                const chunkData = await this.chunkManager.loadChunk(newChunkId);
                if (chunkData && chunkData.objectChanges) {
                    const crateIndex = chunkData.objectChanges.findIndex(
                        obj => obj.id === entityId && obj.name === 'crate'
                    );

                    if (crateIndex !== -1) {
                        const crate = chunkData.objectChanges[crateIndex];
                        crate.position = position;
                        crate.rotation = rotation;
                        crate.inventory = sanitizedInventory;
                        // Release lock
                        delete crate.lockedBy;
                        delete crate.lockTime;
                        delete crate.claimedBy;
                        delete crate.claimedAt;

                        await this.chunkManager.saveChunk(newChunkId, chunkData);
                    }
                }
            } else {
                // Different chunk - add to new FIRST, then remove from old (safer ordering)
                // This ensures crate is never lost if one operation fails
                const crateChange = {
                    action: 'add',
                    id: entityId,
                    name: 'crate',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality || 50,
                    lastRepairTime: lastRepairTime || Date.now(),
                    chunkId: newChunkId,
                    inventory: sanitizedInventory
                };

                // Add to new chunk first (if this fails, crate stays in old chunk)
                await this.chunkManager.addObjectChange(newChunkId, crateChange);

                // Now remove from original chunk (safe - crate is already in new chunk)
                const originalChunkData = await this.chunkManager.loadChunk(originalFullChunkId);
                if (originalChunkData && originalChunkData.objectChanges) {
                    const crateIndex = originalChunkData.objectChanges.findIndex(
                        obj => obj.id === entityId && obj.name === 'crate'
                    );
                    if (crateIndex !== -1) {
                        originalChunkData.objectChanges.splice(crateIndex, 1);
                        await this.chunkManager.saveChunk(originalFullChunkId, originalChunkData);
                    }
                }
            }

            // Remove from server-side tracking
            this.loadedCrates.delete(entityId);

            // Calculate durability for broadcast
            const crateDurabilityInfo = enrichStructureWithDurability({
                quality: quality || 50,
                lastRepairTime: lastRepairTime || Date.now(),
                name: 'crate'
            });

            // Send success response to client BEFORE broadcast
            ws.send(JSON.stringify({
                type: 'release_crate_response',
                payload: { entityId, success: true, newChunkId }
            }));

            // Broadcast crate appearance
            this.messageRouter.broadcastTo3x3Grid(newChunkId, {
                type: 'object_added',
                payload: {
                    chunkId: newChunkId,
                    objectId: entityId,
                    objectType: 'crate',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality || 50,
                    currentDurability: crateDurabilityInfo.currentDurability,
                    hoursUntilRuin: crateDurabilityInfo.hoursUntilRuin,
                    inventory: sanitizedInventory,
                    isMobileRelease: true  // Flag so clients update position/physics for existing object
                }
            });

        } catch (error) {
            console.error('ERROR in release_crate:', error);
            ws.send(JSON.stringify({
                type: 'release_crate_response',
                payload: { entityId: payload.entityId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle warehouse_load_crate message
     * Loads a crate into a warehouse for safe storage (max 4 crates)
     */
    async handleWarehouseLoadCrate(ws, payload) {
        try {
            const { warehouseId, warehouseChunkKey, crateId, crateChunkKey, clientId } = payload;
            const warehouseFullChunkId = `chunk_${warehouseChunkKey}`;
            const crateFullChunkId = `chunk_${crateChunkKey}`;

            // Load warehouse chunk
            const warehouseChunkData = await this.chunkManager.loadChunk(warehouseFullChunkId);
            if (!warehouseChunkData || !warehouseChunkData.objectChanges) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Warehouse chunk not found' }
                }));
                return;
            }

            // Find the warehouse
            const warehouseIndex = warehouseChunkData.objectChanges.findIndex(
                obj => obj.id === warehouseId && obj.action === 'add' && obj.name === 'warehouse'
            );

            if (warehouseIndex === -1) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Warehouse not found' }
                }));
                return;
            }

            const warehouse = warehouseChunkData.objectChanges[warehouseIndex];

            // Check ownership (owner may be accountId or clientId)
            if (warehouse.owner !== clientId && warehouse.owner !== ws.accountId) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Not your warehouse' }
                }));
                return;
            }

            // Check capacity (max 4 crates)
            if (!warehouse.loadedCrates) {
                warehouse.loadedCrates = [];
            }
            if (warehouse.loadedCrates.length >= 4) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Warehouse is full' }
                }));
                return;
            }

            // Load crate chunk (may be same as warehouse chunk)
            let crateChunkData;
            if (crateFullChunkId === warehouseFullChunkId) {
                crateChunkData = warehouseChunkData;
            } else {
                crateChunkData = await this.chunkManager.loadChunk(crateFullChunkId);
            }

            if (!crateChunkData || !crateChunkData.objectChanges) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Crate chunk not found' }
                }));
                return;
            }

            // Find the crate
            const crateIndex = crateChunkData.objectChanges.findIndex(
                obj => obj.id === crateId && obj.action === 'add' && obj.name === 'crate'
            );

            if (crateIndex === -1) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Crate not found' }
                }));
                return;
            }

            const crate = crateChunkData.objectChanges[crateIndex];

            // Check if crate is locked by another player
            if (crate.lockedBy && crate.lockedBy !== clientId && !this.isLockStale(crate)) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Crate is being used by another player' }
                }));
                return;
            }

            // Check if crate is claimed (loaded on cart/boat)
            if (this.loadedCrates.has(crateId)) {
                ws.send(JSON.stringify({
                    type: 'warehouse_load_response',
                    payload: { success: false, reason: 'Crate is loaded on a vehicle' }
                }));
                return;
            }

            // Store crate data in warehouse
            const crateData = {
                crateId: crateId,
                inventory: crate.inventory || { items: [] },
                owner: crate.owner,
                quality: crate.quality,
                lastRepairTime: crate.lastRepairTime,
                loadedAt: Date.now()
            };
            warehouse.loadedCrates.push(crateData);

            // Remove crate from its chunk
            crateChunkData.objectChanges.splice(crateIndex, 1);

            // Save both chunks (may be same chunk)
            await this.chunkManager.saveChunk(warehouseFullChunkId, warehouseChunkData);
            if (crateFullChunkId !== warehouseFullChunkId) {
                await this.chunkManager.saveChunk(crateFullChunkId, crateChunkData);
            }

            // Send success response
            ws.send(JSON.stringify({
                type: 'warehouse_load_response',
                payload: {
                    success: true,
                    warehouseId: warehouseId,
                    crateId: crateId,
                    loadedCount: warehouse.loadedCrates.length
                }
            }));

            // Broadcast crate removal to nearby players
            this.messageRouter.broadcastTo3x3Grid(crateFullChunkId, {
                type: 'object_removed',
                payload: {
                    chunkId: crateFullChunkId,
                    objectId: crateId,
                    isWarehouseLoad: true
                }
            });

            // Broadcast warehouse state update
            this.messageRouter.broadcastTo3x3Grid(warehouseFullChunkId, {
                type: 'warehouse_state_updated',
                payload: {
                    warehouseId: warehouseId,
                    chunkId: warehouseFullChunkId,
                    loadedCount: warehouse.loadedCrates.length
                }
            });

        } catch (error) {
            console.error('ERROR in warehouse_load_crate:', error);
            ws.send(JSON.stringify({
                type: 'warehouse_load_response',
                payload: { success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle warehouse_unload_crate message
     * Unloads the last loaded crate from warehouse (LIFO)
     */
    async handleWarehouseUnloadCrate(ws, payload) {
        try {
            const { warehouseId, warehouseChunkKey, dropPosition, dropRotation, clientId } = payload;
            const warehouseFullChunkId = `chunk_${warehouseChunkKey}`;

            // Load warehouse chunk
            const warehouseChunkData = await this.chunkManager.loadChunk(warehouseFullChunkId);
            if (!warehouseChunkData || !warehouseChunkData.objectChanges) {
                ws.send(JSON.stringify({
                    type: 'warehouse_unload_response',
                    payload: { success: false, reason: 'Warehouse chunk not found' }
                }));
                return;
            }

            // Find the warehouse
            const warehouseIndex = warehouseChunkData.objectChanges.findIndex(
                obj => obj.id === warehouseId && obj.action === 'add' && obj.name === 'warehouse'
            );

            if (warehouseIndex === -1) {
                ws.send(JSON.stringify({
                    type: 'warehouse_unload_response',
                    payload: { success: false, reason: 'Warehouse not found' }
                }));
                return;
            }

            const warehouse = warehouseChunkData.objectChanges[warehouseIndex];

            // Check ownership (owner may be accountId or clientId)
            if (warehouse.owner !== clientId && warehouse.owner !== ws.accountId) {
                ws.send(JSON.stringify({
                    type: 'warehouse_unload_response',
                    payload: { success: false, reason: 'Not your warehouse' }
                }));
                return;
            }

            // Check if warehouse has crates
            if (!warehouse.loadedCrates || warehouse.loadedCrates.length === 0) {
                ws.send(JSON.stringify({
                    type: 'warehouse_unload_response',
                    payload: { success: false, reason: 'Warehouse is empty' }
                }));
                return;
            }

            // Pop the last crate (LIFO)
            const crateData = warehouse.loadedCrates.pop();

            // Calculate which chunk the crate will be placed in
            const newFullChunkId = ChunkCoordinates.worldToChunkId(dropPosition[0], dropPosition[2]);
            const newChunkKey = newFullChunkId.replace('chunk_', '');

            // Load or reuse chunk for new crate position
            let dropChunkData;
            if (newFullChunkId === warehouseFullChunkId) {
                dropChunkData = warehouseChunkData;
            } else {
                dropChunkData = await this.chunkManager.loadChunk(newFullChunkId);
                if (!dropChunkData) {
                    dropChunkData = { objectChanges: [] };
                }
                if (!dropChunkData.objectChanges) {
                    dropChunkData.objectChanges = [];
                }
            }

            // Create new crate object
            const newCrateId = crateData.crateId;
            const newCrate = {
                action: 'add',
                id: newCrateId,
                name: 'crate',
                position: dropPosition,
                rotation: dropRotation,
                scale: 1,
                chunkId: newFullChunkId,
                owner: crateData.owner,
                quality: crateData.quality,
                lastRepairTime: crateData.lastRepairTime,
                inventory: crateData.inventory
            };

            dropChunkData.objectChanges.push(newCrate);

            // Save chunks
            await this.chunkManager.saveChunk(warehouseFullChunkId, warehouseChunkData);
            if (newFullChunkId !== warehouseFullChunkId) {
                await this.chunkManager.saveChunk(newFullChunkId, dropChunkData);
            }

            // Send success response
            ws.send(JSON.stringify({
                type: 'warehouse_unload_response',
                payload: {
                    success: true,
                    warehouseId: warehouseId,
                    crateId: newCrateId,
                    loadedCount: warehouse.loadedCrates.length,
                    cratePosition: dropPosition,
                    crateRotation: dropRotation,
                    crateOwner: crateData.owner,
                    crateQuality: crateData.quality,
                    crateLastRepairTime: crateData.lastRepairTime,
                    crateInventory: crateData.inventory,
                    crateChunkKey: newChunkKey
                }
            }));

            // Broadcast new crate to nearby players
            this.messageRouter.broadcastTo3x3Grid(newFullChunkId, {
                type: 'object_added',
                payload: {
                    chunkId: newFullChunkId,
                    objectId: newCrateId,
                    objectType: 'crate',
                    position: dropPosition,
                    rotation: dropRotation,
                    scale: 1,
                    quality: crateData.quality,
                    inventory: crateData.inventory,
                    owner: crateData.owner
                }
            });

            // Broadcast warehouse state update
            this.messageRouter.broadcastTo3x3Grid(warehouseFullChunkId, {
                type: 'warehouse_state_updated',
                payload: {
                    warehouseId: warehouseId,
                    chunkId: warehouseFullChunkId,
                    loadedCount: warehouse.loadedCrates.length
                }
            });

        } catch (error) {
            console.error('ERROR in warehouse_unload_crate:', error);
            ws.send(JSON.stringify({
                type: 'warehouse_unload_response',
                payload: { success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle claim_mobile_entity message (generalized for boats, horses, artillery, etc.)
     * Temporarily removes an entity from the chunk when a player boards/mounts/loads it
     * Uses optimistic locking to prevent race conditions when two players claim simultaneously
     */
    async handleClaimMobileEntity(ws, payload) {
        const { entityId, entityType, chunkKey, clientId } = payload;
        const fullChunkId = `chunk_${chunkKey}`;
        const responseType = `claim_${entityType}_response`;

        try {
            // Check if already being claimed (race condition prevention)
            if (this.claimedMobileEntities.has(entityId)) {
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId, success: false, reason: 'Entity is already being claimed' }
                }));
                return;
            }

            // Optimistic lock - set BEFORE any async operations
            this.claimedMobileEntities.set(entityId, { clientId, claimedAt: Date.now() });

            const chunkData = await this.chunkManager.loadChunk(fullChunkId);
            if (!chunkData || !chunkData.objectChanges) {
                this.claimedMobileEntities.delete(entityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId, success: false, reason: 'Chunk not found' }
                }));
                return;
            }

            // Find the entity
            const entityIndex = chunkData.objectChanges.findIndex(
                obj => obj.id === entityId && obj.action === 'add' && obj.name === entityType
            );

            if (entityIndex === -1) {
                this.claimedMobileEntities.delete(entityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId, success: false, reason: 'Entity not found' }
                }));
                return;
            }

            const entity = chunkData.objectChanges[entityIndex];

            // Check if already claimed by someone else
            if (entity.claimedBy && entity.claimedBy !== clientId) {
                this.claimedMobileEntities.delete(entityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId, success: false, reason: 'Entity already claimed by another player' }
                }));
                return;
            }

            // Mark as claimed
            entity.claimedBy = clientId;
            entity.claimedAt = Date.now();
            await this.chunkManager.saveChunk(fullChunkId, chunkData);

            // Track claimed entity for disconnect cleanup
            if (!this.clientMobileEntities.has(clientId)) {
                this.clientMobileEntities.set(clientId, []);
            }
            this.clientMobileEntities.get(clientId).push({
                entityId,
                entityType,
                chunkId: fullChunkId,
                lastPosition: entity.position
            });

            // Release optimistic lock (entity is now in clientMobileEntities)
            this.claimedMobileEntities.delete(entityId);

            // Send SUCCESS response with entity data
            ws.send(JSON.stringify({
                type: responseType,
                payload: {
                    entityId,
                    success: true,
                    inventory: entity.inventory,
                    quality: entity.quality,
                    lastRepairTime: entity.lastRepairTime,
                    hasMilitia: entity.hasMilitia,
                    militiaOwner: entity.militiaOwner,
                    militiaFaction: entity.militiaFaction,
                    militiaType: entity.militiaType
                }
            }));

            // Broadcast entity removal (it's now "mobile" controlled by client)
            this.messageRouter.broadcastTo3x3Grid(fullChunkId, {
                type: 'object_removed',
                payload: {
                    chunkId: fullChunkId,
                    objectId: entityId,
                    isMobileClaim: true,
                    claimedBy: clientId
                }
            });

        } catch (error) {
            this.claimedMobileEntities.delete(entityId);
            console.error(`[MobileEntity] Error claiming ${entityId}:`, error);
            ws.send(JSON.stringify({
                type: responseType,
                payload: { entityId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle join_ship_crew message
     * Registers a gunner as aboard a ship2 so server knows not to delete it on pilot disconnect
     */
    async handleJoinShipCrew(ws, payload) {
        const { shipId, chunkKey, clientId, role } = payload;

        // Add ship to this client's tracked entities
        if (!this.clientMobileEntities.has(clientId)) {
            this.clientMobileEntities.set(clientId, []);
        }

        // Avoid duplicates
        const entities = this.clientMobileEntities.get(clientId);
        if (!entities.some(e => e.entityId === shipId)) {
            entities.push({
                entityId: shipId,
                entityType: 'ship2',
                chunkId: `chunk_${chunkKey}`,
                role: role  // 'portGunner' or 'starboardGunner'
            });
        }
    }

    /**
     * Handle leave_ship_crew message
     * Unregisters a crew member from a ship2
     */
    async handleLeaveShipCrew(ws, payload) {
        const { shipId, clientId } = payload;

        // Remove ship from this client's tracked entities
        const entities = this.clientMobileEntities.get(clientId);
        if (entities) {
            const idx = entities.findIndex(e => e.entityId === shipId);
            if (idx !== -1) {
                entities.splice(idx, 1);
            }
        }
    }

    /**
     * Handle update_mobile_entity_chunk message
     * Updates tracking when a claimed entity crosses chunk boundaries
     * This ensures disconnect cleanup can find entities that traveled far
     */
    handleUpdateMobileEntityChunk(ws, payload) {
        const { entityId, clientId, newChunkId, position } = payload;

        const entities = this.clientMobileEntities.get(clientId);
        if (entities) {
            const tracked = entities.find(e => e.entityId === entityId);
            if (tracked) {
                tracked.chunkId = newChunkId;
                if (position) {
                    tracked.lastPosition = position;
                }
            }
        }
    }

    /**
     * Handle release_mobile_entity message (generalized for boats, horses, etc.)
     * Adds an entity back to a chunk when a player dismounts/disembarks
     */
    async handleReleaseMobileEntity(ws, payload) {
        try {
            const { entityId, entityType, chunkKey, clientId, position, rotation, quality, lastRepairTime, inventory: clientInventory, owner: clientProvidedOwner, destroy, hasMilitia: clientHasMilitia, militiaOwner: clientMilitiaOwner, militiaFaction: clientMilitiaFaction, militiaType: clientMilitiaType } = payload;

            // Handle destroy case (ship sank with cargo - permanently remove entity)
            if (destroy) {
                const oldChunkId = `chunk_${chunkKey}`;
                const oldChunkData = await this.chunkManager.loadChunk(oldChunkId);

                if (oldChunkData && oldChunkData.objectChanges) {
                    const entity = oldChunkData.objectChanges.find(
                        obj => obj.id === entityId && obj.action === 'add' && obj.name === entityType
                    );

                    if (entity) {
                        // Validate ownership - only the claiming client can destroy
                        if (entity.claimedBy && entity.claimedBy !== clientId) {
                            console.warn(`[MobileEntity] Client ${clientId} tried to destroy ${entityId} claimed by ${entity.claimedBy}`);
                            return;
                        }

                        // Remove entity from chunk
                        oldChunkData.objectChanges = oldChunkData.objectChanges.filter(
                            obj => obj.id !== entityId
                        );
                        await this.chunkManager.saveChunk(oldChunkId, oldChunkData);

                        // Broadcast removal to nearby players
                        this.messageRouter.broadcastTo3x3Grid(oldChunkId, {
                            type: 'object_removed',
                            payload: {
                                chunkId: oldChunkId,
                                objectId: entityId
                            }
                        });
                    }
                }

                // Remove from disconnect tracking
                const clientEntities = this.clientMobileEntities.get(clientId);
                if (clientEntities) {
                    const index = clientEntities.findIndex(e => e.entityId === entityId);
                    if (index !== -1) {
                        clientEntities.splice(index, 1);
                    }
                    if (clientEntities.length === 0) {
                        this.clientMobileEntities.delete(clientId);
                    }
                }
                return;
            }

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[ReleaseMobileEntity] Invalid position:', position);
                return;
            }

            // Calculate new chunk from position (entity may have moved to different chunk)
            const newChunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use server-tracked chunk for old location (not client-provided chunkKey)
            // This prevents orphaned entities if client sends wrong chunk
            const trackedEntities = this.clientMobileEntities.get(clientId) || [];
            const tracked = trackedEntities.find(e => e.entityId === entityId);
            let oldChunkId = tracked?.chunkId || `chunk_${chunkKey}`;

            // Preserve inventory, owner, and factionId from original entity
            // Use client-provided owner as fallback (in case old chunk lookup fails)
            let entityInventory = null;
            let entityOwner = clientProvidedOwner || null;
            let entityFactionId = null;

            // Preserve militia fields for artillery with gunners
            // Use client-provided values as fallback (in case old chunk lookup fails)
            let entityHasMilitia = clientHasMilitia || false;
            let entityMilitiaOwner = clientMilitiaOwner || null;
            let entityMilitiaFaction = clientMilitiaFaction || null;
            let entityMilitiaType = clientMilitiaType || null;

            // Load old chunk to get entity data and remove claimed status
            let oldChunkData = await this.chunkManager.loadChunk(oldChunkId);
            let entity = oldChunkData?.objectChanges?.find(
                obj => obj.id === entityId && obj.action === 'add' && obj.name === entityType
            );

            // If not found in tracked chunk, try lastPosition (more accurate after long travel)
            if (!entity && tracked?.lastPosition) {
                const lastPos = tracked.lastPosition;
                const posX = Array.isArray(lastPos) ? lastPos[0] : lastPos.x;
                const posZ = Array.isArray(lastPos) ? lastPos[2] : lastPos.z;
                if (posX !== undefined && posZ !== undefined) {
                    const positionChunkId = ChunkCoordinates.worldToChunkId(posX, posZ);
                    if (positionChunkId !== oldChunkId) {
                        oldChunkData = await this.chunkManager.loadChunk(positionChunkId);
                        entity = oldChunkData?.objectChanges?.find(
                            obj => obj.id === entityId && obj.action === 'add' && obj.name === entityType
                        );
                        if (entity) {
                            oldChunkId = positionChunkId;  // Update to actual location
                        }
                    }
                }
            }

            if (entity) {
                // Validate ownership - only the claiming client can release
                if (entity.claimedBy && entity.claimedBy !== clientId) {
                    console.warn(`[MobileEntity] Client ${clientId} tried to release ${entityId} claimed by ${entity.claimedBy}`);
                    return;
                }

                // Preserve inventory, owner, and factionId from original entity
                // Server data takes precedence, but keep client-provided fallback if server has null
                entityInventory = entity.inventory;
                if (entity.owner) {
                    entityOwner = entity.owner;
                }
                if (entity.factionId !== undefined) {
                    entityFactionId = entity.factionId;
                }

                // Preserve militia fields from original entity
                if (entity.hasMilitia) {
                    entityHasMilitia = entity.hasMilitia;
                    entityMilitiaOwner = entity.militiaOwner;
                    entityMilitiaFaction = entity.militiaFaction;
                    entityMilitiaType = entity.militiaType;
                }

                if (oldChunkId !== newChunkId) {
                    // Remove from old chunk using filter (race-condition safe)
                    oldChunkData.objectChanges = oldChunkData.objectChanges.filter(
                        obj => obj.id !== entityId
                    );
                    await this.chunkManager.saveChunk(oldChunkId, oldChunkData);
                } else {
                    // Same chunk - update position, damage, and clear claim
                    entity.position = position;
                    entity.rotation = rotation;
                    entity.claimedBy = null;
                    entity.claimedAt = null;
                    // Persist damage (lastRepairTime) and quality from client
                    if (lastRepairTime !== undefined) {
                        entity.lastRepairTime = lastRepairTime;
                    }
                    if (quality !== undefined) {
                        entity.quality = quality;
                    }
                    // Persist inventory from client (may have fired artillery, moved items)
                    if (clientInventory !== undefined) {
                        entity.inventory = clientInventory;
                    }
                    await this.chunkManager.saveChunk(oldChunkId, oldChunkData);
                }
            } else if (clientProvidedOwner) {
                // Entity not found in tracked chunk or lastPosition chunk
                // This can happen if entity was already moved/deleted by another mechanism
                // We'll still add to new chunk (addObjectChange handles duplicates)
                console.warn(`[MobileEntity] Entity ${entityId} not found (tracked: ${tracked?.chunkId}, lastPos: ${tracked?.lastPosition ? JSON.stringify(tracked.lastPosition) : 'none'}), adding to ${newChunkId}`);
            }

            // Client-provided inventory takes precedence over stale chunk data
            // (player may have fired artillery, moved items in crate, etc.)
            if (clientInventory !== undefined) {
                entityInventory = clientInventory;
            }

            // If entity moved to different chunk, add to new chunk
            if (oldChunkId !== newChunkId) {
                const entityChange = {
                    action: 'add',
                    id: entityId,
                    name: entityType,
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality || 50,
                    lastRepairTime: lastRepairTime || Date.now(),
                    chunkId: newChunkId,
                    claimedBy: null,
                    claimedAt: null
                };

                // Preserve inventory for entities that have it (artillery, crate, etc.)
                if (entityInventory) {
                    entityChange.inventory = entityInventory;
                }

                // Preserve owner for ownership tracking
                if (entityOwner) {
                    entityChange.owner = entityOwner;
                }

                // Preserve factionId for flag display
                if (entityFactionId !== null) {
                    entityChange.factionId = entityFactionId;
                }

                // Preserve militia fields for artillery with gunners
                if (entityHasMilitia) {
                    entityChange.hasMilitia = entityHasMilitia;
                    entityChange.militiaOwner = entityMilitiaOwner;
                    entityChange.militiaFaction = entityMilitiaFaction;
                    entityChange.militiaType = entityMilitiaType;
                }

                await this.chunkManager.addObjectChange(newChunkId, entityChange);
            }

            // Calculate durability values
            const durabilityInfo = enrichStructureWithDurability({
                quality: quality || 50,
                lastRepairTime: lastRepairTime || Date.now(),
                name: entityType
            });

            // Look up owner name for broadcast (use stored factionId if available)
            const ownerName = entityOwner && this.authManager ?
                await this.authManager.getUsernameById(entityOwner) : null;
            // Use stored factionId from entity, fall back to lookup only if not stored
            const ownerFactionId = entityFactionId !== null ? entityFactionId :
                (entityOwner && this.authManager ? await this.authManager.getFactionById(entityOwner) : null);

            // Build broadcast payload
            const broadcastPayload = {
                chunkId: newChunkId,
                objectId: entityId,
                objectType: entityType,
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality || 50,
                currentDurability: durabilityInfo.currentDurability,
                hoursUntilRuin: durabilityInfo.hoursUntilRuin,
                owner: entityOwner,
                ownerName: ownerName,
                ownerFactionId: ownerFactionId,
                isMobileRelease: true
            };

            // Include inventory in broadcast for entities that have it
            if (entityInventory) {
                broadcastPayload.inventory = entityInventory;
            }

            // Include militia fields in broadcast for artillery with gunners
            if (entityHasMilitia) {
                broadcastPayload.hasMilitia = entityHasMilitia;
                broadcastPayload.militiaOwner = entityMilitiaOwner;
                broadcastPayload.militiaFaction = entityMilitiaFaction;
                broadcastPayload.militiaType = entityMilitiaType;
            }

            // Broadcast entity re-addition to nearby players
            this.messageRouter.broadcastTo3x3Grid(newChunkId, {
                type: 'object_added',
                payload: broadcastPayload
            });

            // Remove from disconnect tracking
            const clientEntities = this.clientMobileEntities.get(clientId);
            if (clientEntities) {
                const index = clientEntities.findIndex(e => e.entityId === entityId);
                if (index !== -1) {
                    clientEntities.splice(index, 1);
                }
                if (clientEntities.length === 0) {
                    this.clientMobileEntities.delete(clientId);
                }
            }

        } catch (error) {
            console.error('ERROR in release_mobile_entity:', error);
        }
    }

    /**
     * Handle switch_mobile_entity message - atomically release old and claim new
     * Prevents race conditions when switching between boats/vehicles
     */
    async handleSwitchMobileEntity(ws, payload) {
        const {
            clientId,
            // Old entity (to release)
            oldEntityId, oldEntityType, oldChunkKey, oldPosition, oldRotation,
            oldQuality, oldLastRepairTime, oldInventory, oldOwner,
            // New entity (to claim)
            newEntityId, newEntityType, newChunkKey
        } = payload;

        const newChunkId = `chunk_${newChunkKey}`;
        const responseType = `claim_${newEntityType}_response`;

        try {
            // Step 1: Check optimistic lock on new entity
            if (this.claimedMobileEntities.has(newEntityId)) {
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId: newEntityId, success: false, reason: 'Entity is already being claimed' }
                }));
                return;
            }

            // Optimistic lock on new entity
            this.claimedMobileEntities.set(newEntityId, { clientId, claimedAt: Date.now() });

            // Step 2: Load new entity chunk and validate
            const newChunkData = await this.chunkManager.loadChunk(newChunkId);
            if (!newChunkData || !newChunkData.objectChanges) {
                this.claimedMobileEntities.delete(newEntityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId: newEntityId, success: false, reason: 'Chunk not found' }
                }));
                return;
            }

            const newEntityIndex = newChunkData.objectChanges.findIndex(
                obj => obj.id === newEntityId && obj.action === 'add' && obj.name === newEntityType
            );

            if (newEntityIndex === -1) {
                this.claimedMobileEntities.delete(newEntityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId: newEntityId, success: false, reason: 'Entity not found' }
                }));
                return;
            }

            const newEntity = newChunkData.objectChanges[newEntityIndex];

            // Check if new entity is already claimed by someone else
            if (newEntity.claimedBy && newEntity.claimedBy !== clientId) {
                this.claimedMobileEntities.delete(newEntityId);
                ws.send(JSON.stringify({
                    type: responseType,
                    payload: { entityId: newEntityId, success: false, reason: 'Entity already claimed by another player' }
                }));
                return;
            }

            // Step 3: Release old entity (inline logic from handleReleaseMobileEntity)
            if (oldEntityId && oldEntityType) {
                // Validate old position
                if (validatePosition(oldPosition)) {
                    const newOldChunkId = ChunkCoordinates.worldToChunkId(oldPosition[0], oldPosition[2]);

                    // Use server-tracked chunk for old location
                    const trackedEntities = this.clientMobileEntities.get(clientId) || [];
                    const tracked = trackedEntities.find(e => e.entityId === oldEntityId);
                    const actualOldChunkId = tracked?.chunkId || `chunk_${oldChunkKey}`;

                    const oldChunkData = await this.chunkManager.loadChunk(actualOldChunkId);
                    if (oldChunkData && oldChunkData.objectChanges) {
                        const oldEntity = oldChunkData.objectChanges.find(
                            obj => obj.id === oldEntityId && obj.action === 'add' && obj.name === oldEntityType
                        );

                        if (oldEntity && (!oldEntity.claimedBy || oldEntity.claimedBy === clientId)) {
                            // Preserve data from old entity
                            const entityInventory = oldInventory !== undefined ? oldInventory : oldEntity.inventory;
                            const entityOwner = oldOwner || oldEntity.owner || null;
                            const entityFactionId = oldEntity.factionId !== undefined ? oldEntity.factionId : null;

                            if (actualOldChunkId !== newOldChunkId) {
                                // Entity moved chunks - remove from old, add to new
                                oldChunkData.objectChanges = oldChunkData.objectChanges.filter(
                                    obj => obj.id !== oldEntityId
                                );
                                await this.chunkManager.saveChunk(actualOldChunkId, oldChunkData);

                                // Add to new chunk
                                const entityChange = {
                                    action: 'add',
                                    id: oldEntityId,
                                    name: oldEntityType,
                                    position: oldPosition,
                                    rotation: oldRotation || 0,
                                    scale: 1.0,
                                    quality: oldQuality || 50,
                                    lastRepairTime: oldLastRepairTime || Date.now(),
                                    chunkId: newOldChunkId,
                                    claimedBy: null,
                                    claimedAt: null
                                };
                                if (entityInventory) entityChange.inventory = entityInventory;
                                if (entityOwner) entityChange.owner = entityOwner;
                                if (entityFactionId !== null) entityChange.factionId = entityFactionId;

                                await this.chunkManager.addObjectChange(newOldChunkId, entityChange);
                            } else {
                                // Same chunk - update in place
                                oldEntity.position = oldPosition;
                                oldEntity.rotation = oldRotation;
                                oldEntity.claimedBy = null;
                                oldEntity.claimedAt = null;
                                if (oldLastRepairTime !== undefined) oldEntity.lastRepairTime = oldLastRepairTime;
                                if (oldQuality !== undefined) oldEntity.quality = oldQuality;
                                if (oldInventory !== undefined) oldEntity.inventory = oldInventory;
                                await this.chunkManager.saveChunk(actualOldChunkId, oldChunkData);
                            }

                            // Calculate durability for broadcast
                            const durabilityInfo = enrichStructureWithDurability({
                                quality: oldQuality || 50,
                                lastRepairTime: oldLastRepairTime || Date.now(),
                                name: oldEntityType
                            });

                            const ownerName = entityOwner && this.authManager ?
                                await this.authManager.getUsernameById(entityOwner) : null;
                            const ownerFactionId = entityFactionId !== null ? entityFactionId :
                                (entityOwner && this.authManager ? await this.authManager.getFactionById(entityOwner) : null);

                            // Broadcast old entity re-addition
                            this.messageRouter.broadcastTo3x3Grid(newOldChunkId, {
                                type: 'object_added',
                                payload: {
                                    chunkId: newOldChunkId,
                                    objectId: oldEntityId,
                                    objectType: oldEntityType,
                                    position: oldPosition,
                                    rotation: oldRotation || 0,
                                    scale: 1.0,
                                    quality: oldQuality || 50,
                                    currentDurability: durabilityInfo.currentDurability,
                                    hoursUntilRuin: durabilityInfo.hoursUntilRuin,
                                    owner: entityOwner,
                                    ownerName: ownerName,
                                    ownerFactionId: ownerFactionId,
                                    isMobileRelease: true,
                                    inventory: entityInventory
                                }
                            });
                        }
                    }

                    // Remove old entity from tracking
                    const clientEntities = this.clientMobileEntities.get(clientId);
                    if (clientEntities) {
                        const index = clientEntities.findIndex(e => e.entityId === oldEntityId);
                        if (index !== -1) clientEntities.splice(index, 1);
                    }
                }
            }

            // Step 4: Claim new entity
            newEntity.claimedBy = clientId;
            newEntity.claimedAt = Date.now();
            await this.chunkManager.saveChunk(newChunkId, newChunkData);

            // Track new claimed entity
            if (!this.clientMobileEntities.has(clientId)) {
                this.clientMobileEntities.set(clientId, []);
            }
            this.clientMobileEntities.get(clientId).push({
                entityId: newEntityId,
                entityType: newEntityType,
                chunkId: newChunkId
            });

            // Release optimistic lock
            this.claimedMobileEntities.delete(newEntityId);

            // Send success response
            ws.send(JSON.stringify({
                type: responseType,
                payload: {
                    entityId: newEntityId,
                    success: true,
                    inventory: newEntity.inventory,
                    quality: newEntity.quality,
                    lastRepairTime: newEntity.lastRepairTime,
                    hasMilitia: newEntity.hasMilitia,
                    militiaOwner: newEntity.militiaOwner,
                    militiaFaction: newEntity.militiaFaction,
                    militiaType: newEntity.militiaType
                }
            }));

            // Broadcast new entity removal (now mobile)
            this.messageRouter.broadcastTo3x3Grid(newChunkId, {
                type: 'object_removed',
                payload: {
                    chunkId: newChunkId,
                    objectId: newEntityId,
                    isMobileClaim: true,
                    claimedBy: clientId
                }
            });

        } catch (error) {
            this.claimedMobileEntities.delete(newEntityId);
            console.error(`[MobileEntity] Error switching from ${oldEntityId} to ${newEntityId}:`, error);
            ws.send(JSON.stringify({
                type: responseType,
                payload: { entityId: newEntityId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Cleanup mobile entities claimed by a disconnected client
     * Called from server.js on ws.close
     */
    async cleanupMobileEntitiesForClient(clientId) {
        const entities = this.clientMobileEntities.get(clientId);
        if (!entities || entities.length === 0) {
            this.clientMobileEntities.delete(clientId);
            return;
        }

        // Water vehicles are removed on disconnect (can't be left floating in invalid positions)
        const WATER_VEHICLE_TYPES = ['ship', 'ship2', 'boat', 'sailboat'];

        for (const { entityId, entityType, chunkId, lastPosition } of entities) {
            try {
                // Calculate chunk directly from stored position (no searching needed!)
                let actualChunkId = chunkId;  // fallback to tracked chunk
                if (lastPosition) {
                    // Handle both array [x,y,z] and object {x,y,z} formats
                    const posX = Array.isArray(lastPosition) ? lastPosition[0] : lastPosition.x;
                    const posZ = Array.isArray(lastPosition) ? lastPosition[2] : lastPosition.z;
                    if (posX !== undefined && posZ !== undefined) {
                        actualChunkId = ChunkCoordinates.worldToChunkId(posX, posZ);
                    }
                }

                // Load the chunk and find the entity
                let chunkData = await this.chunkManager.loadChunk(actualChunkId);
                let entity = chunkData?.objectChanges?.find(
                    obj => obj.id === entityId && obj.claimedBy === clientId
                );

                // Fallback: if not found in calculated chunk, try original tracked chunk
                if (!entity && actualChunkId !== chunkId) {
                    chunkData = await this.chunkManager.loadChunk(chunkId);
                    entity = chunkData?.objectChanges?.find(
                        obj => obj.id === entityId && obj.claimedBy === clientId
                    );
                    if (entity) {
                        actualChunkId = chunkId;
                    }
                }

                if (entity) {
                    // Water vehicles: remove entirely on disconnect
                    // They can't be safely repositioned without water validation
                    if (WATER_VEHICLE_TYPES.includes(entityType)) {
                        // For ship2, check if other crew members are still aboard
                        if (entityType === 'ship2') {
                            let otherCrewAboard = false;
                            for (const [otherClientId, otherEntities] of this.clientMobileEntities) {
                                if (otherClientId !== clientId &&
                                    otherEntities.some(e => e.entityId === entityId)) {
                                    otherCrewAboard = true;
                                    break;
                                }
                            }

                            if (otherCrewAboard) {
                                // Others aboard - just clear claimedBy, don't delete ship
                                entity.claimedBy = null;
                                entity.claimedAt = null;
                                await this.chunkManager.saveChunk(actualChunkId, chunkData);
                                continue;  // Skip deletion, ship persists
                            }
                        }

                        // No one else aboard (or not ship2) - delete as before
                        // Remove from chunk data
                        chunkData.objectChanges = chunkData.objectChanges.filter(
                            obj => obj.id !== entityId
                        );
                        await this.chunkManager.saveChunk(actualChunkId, chunkData);

                        // Broadcast removal to all nearby clients
                        this.messageRouter.broadcastTo3x3Grid(actualChunkId, {
                            type: 'object_removed',
                            payload: {
                                chunkId: actualChunkId,
                                objectId: entityId
                            }
                        });

                        continue;
                    }

                    // Land vehicles (horse, cart, etc.): release in place
                    entity.claimedBy = null;
                    entity.claimedAt = null;
                    await this.chunkManager.saveChunk(actualChunkId, chunkData);

                    // Broadcast entity re-addition
                    const durabilityInfo = enrichStructureWithDurability({
                        quality: entity.quality || 50,
                        lastRepairTime: entity.lastRepairTime || Date.now(),
                        name: entityType
                    });

                    const cleanupPayload = {
                        chunkId: actualChunkId,
                        objectId: entityId,
                        objectType: entityType,
                        position: entity.position,
                        rotation: entity.rotation || 0,
                        scale: entity.scale || 1.0,
                        quality: entity.quality || 50,
                        owner: entity.owner,
                        currentDurability: durabilityInfo.currentDurability,
                        hoursUntilRuin: durabilityInfo.hoursUntilRuin,
                        isMobileRelease: true
                    };

                    // Include militia fields for artillery with gunners
                    if (entity.hasMilitia) {
                        cleanupPayload.hasMilitia = entity.hasMilitia;
                        cleanupPayload.militiaOwner = entity.militiaOwner;
                        cleanupPayload.militiaFaction = entity.militiaFaction;
                        cleanupPayload.militiaType = entity.militiaType;
                    }

                    this.messageRouter.broadcastTo3x3Grid(actualChunkId, {
                        type: 'object_added',
                        payload: cleanupPayload
                    });

                } else {
                    console.warn(`[MobileEntity] Could not find entity ${entityId} for cleanup (lastPosition: ${lastPosition ? JSON.stringify(lastPosition) : 'none'}, checked chunks: ${actualChunkId}${actualChunkId !== chunkId ? `, ${chunkId}` : ''})`);
                }
            } catch (error) {
                console.error(`[MobileEntity] Error cleaning up ${entityId}:`, error);
            }
        }

        this.clientMobileEntities.delete(clientId);
    }

    /**
     * Cleanup loaded crates for a disconnected client
     * Restores crates back to their original chunk
     * Called from server.js on ws.close
     */
    async cleanupLoadedCratesForClient(clientId) {
        // Find all crates loaded by this client
        const cratesToRelease = [];
        for (const [entityId, crateInfo] of this.loadedCrates) {
            if (crateInfo.clientId === clientId) {
                cratesToRelease.push({ entityId, ...crateInfo });
            }
        }

        if (cratesToRelease.length === 0) return;

        for (const { entityId, chunkId, inventory } of cratesToRelease) {
            try {
                const chunkData = await this.chunkManager.loadChunk(chunkId);
                if (!chunkData || !chunkData.objectChanges) continue;

                const crate = chunkData.objectChanges.find(
                    obj => obj.id === entityId && obj.name === 'crate' && obj.claimedBy === clientId
                );

                if (crate) {
                    // Clear claimed/locked status - restore crate to original state
                    delete crate.claimedBy;
                    delete crate.claimedAt;
                    delete crate.lockedBy;
                    delete crate.lockTime;

                    await this.chunkManager.saveChunk(chunkId, chunkData);

                    // Broadcast crate re-appearance at original position
                    const durabilityInfo = enrichStructureWithDurability({
                        quality: crate.quality || 50,
                        lastRepairTime: crate.lastRepairTime || Date.now(),
                        name: 'crate'
                    });

                    this.messageRouter.broadcastTo3x3Grid(chunkId, {
                        type: 'object_added',
                        payload: {
                            chunkId: chunkId,
                            objectId: entityId,
                            objectType: 'crate',
                            position: crate.position,
                            rotation: crate.rotation || 0,
                            scale: crate.scale || 1.0,
                            quality: crate.quality || 50,
                            currentDurability: durabilityInfo.currentDurability,
                            hoursUntilRuin: durabilityInfo.hoursUntilRuin,
                            inventory: inventory || crate.inventory || { items: [] },
                            isDisconnectRestore: true
                        }
                    });

                }

                // Remove from tracking
                this.loadedCrates.delete(entityId);
            } catch (error) {
                console.error(`[Crate] Error cleaning up crate ${entityId}:`, error);
                // Still remove from tracking to prevent memory leak
                this.loadedCrates.delete(entityId);
            }
        }
    }

    async handlePlaceCampfire(payload) {
        try {
            const { position, rotation, materialQuality, materialType, isBanditStructure, objectId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceCampfire] Invalid position:', position);
                return;
            }

            // Calculate chunk from position using unified CENTER-BASED system
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use provided objectId (for bandit structures) or generate unique ID
            const campfireId = objectId || `campfire_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Calculate quality from material quality and apply cap
            let quality = materialQuality || 50;  // Use stone quality, default to 50 if not provided
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['campfire'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Generate loot for bandit campfires
            const campfireInventory = isBanditStructure ? generateBanditCampfireLoot(campfireId) : [];

            // Create campfire structure object (actual 3D object with inventory)
            const campfireChange = {
                action: 'add',
                id: campfireId,
                name: 'campfire',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,  // Use calculated quality with material and cap
                lastRepairTime: Date.now(),  // Track when structure was created
                chunkId: chunkId,
                inventory: { items: campfireInventory },
                isBanditStructure: isBanditStructure || false,
                materialType: materialType || 'limestone'  // sandstone or limestone for visual tint
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, campfireChange);

            // Calculate durability values for broadcast
            const campfireDurabilityInfo = enrichStructureWithDurability(campfireChange);

            // Broadcast to all clients in 3x3 grid (using same format as regular structures)
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: campfireId,
                    objectType: 'campfire',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,  // Use calculated quality
                    currentDurability: campfireDurabilityInfo.currentDurability,
                    hoursUntilRuin: campfireDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    inventory: { items: campfireInventory },
                    isBanditStructure: isBanditStructure || false,
                    materialType: materialType || 'limestone'
                }
            });
        } catch (error) {
            console.error('ERROR in place_campfire:', error);
        }
    }

    /**
     * Handle place_tent message
     * Creates instant-build tent with 10x10 inventory
     * Also sets as player's home if they have an accountId
     */
    async handlePlaceTent(payload) {
        try {
            const { position, rotation, materialQuality, clientId, accountId, isBanditStructure, objectId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceTent] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use accountId for persistent ownership if available, otherwise fall back to clientId
            const ownerId = accountId || clientId;

            // Use provided objectId (for bandit structures) or generate unique ID
            const tentId = objectId || `tent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Calculate quality from material quality and apply cap
            let quality = materialQuality || 50;  // Use plank quality, default to 50
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['tent'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Generate loot for bandit tents
            const tentInventory = isBanditStructure ? generateBanditTentLoot(tentId) : [];

            // Create tent structure object (actual 3D object with 10x10 inventory)
            const tentChange = {
                action: 'add',
                id: tentId,
                name: 'tent',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,  // Use calculated quality with material and cap
                lastRepairTime: Date.now(),  // Track when structure was created
                chunkId: chunkId,
                inventory: { items: tentInventory },
                isBanditStructure: isBanditStructure || false,
                owner: ownerId  // Track who built the tent (for ownership transfer on registration)
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, tentChange);

            // Calculate durability values for broadcast
            const tentDurabilityInfo = enrichStructureWithDurability(tentChange);

            // Look up owner name and faction for display
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Broadcast to all clients in 3x3 grid (using same format as regular structures)
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: tentId,
                    objectType: 'tent',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,  // Use calculated quality
                    currentDurability: tentDurabilityInfo.currentDurability,
                    hoursUntilRuin: tentDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    inventory: { items: tentInventory },
                    isBanditStructure: isBanditStructure || false,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });

            // Set as player's home if they have an accountId (not for bandit tents)
            if (accountId && this.authManager && !isBanditStructure) {
                await this.authManager.setHome(accountId, tentId, position[0], position[2]);

                // Notify client their home was set
                this.messageRouter.sendToAccount(accountId, {
                    type: 'home_set',
                    payload: {
                        structureId: tentId,
                        x: position[0],
                        z: position[2]
                    }
                });
            }
        } catch (error) {
            console.error('ERROR in place_tent:', error);
        }
    }

    /**
     * Handle place_wall message
     * Creates instant-build wall (simple defensive structure, no inventory)
     */
    async handlePlaceWall(ws, payload) {
        try {
            const { position, rotation, materialQuality, materialType, clientId, accountId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceWall] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use accountId for persistent ownership if available, otherwise fall back to clientId
            const ownerId = accountId || clientId;

            // Generate unique ID
            const wallId = `wall_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Calculate quality from material quality (no cap for walls)
            const quality = materialQuality || 50;

            // Create wall structure object (no inventory)
            const wallChange = {
                action: 'add',
                id: wallId,
                name: 'wall',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                owner: ownerId,
                materialType: materialType || 'limestone'  // sandstone or limestone for visual tint
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, wallChange);

            // Calculate durability values for broadcast
            const wallDurabilityInfo = enrichStructureWithDurability(wallChange);

            // Look up owner name for display
            const ownerName = ownerId && this.authManager ? await this.authManager.getUsernameById(ownerId) : null;

            // Broadcast to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: wallId,
                    objectType: 'wall',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: wallDurabilityInfo.currentDurability,
                    hoursUntilRuin: wallDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    owner: ownerId,
                    ownerName: ownerName,
                    materialType: materialType || 'limestone'
                }
            });

            // Audit log wall placement
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logStructureAdd(
                    'wall', wallId,
                    parsed?.chunkX, parsed?.chunkZ,
                    clientId, accountId, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in place_wall:', error);
        }
    }

    /**
     * Handle place_outpost message
     * Creates instant-build outpost (for players and bandit camps)
     */
    async handlePlaceOutpost(payload) {
        try {
            const { position, rotation, materialQuality, isBanditStructure, objectId, clientId, accountId } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlaceOutpost] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use accountId for persistent ownership if available, otherwise fall back to clientId
            const ownerId = accountId || clientId || null;

            // Use provided objectId (for bandit structures) or generate unique ID
            const outpostId = objectId || `outpost_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Calculate quality from material quality and apply cap
            let quality = materialQuality || 50;
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.['outpost'];
            if (qualityCap !== undefined) {
                quality = Math.min(quality, qualityCap);
            }

            // Look up owner name and faction for display
            const [ownerName, ownerFactionId] = ownerId && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(ownerId),
                    this.authManager.getFactionById(ownerId)
                ]) : [null, null];

            // Create outpost structure object
            const outpostChange = {
                action: 'add',
                id: outpostId,
                name: 'outpost',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                isBanditStructure: isBanditStructure || false,
                owner: ownerId
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, outpostChange);

            // Calculate durability values for broadcast
            const outpostDurabilityInfo = enrichStructureWithDurability(outpostChange);

            // Broadcast to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: outpostId,
                    objectType: 'outpost',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: outpostDurabilityInfo.currentDurability,
                    hoursUntilRuin: outpostDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    isBanditStructure: isBanditStructure || false,
                    owner: ownerId,
                    ownerName: ownerName,
                    ownerFactionId: ownerFactionId
                }
            });
        } catch (error) {
            console.error('ERROR in place_outpost:', error);
        }
    }

    /**
     * Handle place_bearden message
     * Creates a brown bear den structure (procedurally generated)
     */
    async handlePlaceBearden(payload) {
        try {
            const { position, rotation, materialQuality, isBrownBearStructure, objectId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceBearden] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use provided objectId or generate unique ID
            const beardenId = objectId || `bearden_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Quality for procedural structures
            const quality = materialQuality || 30;

            // Create bearden structure object
            const beardenChange = {
                action: 'add',
                id: beardenId,
                name: 'bearden',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                isBrownBearStructure: isBrownBearStructure || false
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, beardenChange);

            // Calculate durability values for broadcast
            const beardenDurabilityInfo = enrichStructureWithDurability(beardenChange);

            // Broadcast to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: beardenId,
                    objectType: 'bearden',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: beardenDurabilityInfo.currentDurability,
                    hoursUntilRuin: beardenDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    isBrownBearStructure: isBrownBearStructure || false
                }
            });
        } catch (error) {
            console.error('ERROR in place_bearden:', error);
        }
    }

    /**
     * Handle place_deertree message
     * Creates a deer tree structure (procedurally generated, uses pine model)
     */
    async handlePlaceDeertree(payload) {
        try {
            const { position, rotation, materialQuality, isDeerTreeStructure, objectId } = payload;

            // Validate position
            if (!validatePosition(position)) {
                console.warn('[PlaceDeertree] Invalid position:', position);
                return;
            }

            // Calculate chunk from position
            const chunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Use provided objectId or generate unique ID
            const deertreeId = objectId || `deertree_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Quality for procedural structures
            const quality = materialQuality || 100;

            // Create deertree structure object (uses pine model visually)
            const deertreeChange = {
                action: 'add',
                id: deertreeId,
                name: 'deertree',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: quality,
                lastRepairTime: Date.now(),
                chunkId: chunkId,
                isDeerTreeStructure: isDeerTreeStructure || false
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(chunkId, deertreeChange);

            // Calculate durability values for broadcast
            const deertreeDurabilityInfo = enrichStructureWithDurability(deertreeChange);

            // Broadcast to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId: chunkId,
                    objectId: deertreeId,
                    objectType: 'deertree',
                    position: position,
                    rotation: rotation || 0,
                    scale: 1.0,
                    quality: quality,
                    currentDurability: deertreeDurabilityInfo.currentDurability,
                    hoursUntilRuin: deertreeDurabilityInfo.hoursUntilRuin,
                    totalResources: null,
                    remainingResources: null,
                    isDeerTreeStructure: isDeerTreeStructure || false
                }
            });
        } catch (error) {
            console.error('ERROR in place_deertree:', error);
        }
    }

    /**
     * Handle plant_tree message
     * Creates a growing tree that will mature over 30 minutes
     */
    async handlePlantTree(payload) {
        try {
            const { position, treeType, quality } = payload;

            // Validate position (ISSUE-064)
            if (!validatePosition(position)) {
                console.warn('[PlantTree] Invalid position:', position);
                return;
            }

            // Always calculate chunk from position using unified CENTER-BASED system
            // (ignore client-provided chunkId to ensure correct "chunk_X,Z" format)
            const finalChunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);

            // Generate unique ID for planted tree
            const treeId = `planted_${treeType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Vegetables start at 75% scale, trees start at 25%
            const initialScale = (treeType === 'vegetables' || treeType === 'hemp') ? 0.75 : 0.25;

            // Create planted tree object with growth tracking (tick-based)
            const plantedTreeChange = {
                action: 'add',
                id: treeId,
                name: treeType,  // Tree type (pine, fir, apple, vegetables)
                position: position,
                rotation: 0,
                scale: initialScale,  // Vegetables 75%, trees 25%
                quality: quality || 50,
                chunkId: finalChunkId,
                // Growth tracking fields (tick-based)
                isGrowing: true,
                plantedAtTick: this.serverTick || 0,
                growthDurationTicks: 1800, // 30 minutes
                // Tree-specific fields
                // Vegetables are one-time gather, no resource tracking needed
                totalResources: null,
                remainingResources: null
            };

            // Save to chunk file
            await this.chunkManager.addObjectChange(finalChunkId, plantedTreeChange);

            // Broadcast to all clients in 3x3 grid (tick-based)
            this.messageRouter.broadcastTo3x3Grid(finalChunkId, {
                type: 'tree_planted',
                payload: {
                    chunkId: finalChunkId,
                    objectId: treeId,
                    treeType: treeType,
                    position: position,
                    scale: initialScale,
                    quality: quality || 50,
                    isGrowing: true,
                    plantedAtTick: this.serverTick || 0,
                    growthDurationTicks: 1800
                }
            });
        } catch (error) {
            console.error('ERROR in plant_tree:', error);
        }
    }

    /**
     * Handle build_construction message
     */
    async handleBuildConstruction(ws, payload) {
        try {
            const { constructionId, chunkKey, materialType } = payload;
            const fullChunkId = `chunk_${chunkKey}`;
            const chunkData = await this.chunkManager.loadChunk(fullChunkId);

            // Find the construction site
            let constructionSite = null;
            if (Array.isArray(chunkData.objects)) {
                constructionSite = chunkData.objects.find(obj => obj.id === constructionId && obj.isConstructionSite);
            }
            if (!constructionSite && Array.isArray(chunkData.objectChanges)) {
                constructionSite = chunkData.objectChanges.find(c => c.action === 'add' && c.id === constructionId && c.isConstructionSite);
            }

            if (!constructionSite) {
                console.error(`Construction site ${constructionId} not found in chunk ${chunkKey}`);
                return;
            }

            // Calculate structure quality from materials
            const materials = constructionSite.materials || {};
            let totalQuality = 0;
            let materialCount = 0;

            for (const [materialType, data] of Object.entries(materials)) {
                // Materials now stored as {quantity: N, totalQuality: Q}
                if (typeof data === 'object' && data.quantity !== undefined && data.totalQuality !== undefined) {
                    totalQuality += data.totalQuality;
                    materialCount += data.quantity;
                } else if (typeof data === 'number') {
                    // Backwards compatibility: old format (just a number)
                    totalQuality += 50 * data;
                    materialCount += data;
                }
            }

            let structureQuality = clampQuality(materialCount > 0 ? Math.round(totalQuality / materialCount) : 50);

            // Apply structure-specific quality cap if defined
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.[constructionSite.targetStructure];
            if (qualityCap) {
                structureQuality = Math.min(structureQuality, qualityCap);
            }

            // Remove construction site
            await this.chunkManager.addObjectChange(fullChunkId, {
                action: 'remove',
                id: constructionId,
                chunkId: fullChunkId
            });

            // Generate ID for structure
            const structureId = `${constructionSite.targetStructure}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Look up owner name and faction EARLY so we can persist factionId on the structure
            const [ownerName, ownerFactionId] = constructionSite.owner && this.authManager ?
                await Promise.all([
                    this.authManager.getUsernameById(constructionSite.owner),
                    this.authManager.getFactionById(constructionSite.owner)
                ]) : [null, null];

            // Determine final Y position
            let finalY = constructionSite.finalFoundationY;

            // Determine scale
            let structureScale = 0.5;
            if (constructionSite.targetStructure === 'dock') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'crate') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'outpost') {
                structureScale = 1.0;
            // NOTE: Tent removed - now uses instant build via handlePlaceTent()
            // } else if (constructionSite.targetStructure === 'tent') {
            //     structureScale = 0.5;
            } else if (constructionSite.targetStructure === 'house') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'campfire') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'market') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'tileworks') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'ironworks') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'blacksmith') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'bakery') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'gardener') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'miner') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'woodcutter') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'stonemason') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'wall') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'fisherman') {
                structureScale = 1.0;
            } else if (constructionSite.targetStructure === 'warehouse') {
                structureScale = 1.0;
            }

            const structurePosition = [constructionSite.position[0], finalY, constructionSite.position[2]];
            const structureChange = {
                action: 'add',
                id: structureId,
                name: constructionSite.targetStructure,
                position: structurePosition,
                quality: structureQuality,
                lastRepairTime: Date.now(),  // Track when structure was created/last repaired
                scale: structureScale,
                chunkId: fullChunkId,
                totalResources: null,
                remainingResources: null,
                harvestedBy: null,
                harvestStartTime: null,
                rotation: constructionSite.rotation,
                finalFoundationY: finalY,  // Store for terrain leveling when chunk reloads
                owner: constructionSite.owner,  // Transfer ownership from construction site to structure
                factionId: ownerFactionId,  // Persist builder's faction on the structure
                materialType: materialType || null  // Track sandstone vs limestone for tinting
            };

            // Note: lastShipSpawn is NOT set on dock creation - it's only set when
            // a ship actually spawns via dock_ship_spawned. Ships can spawn immediately
            // because the spawn check uses (now - (lastShipSpawn || 0)) which is huge if 0.
            // Setting it to a past time would incorrectly trigger merchant spawns.

            // For houses, campfires, tileworks, ironworks, blacksmith, bakery, fisherman, and markets, initialize inventory (like crates)
            if (constructionSite.targetStructure === 'house' ||
                constructionSite.targetStructure === 'campfire' ||
                constructionSite.targetStructure === 'tileworks' ||
                constructionSite.targetStructure === 'ironworks' ||
                constructionSite.targetStructure === 'blacksmith' ||
                constructionSite.targetStructure === 'bakery' ||
                constructionSite.targetStructure === 'fisherman' ||
                constructionSite.targetStructure === 'market') {

                if (constructionSite.targetStructure === 'market') {
                    // Markets use quantities instead of items grid
                    const defaultQuantity = 0;
                    // New market inventory format: items[itemType][key] = count
                    // Key is "quality" for materials, "quality,durability" for tools/food
                    const defaultQuality = CONFIG.MARKET.DEFAULT_QUALITY;
                    const defaultDurability = CONFIG.MARKET.DEFAULT_DURABILITY;
                    const durabilityItems = CONFIG.MARKET.DURABILITY_ITEMS;

                    const marketItems = {};
                    for (const itemType of CONFIG.MARKET.ALL_ITEMS) {
                        if (durabilityItems.includes(itemType)) {
                            // Tools/Food: key is "quality,durability"
                            marketItems[itemType] = {
                                [`${defaultQuality},${defaultDurability}`]: defaultQuantity
                            };
                        } else {
                            // Materials: key is just "quality"
                            marketItems[itemType] = {
                                [defaultQuality]: defaultQuantity
                            };
                        }
                    }


                    structureChange.inventory = {
                        items: marketItems
                    };
                } else {
                    structureChange.inventory = { items: [] };
                }
            }

            await this.chunkManager.addObjectChange(fullChunkId, structureChange);

            // Handle house ownership - players can only own one house at a time
            if (constructionSite.targetStructure === 'house' && constructionSite.owner && this.authManager) {
                // Check if player already owns a house
                const existingHouse = await this.authManager.getOwnedHouse(constructionSite.owner);

                if (existingHouse.houseId && existingHouse.chunkId) {
                    // Clear ownership of old house
                    const oldHouse = await this.chunkManager.clearHouseOwnershipById(
                        existingHouse.chunkId,
                        existingHouse.houseId
                    );

                    if (oldHouse) {
                        // Broadcast ownership cleared to nearby players
                        this.messageRouter.broadcastTo3x3Grid(existingHouse.chunkId, {
                            type: 'object_added',
                            payload: {
                                chunkId: existingHouse.chunkId,
                                objectId: existingHouse.houseId,
                                objectType: 'house',
                                position: oldHouse.position,
                                quality: oldHouse.quality,
                                scale: oldHouse.scale || 1,
                                rotation: oldHouse.rotation || 0,
                                owner: null  // Ownership cleared
                            }
                        });
                    }
                }

                // Set new house as player's owned house
                await this.authManager.setOwnedHouse(constructionSite.owner, structureId, fullChunkId);

                // Also set as player's home spawn point
                const homeX = constructionSite.position[0];
                const homeZ = constructionSite.position[2];
                await this.authManager.setHome(constructionSite.owner, structureId, homeX, homeZ);

                // Notify client their home was set
                this.messageRouter.sendToAccount(constructionSite.owner, {
                    type: 'home_set',
                    payload: {
                        structureId: structureId,
                        x: homeX,
                        z: homeZ
                    }
                });
            }

            // Broadcast removal and addition
            this.messageRouter.broadcastTo3x3Grid(fullChunkId, {
                type: 'object_removed',
                payload: { chunkId: fullChunkId, objectId: constructionId }
            });

            // Calculate durability values for broadcast
            const durabilityInfo = enrichStructureWithDurability(structureChange);

            // ownerName and ownerFactionId already looked up earlier (before structureChange creation)

            const addedPayload = {
                chunkId: fullChunkId,
                objectId: structureId,
                objectType: constructionSite.targetStructure,
                position: structurePosition,
                quality: structureQuality,
                currentDurability: durabilityInfo.currentDurability,
                hoursUntilRuin: durabilityInfo.hoursUntilRuin,
                scale: structureScale,
                rotation: constructionSite.rotation,
                totalResources: null,
                materialType: materialType || null,  // Pass through for sandstone tinting
                remainingResources: null,
                owner: structureChange.owner,  // Include owner in broadcast
                ownerName: ownerName,  // Include display name
                ownerFactionId: ownerFactionId  // Include faction for artillery targeting
            };

            // Include inventory for houses, campfires, tileworks, ironworks, blacksmith, bakery, and markets
            if (constructionSite.targetStructure === 'house' ||
                constructionSite.targetStructure === 'campfire' ||
                constructionSite.targetStructure === 'tileworks' ||
                constructionSite.targetStructure === 'ironworks' ||
                constructionSite.targetStructure === 'blacksmith' ||
                constructionSite.targetStructure === 'bakery' ||
                constructionSite.targetStructure === 'market') {

                if (constructionSite.targetStructure === 'market') {
                    // Markets use NEW format: items[itemType][key] = count
                    // Use the same inventory that was saved to disk
                    addedPayload.inventory = structureChange.inventory;
                } else {
                    addedPayload.inventory = { items: [] };
                }
            }

            this.messageRouter.broadcastTo3x3Grid(fullChunkId, {
                type: 'object_added',
                payload: addedPayload
            });

            // Audit log structure completion
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(fullChunkId);
                this.auditLogger.logStructureAdd(
                    constructionSite.targetStructure, structureId,
                    parsed?.chunkX, parsed?.chunkZ,
                    ws.clientId, ws.accountId, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in build_construction:', error);
        }
    }

    /**
     * Handle update_construction_materials message
     * Updates the materials and quality tracking for a construction site
     */
    async handleUpdateConstructionMaterials(payload) {
        try {
            const { constructionId, chunkKey, materials, materialItems, clientId } = payload;
            const fullChunkId = `chunk_${chunkKey}`;
            const chunkData = await this.chunkManager.loadChunk(fullChunkId);

            // Find the construction site
            let constructionSite = null;
            if (Array.isArray(chunkData.objects)) {
                constructionSite = chunkData.objects.find(obj => obj.id === constructionId && obj.isConstructionSite);
            }
            if (!constructionSite && Array.isArray(chunkData.objectChanges)) {
                constructionSite = chunkData.objectChanges.find(c => c.action === 'add' && c.id === constructionId && c.isConstructionSite);
            }

            if (!constructionSite) {
                console.error(`Construction site ${constructionId} not found in chunk ${chunkKey}`);
                return;
            }

            // Update materials with quality tracking
            constructionSite.materials = materials;
            // Store materialItems for persistence (so new players joining get icons)
            constructionSite.materialItems = materialItems;

            // Save to disk
            await this.chunkManager.saveChunk(fullChunkId);

            // Broadcast to 3x3 grid (excluding sender) so peers see icons
            this.messageRouter.broadcastTo3x3GridExcluding(fullChunkId, {
                type: 'construction_materials_updated',
                payload: {
                    constructionId,
                    chunkKey,
                    materials,
                    materialItems
                }
            }, clientId);
        } catch (error) {
            console.error('ERROR in update_construction_materials:', error);
        }
    }

    // ==========================================
    // INVENTORY LOCKING SYSTEM
    // ==========================================

    /**
     * Lock timeout in milliseconds (30 seconds)
     * If a player holds a lock longer than this without activity, it can be taken
     * Note: Client confirms every 1.5s, so 30s gives ~20 confirmations before timeout
     */
    static LOCK_TIMEOUT = 30000;

    /**
     * Check if a structure's lock is stale (timed out)
     * @param {object} structure - The structure object
     * @returns {boolean} True if lock is stale or doesn't exist
     */
    isLockStale(structure) {
        if (!structure.lockedBy) return true;
        const lockAge = Date.now() - (structure.lockTime || 0);
        return lockAge > MessageHandlers.LOCK_TIMEOUT;
    }

    /**
     * Handle lock_inventory message
     * Attempts to acquire exclusive lock on a structure's inventory
     * Returns inventory data if lock acquired successfully
     */
    async handleLockInventory(ws, payload) {
        try {
            const { structureId, chunkId, position, scale, rotation } = payload;
            const clientId = ws.clientId;

            // Prevent race condition: block if another lock request is in progress
            // Without this, two simultaneous requests can both pass the lockedBy check
            // before either sets the lock (async gap between await and assignment)
            if (this.pendingLocks.has(structureId)) {
                ws.send(JSON.stringify({
                    type: 'inventory_lock_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'Another player is accessing this storage, please try again'
                    }
                }));
                return;
            }
            this.pendingLocks.add(structureId);

            try {
            let structure = await this.chunkManager.findObjectChange(chunkId, structureId);

            // APPLE TREE FIRST-TIME INTERACTION: Initialize with full inventory
            if (!structure && structureId.includes('_apple_')) {
                // Atomicity check: prevent race condition if two clients request simultaneously
                if (this.initializingAppleTrees.has(structureId)) {
                    ws.send(JSON.stringify({
                        type: 'inventory_lock_response',
                        payload: {
                            structureId,
                            success: false,
                            reason: 'Apple tree is being initialized, please try again'
                        }
                    }));
                    return;
                }
                this.initializingAppleTrees.add(structureId);
                try {
                    structure = await this.spawnTasks.initializeAppleTree(structureId, chunkId, position, scale, rotation);
                } finally {
                    this.initializingAppleTrees.delete(structureId);
                }
            }

            if (!structure) {
                ws.send(JSON.stringify({
                    type: 'inventory_lock_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'Structure not found'
                    }
                }));
                return;
            }

            // Apple trees: check and spawn regrown apples before returning inventory
            if (structure.name === 'apple' && this.spawnTasks && this.serverTick) {
                await this.spawnTasks.checkAndSpawnItems(structure, chunkId, this.serverTick);
            }

            // Check ownership for owner-protected structures
            const ownerProtectedStructures = ['house', 'tileworks', 'ironworks', 'blacksmith', 'bakery', 'fisherman'];
            if (ownerProtectedStructures.includes(structure.name) && structure.owner) {
                if (structure.owner !== clientId && structure.owner !== ws.accountId) {
                    ws.send(JSON.stringify({
                        type: 'inventory_lock_response',
                        payload: {
                            structureId,
                            success: false,
                            reason: `Only the ${structure.name} owner can access this inventory`
                        }
                    }));
                    return;
                }
            }

            // Check if sold to proprietor (locked for all players)
            if (structure.isSoldWorkerStructure) {
                ws.send(JSON.stringify({
                    type: 'inventory_lock_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'This structure is owned by a proprietor'
                    }
                }));
                return;
            }

            // Check if already locked by someone else
            const previousLocker = structure.lockedBy;
            const wasStale = this.isLockStale(structure);
            if (previousLocker && previousLocker !== clientId && !wasStale) {
                ws.send(JSON.stringify({
                    type: 'inventory_lock_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'This storage is being used by another player'
                    }
                }));
                return;
            }

            // If taking over a stale lock, notify the previous holder
            if (previousLocker && previousLocker !== clientId && wasStale) {
                this.messageRouter.sendToClient(previousLocker, {
                    type: 'lock_stolen',
                    payload: {
                        structureId,
                        chunkId,
                        reason: 'Lock timed out - another player took access'
                    }
                });
            }

            // Acquire lock
            structure.lockedBy = clientId;
            structure.lockTime = Date.now();

            // Save the lock state
            await this.chunkManager.saveChunk(chunkId);

            // Get inventory data - use appropriate default based on structure type
            let inventory;
            if (structure.name === 'market') {
                // Markets use object format: items[itemType][key] = count
                inventory = structure.inventory || { items: {} };
                if (!inventory.items || Array.isArray(inventory.items)) {
                    inventory.items = {};
                }
            } else {
                // Other structures use array format: items[]
                inventory = structure.inventory || { items: [] };
            }

            ws.send(JSON.stringify({
                type: 'inventory_lock_response',
                payload: {
                    structureId,
                    success: true,
                    inventory: inventory,
                    lockTime: structure.lockTime
                }
            }));

            // Broadcast lock state to nearby players (excluding the locking client)
            this.messageRouter.broadcastTo3x3GridExcluding(chunkId, {
                type: 'structure_lock_changed',
                payload: {
                    structureId,
                    chunkId,
                    lockedBy: clientId,
                    locked: true
                }
            }, clientId);

            } finally {
                this.pendingLocks.delete(structureId);
            }
        } catch (error) {
            console.error('ERROR in lock_inventory:', error);
            ws.send(JSON.stringify({
                type: 'inventory_lock_response',
                payload: {
                    structureId: payload.structureId,
                    success: false,
                    reason: 'Server error'
                }
            }));
        }
    }

    /**
     * Handle unlock_inventory message
     * Releases the lock on a structure's inventory
     */
    async handleUnlockInventory(ws, payload) {
        try {
            const { structureId, chunkId } = payload;
            const clientId = ws.clientId;

            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);

            if (!structure) {
                return;
            }

            // Only unlock if we hold the lock
            if (structure.lockedBy === clientId) {
                structure.lockedBy = null;
                structure.lockTime = null;
                await this.chunkManager.saveChunk(chunkId);

                // Broadcast unlock to nearby players
                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'structure_lock_changed',
                    payload: {
                        structureId,
                        chunkId,
                        lockedBy: null,
                        locked: false
                    }
                });
            }

        } catch (error) {
            console.error('ERROR in unlock_inventory:', error);
        }
    }

    /**
     * Handle confirm_lock message
     * Double-checks that client still holds the lock (race condition prevention)
     */
    async handleConfirmLock(ws, payload) {
        try {
            const { structureId, chunkId } = payload;
            const clientId = ws.clientId;

            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);

            if (!structure) {
                ws.send(JSON.stringify({
                    type: 'lock_confirm_response',
                    payload: { structureId, confirmed: false, reason: 'Structure not found' }
                }));
                return;
            }

            const stillHoldsLock = structure.lockedBy === clientId && !this.isLockStale(structure);

            if (stillHoldsLock) {
                // Refresh lock time (in-memory only - no DB save needed, locks are ephemeral)
                structure.lockTime = Date.now();
            }

            ws.send(JSON.stringify({
                type: 'lock_confirm_response',
                payload: {
                    structureId,
                    confirmed: stillHoldsLock,
                    reason: stillHoldsLock ? null : 'Lock no longer held'
                }
            }));

        } catch (error) {
            console.error('ERROR in confirm_lock:', error);
            ws.send(JSON.stringify({
                type: 'lock_confirm_response',
                payload: { structureId: payload.structureId, confirmed: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Release all locks held by a specific client
     * Called when a client disconnects
     * @param {string} clientId - The client ID whose locks should be released
     */
    async releaseAllLocksForClient(clientId) {
        try {
            const loadedChunks = this.chunkManager.getCachedChunkIds();
            let locksReleased = 0;

            for (const chunkId of loadedChunks) {
                const chunkData = await this.chunkManager.loadChunk(chunkId);
                if (!chunkData?.objectChanges) continue;

                let chunkModified = false;

                const unlockedStructures = [];

                for (const obj of chunkData.objectChanges) {
                    if (obj.lockedBy === clientId) {
                        obj.lockedBy = null;
                        obj.lockTime = null;
                        chunkModified = true;
                        locksReleased++;
                        unlockedStructures.push(obj.id);
                    }
                }

                if (chunkModified) {
                    await this.chunkManager.saveChunk(chunkId);

                    for (const structureId of unlockedStructures) {
                        this.messageRouter.broadcastTo3x3Grid(chunkId, {
                            type: 'structure_lock_changed',
                            payload: {
                                structureId,
                                chunkId,
                                lockedBy: null,
                                locked: false
                            }
                        });
                    }
                }
            }

        } catch (error) {
            console.error('ERROR in releaseAllLocksForClient:', error);
        }
    }

    /**
     * Handle get_crate_inventory message (also handles houses, gardens, apple trees)
     */
    async handleGetCrateInventory(ws, payload) {
        try {
            const { crateId, chunkId, position, scale, rotation } = payload;
            let crateChange = await this.chunkManager.findObjectChange(chunkId, crateId);

            // APPLE TREE FIRST-TIME INTERACTION: Initialize with full inventory
            // Match both planted trees (planted_apple_*) and natural trees (*_apple_* like 0,0_apple_3)
            if (!crateChange && crateId.includes('apple')) {
                // Atomicity check: prevent race condition if two clients request simultaneously
                if (this.initializingAppleTrees.has(crateId)) {
                    ws.send(JSON.stringify({
                        type: 'crate_inventory_response',
                        payload: {
                            crateId,
                            inventory: { items: [] },
                            accessDenied: true,
                            message: 'Apple tree is being initialized, please try again'
                        }
                    }));
                    return;
                }
                this.initializingAppleTrees.add(crateId);
                try {
                    crateChange = await this.spawnTasks.initializeAppleTree(crateId, chunkId, position, scale, rotation);
                } finally {
                    this.initializingAppleTrees.delete(crateId);
                }
            }

            // Check ownership for owner-protected structures
            const ownerProtectedStructures = ['house', 'tileworks', 'ironworks', 'blacksmith', 'bakery', 'fisherman'];
            if (crateChange && ownerProtectedStructures.includes(crateChange.name) && crateChange.owner) {
                // Check if the requesting client owns the structure
                if (crateChange.owner !== ws.clientId && crateChange.owner !== ws.accountId) {
                    // Not the owner - send access denied
                    ws.send(JSON.stringify({
                        type: 'crate_inventory_response',
                        payload: {
                            crateId,
                            inventory: { items: [] },
                            accessDenied: true,
                            message: `Only the ${crateChange.name} owner can access this inventory`
                        }
                    }));
                    return;
                }
            }

            // For apple trees, check and spawn items before returning inventory
            if (crateChange && crateChange.name === 'apple' && this.spawnTasks && this.serverTick) {
                const spawned = await this.spawnTasks.checkAndSpawnItems(crateChange, chunkId, this.serverTick);
                if (spawned > 0) {
                    await this.chunkManager.saveChunk(chunkId);
                }
            }

            let crateInventory = { items: [] };
            if (crateChange && crateChange.inventory) {
                crateInventory = crateChange.inventory;
            }

            // Build response payload
            const responsePayload = { crateId, inventory: crateInventory };

            // For apple trees, include spawning data for client-side display
            if (crateChange && crateChange.name === 'apple') {
                responsePayload.structureType = crateChange.name;
                responsePayload.quality = crateChange.quality || 50;
                responsePayload.lastSpawnTick = crateChange.lastSpawnTick || 0;
                responsePayload.serverTick = this.serverTick || 0;
            }

            ws.send(JSON.stringify({
                type: 'crate_inventory_response',
                payload: responsePayload
            }));

            // Audit log inventory open
            if (this.auditLogger && crateChange) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logInventoryOpen(
                    crateChange.name, crateId,
                    parsed?.chunkX, parsed?.chunkZ,
                    ws.clientId, ws.accountId,
                    crateChange.owner,
                    crateInventory, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in get_crate_inventory:', error);
        }
    }

    /**
     * Handle save_crate_inventory message (also handles houses)
     */
    async handleSaveCrateInventory(ws, payload) {
        try {
            const { crateId, chunkId, inventory } = payload;
            const clientId = ws.clientId;

            // Proximity validation: Check if player is in nearby chunk
            const clientData = this.clients.get(clientId);
            if (clientData && clientData.currentChunk) {
                const playerChunk = ChunkCoordinates.parseChunkIdSafe(clientData.currentChunk);
                const structureChunk = ChunkCoordinates.parseChunkIdSafe(chunkId);
                if (playerChunk && structureChunk) {
                    const dx = Math.abs(playerChunk.chunkX - structureChunk.chunkX);
                    const dz = Math.abs(playerChunk.chunkZ - structureChunk.chunkZ);
                    // Allow saves only if player is within 1 chunk of the structure
                    if (dx > 1 || dz > 1) {
                        ws.send(JSON.stringify({
                            type: 'crate_save_denied',
                            payload: {
                                crateId,
                                message: 'Too far from storage to save'
                            }
                        }));
                        return;
                    }
                }
            }

            const chunkData = await this.chunkManager.loadChunk(chunkId);

            const crateIndex = chunkData.objectChanges.findIndex(c => c.id === crateId && c.action === 'add');

            if (crateIndex !== -1) {
                const structure = chunkData.objectChanges[crateIndex];

                // BUGFIX: Markets should never receive save_crate_inventory
                // They use buy_item/sell_item for inventory changes
                if (structure.name === 'market') {
                    console.error(`[save_crate_inventory] REJECTED: Cannot save array inventory to market ${crateId}`);
                    return;
                }

                // Check if client holds the lock (new locking system)
                // For non-tent structures, require the client to hold the lock to save
                // This prevents race conditions where two players open the same crate
                // Exception: claimed entities (artillery/crates on ships) can save via claimedBy
                const isTent = structure.name === 'tent';
                const isClaimedByClient = structure.claimedBy === clientId;
                if (!isTent) {
                    // Non-tent structures require exclusive lock OR claim ownership
                    // claimedBy is set when artillery/crates are loaded onto ships
                    const hasLock = structure.lockedBy === clientId;
                    if (!hasLock && !isClaimedByClient) {
                        ws.send(JSON.stringify({
                            type: 'crate_save_denied',
                            payload: {
                                crateId,
                                message: 'You do not have access to this inventory'
                            }
                        }));
                        return;
                    }
                } else {
                    // Tents allow shared access - only block if someone ELSE has it locked
                    if (structure.lockedBy && structure.lockedBy !== clientId) {
                        ws.send(JSON.stringify({
                            type: 'crate_save_denied',
                            payload: {
                                crateId,
                                message: 'This storage is being used by another player'
                            }
                        }));
                        return;
                    }
                }

                // Check ownership for owner-protected structures
                if (OWNER_PROTECTED.has(structure.name) && structure.owner) {
                    // Check if the requesting client owns the structure
                    if (structure.owner !== ws.clientId && structure.owner !== ws.accountId) {
                        // Send error response
                        ws.send(JSON.stringify({
                            type: 'crate_save_denied',
                            payload: {
                                crateId,
                                message: `Only the ${structure.name} owner can modify this inventory`
                            }
                        }));
                        return;
                    }
                }

                // Refresh lock time on save (keeps lock alive during active use)
                if (structure.lockedBy === clientId) {
                    structure.lockTime = Date.now();
                }

                // Stamp firewood with placedAtTick for tick-based depletion tracking
                if (BURNING_STRUCTURES.has(structure.name) && inventory && Array.isArray(inventory.items)) {
                    const firewoodTypes = ['oakfirewood', 'pinefirewood', 'firfirewood', 'cypressfirewood', 'applefirewood'];
                    for (const item of inventory.items) {
                        if (firewoodTypes.includes(item.type) && !item.placedAtTick) {
                            item.placedAtTick = this.serverTick || 0;
                        }
                    }
                }

                // Update lastSpawnTick for apple trees (client-driven spawning)
                const isSpawningStructure = structure.name === 'apple';
                if (isSpawningStructure) {
                    structure.lastSpawnTick = this.serverTick || 0;
                }

                structure.inventory = inventory;
                await this.chunkManager.saveChunk(chunkId);

                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'crate_inventory_updated',
                    payload: { crateId, inventory }
                });

                // Audit log inventory save
                if (this.auditLogger) {
                    const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                    this.auditLogger.logInventorySave(
                        structure.name, crateId,
                        parsed?.chunkX, parsed?.chunkZ,
                        ws.clientId, ws.accountId,
                        structure.owner,
                        inventory, ws.username, ws.fingerprintHash
                    );
                }

                // Dispatch to processing systems based on structure type
                switch (structure.name) {
                    case 'campfire':
                        if (this.cookingSystem) {
                            this.cookingSystem.checkForCookableItems(crateId, chunkId, inventory, 'campfire');
                        }
                        break;
                    case 'house':
                        if (this.cookingSystem) {
                            this.cookingSystem.checkForCookableItems(crateId, chunkId, inventory, 'house');
                        }
                        break;
                    case 'tileworks':
                        if (this.tileworksSystem) {
                            this.tileworksSystem.checkForProcessableItems(crateId, chunkId, inventory);
                        }
                        break;
                    case 'ironworks':
                        if (this.ironworksSystem) {
                            this.ironworksSystem.checkForProcessableItems(crateId, chunkId, inventory);
                        }
                        break;
                    case 'blacksmith':
                        if (this.blacksmithSystem) {
                            this.blacksmithSystem.checkForProcessableItems(crateId, chunkId, inventory);
                        }
                        break;
                    case 'bakery':
                        if (this.bakerySystem) {
                            this.bakerySystem.checkForProcessableItems(crateId, chunkId, inventory);
                        }
                        break;
                    case 'fisherman':
                        if (this.fishermanSystem) {
                            this.fishermanSystem.checkForProcessableItems(crateId, chunkId, inventory);
                        }
                        break;
                }
            } else {
                console.error(`Storage structure ${crateId} not found in chunk ${chunkId}`);
            }
        } catch (error) {
            console.error('ERROR in save_crate_inventory:', error);
        }
    }

    /**
     * Handle sync_player_state message - periodic inventory/position sync for Resume feature
     * Only processes for authenticated (non-guest) players
     */
    async handleSyncPlayerState(ws, payload) {
        try {
            const clientData = this.clients.get(ws.clientId);
            if (!clientData) return;

            // Only for authenticated players (not guests)
            const accountId = clientData.accountId;
            if (!accountId || String(accountId).startsWith('session_')) {
                return;
            }

            const { inventory, slingItem, position, wasOnWaterVehicle } = payload;

            // Validate data
            if (!Array.isArray(inventory) || !position) {
                return;
            }

            // Save to database via AuthManager
            if (this.authManager) {
                await this.authManager.savePlayerSync(accountId, {
                    inventory,
                    slingItem: slingItem || null,
                    position,
                    wasOnWaterVehicle: !!wasOnWaterVehicle,
                    lastSyncAt: Date.now()
                });
            }
        } catch (error) {
            console.error('ERROR in sync_player_state:', error);
        }
    }

    /**
     * Handle clear_saved_session message - clears saved position/inventory
     * Prevents players from using Resume Last Session after dying or spawning
     * Uses payload.accountId as fallback since this message may arrive before join_chunk
     */
    async handleClearSavedSession(ws, payload) {
        try {
            // Use clientData accountId if available, fall back to payload accountId
            // (clear_saved_session is sent before join_chunk on initial page load)
            const clientData = this.clients.get(ws.clientId);
            const accountId = clientData?.accountId || payload?.accountId;
            if (!accountId || String(accountId).startsWith('session_')) {
                return;
            }

            // Clear session data via AuthManager
            if (this.authManager) {
                await this.authManager.clearPlayerSession(accountId);
            }
        } catch (error) {
            console.error('ERROR in clear_saved_session:', error);
        }
    }

    /**
     * Handle buy_item message - player purchases item from market
     * New format: buys specific quality (and durability for tools/food)
     */
    async handleBuyItem(ws, payload) {
        try {
            const { marketId, chunkId, itemType, quality, durability, transactionId } = payload;

            // Find market
            const marketChange = await this.chunkManager.findObjectChange(chunkId, marketId);
            if (!marketChange || !marketChange.inventory) {
                console.error(`Market ${marketId} not found or has no inventory`);
                return;
            }

            const inventory = marketChange.inventory;
            const durabilityItems = CONFIG.MARKET.DURABILITY_ITEMS;
            const hasDurability = durabilityItems.includes(itemType);

            // Ensure items object exists for this type
            if (!inventory.items[itemType]) {
                console.error(`Item type ${itemType} not found in market`);
                return;
            }

            // Build the key based on whether item has durability
            const key = hasDurability
                ? `${Math.floor(quality)},${Math.floor(durability || 50)}`
                : `${Math.floor(quality)}`;

            // Check if item exists at this key
            const currentCount = inventory.items[itemType][key] || 0;
            if (currentCount < 1) {
                console.error(`No ${itemType} at ${key} in market. Available: ${currentCount}`);
                return;
            }

            // Decrease count
            inventory.items[itemType][key] = currentCount - 1;

            // Clean up if count reaches 0
            if (inventory.items[itemType][key] <= 0) {
                delete inventory.items[itemType][key];
            }

            // Enemy raid detection: accelerate decay if enemy faction is buying
            let structureUpdated = false;
            if (marketChange.owner && this.authManager) {
                const [accessorFaction, ownerFaction] = await Promise.all([
                    this.authManager.getFactionById(ws.accountId),
                    this.authManager.getFactionById(marketChange.owner)
                ]);

                // Check if this is an enemy raid (both have factions, and they differ)
                const isEnemyRaid = accessorFaction && ownerFaction && accessorFaction !== ownerFaction;

                if (isEnemyRaid) {
                    // Calculate current remaining time
                    const now = Date.now();
                    const marketQuality = marketChange.quality || 50;
                    const maxLifespanHours = Math.pow(marketQuality, DECAY_EXPONENT);
                    const elapsedMs = now - (marketChange.lastRepairTime || now);
                    const elapsedHours = elapsedMs / (1000 * 60 * 60);
                    const remainingHours = maxLifespanHours - elapsedHours;

                    const ENEMY_RAID_LIFESPAN_HOURS = 0.25; // 15 minutes

                    // Only accelerate decay if current remaining > 15 minutes
                    if (remainingHours > ENEMY_RAID_LIFESPAN_HOURS) {
                        // Calculate new lastRepairTime so remaining = 15 minutes
                        const newElapsedHours = maxLifespanHours - ENEMY_RAID_LIFESPAN_HOURS;
                        const newLastRepairTime = now - (newElapsedHours * 60 * 60 * 1000);

                        marketChange.lastRepairTime = newLastRepairTime;
                        structureUpdated = true;
                    }
                }
            }

            // Save to disk
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast updated inventory to all players near the market
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_inventory_updated',
                payload: {
                    marketId,
                    items: inventory.items,
                    transactionId: transactionId || null
                }
            });

            // If structure was damaged by enemy raid, broadcast the decay update
            if (structureUpdated) {
                const durabilityInfo = enrichStructureWithDurability(marketChange);
                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'structure_damaged',
                    payload: {
                        structureId: marketId,
                        chunkId: chunkId,
                        lastRepairTime: marketChange.lastRepairTime,
                        currentDurability: durabilityInfo.currentDurability,
                        hoursUntilRuin: durabilityInfo.hoursUntilRuin
                    }
                });
            }

            // Audit log market buy
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logMarketBuy(
                    marketId,
                    parsed?.chunkX, parsed?.chunkZ,
                    ws.clientId, ws.accountId,
                    marketChange.owner,
                    itemType, quality, durability, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in buy_item:', error);
        }
    }

    /**
     * Handle sell_item message - player sells item to market
     * New format: stores exact quality (and durability for tools/food)
     */
    async handleSellItem(ws, payload) {
        try {
            const { marketId, chunkId, itemType, quality, durability, transactionId } = payload;

            // Find market
            const marketChange = await this.chunkManager.findObjectChange(chunkId, marketId);
            if (!marketChange) {
                console.error(`Market ${marketId} not found`);
                return;
            }

            // Initialize inventory if missing (handles legacy markets)
            if (!marketChange.inventory) {
                marketChange.inventory = { items: {} };
            }
            if (!marketChange.inventory.items) {
                marketChange.inventory.items = {};
            }

            const inventory = marketChange.inventory;
            const durabilityItems = CONFIG.MARKET.DURABILITY_ITEMS;
            const hasDurability = durabilityItems.includes(itemType);

            // Ensure items object exists for this type
            if (!inventory.items[itemType]) {
                inventory.items[itemType] = {};
            }

            // Build the key based on whether item has durability
            const key = hasDurability
                ? `${Math.floor(quality)},${Math.floor(durability || 50)}`
                : `${Math.floor(quality)}`;

            // Increment count at this key
            const currentCount = inventory.items[itemType][key] || 0;
            inventory.items[itemType][key] = currentCount + 1;

            // Save to disk
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast updated inventory to all players near the market
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_inventory_updated',
                payload: {
                    marketId,
                    items: inventory.items,
                    transactionId: transactionId || null
                }
            });

            // Audit log market sell
            if (this.auditLogger) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                this.auditLogger.logMarketSell(
                    marketId,
                    parsed?.chunkX, parsed?.chunkZ,
                    ws.clientId, ws.accountId,
                    marketChange.owner,
                    itemType, quality, durability, ws.username, ws.fingerprintHash
                );
            }
        } catch (error) {
            console.error('ERROR in sell_item:', error);
        }
    }

    /**
     * Handle horse purchase from market
     * Creates horse at player position, saves to chunk, broadcasts to all players
     */
    async handleBuyHorse(ws, payload) {
        const { marketId, chunkId, quality, position, rotation, transactionId } = payload;
        const clientId = ws.clientId;
        const accountId = ws.accountId;

        // Validate position was provided
        if (!position || !Array.isArray(position) || position.length < 3) {
            console.error('[BuyHorse] Missing or invalid position:', position);
            return;
        }

        // Find market using existing pattern
        const market = await this.chunkManager.findObjectChange(chunkId, marketId);
        if (!market?.inventory?.items?.horse) {
            console.error('[BuyHorse] No horses in market', marketId);
            return;
        }

        // Check stock at this quality
        const key = `${Math.floor(quality)}`;
        const count = market.inventory.items.horse[key] || 0;
        if (count < 1) {
            console.error('[BuyHorse] No horse at quality', quality);
            return;
        }

        // Decrement market stock
        market.inventory.items.horse[key] = count - 1;
        if (market.inventory.items.horse[key] <= 0) {
            delete market.inventory.items.horse[key];
        }

        // Save market chunk
        await this.chunkManager.saveChunk(chunkId);

        // Broadcast market update to nearby players
        this.messageRouter.broadcastTo3x3Grid(chunkId, {
            type: 'market_inventory_updated',
            payload: { marketId, items: market.inventory.items, transactionId }
        });

        // --- Create horse structure (same pattern as handlePlaceHorse) ---

        // Calculate chunk from player position (horse spawns at player)
        const horseChunkId = ChunkCoordinates.worldToChunkId(position[0], position[2]);
        const horseId = `horse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const ownerId = accountId || clientId;

        // Create horse structure object
        const horseChange = {
            action: 'add',
            id: horseId,
            name: 'horse',
            position: position,
            rotation: rotation || 0,
            scale: 1.0,
            quality: Math.floor(quality),
            lastRepairTime: Date.now(),
            chunkId: horseChunkId,
            owner: ownerId
        };

        // Save horse to chunk file
        await this.chunkManager.addObjectChange(horseChunkId, horseChange);

        // Calculate durability values
        const horseDurabilityInfo = enrichStructureWithDurability(horseChange);

        // Look up owner name
        const ownerName = ownerId && this.authManager ?
            await this.authManager.getUsernameById(ownerId) : null;

        // Broadcast horse creation to all nearby clients (including buyer)
        this.messageRouter.broadcastTo3x3Grid(horseChunkId, {
            type: 'object_added',
            payload: {
                chunkId: horseChunkId,
                objectId: horseId,
                objectType: 'horse',
                position: position,
                rotation: rotation || 0,
                scale: 1.0,
                quality: Math.floor(quality),
                currentDurability: horseDurabilityInfo.currentDurability,
                hoursUntilRuin: horseDurabilityInfo.hoursUntilRuin,
                owner: ownerId,
                ownerName: ownerName
            }
        });

        // Send horse_purchased to buying client for auto-mount
        ws.send(JSON.stringify({
            type: 'horse_purchased',
            payload: { quality, horseId, transactionId }
        }));

    }

    /**
     * Handle horse sale to market
     */
    async handleSellHorse(ws, payload) {
        const { marketId, chunkId, entityId, quality, transactionId } = payload;

        // Find market
        const market = await this.chunkManager.findObjectChange(chunkId, marketId);
        if (!market) {
            console.error('[SellHorse] Market not found:', marketId);
            return;
        }

        // Initialize horse inventory if needed
        if (!market.inventory) market.inventory = { items: {} };
        if (!market.inventory.items) market.inventory.items = {};
        if (!market.inventory.items.horse) market.inventory.items.horse = {};

        // Add horse to market inventory
        const key = `${Math.floor(quality)}`;
        const currentCount = market.inventory.items.horse[key] || 0;
        market.inventory.items.horse[key] = currentCount + 1;

        // Save chunk
        await this.chunkManager.saveChunk(chunkId);

        // Broadcast market update
        this.messageRouter.broadcastTo3x3Grid(chunkId, {
            type: 'market_inventory_updated',
            payload: { marketId, items: market.inventory.items, transactionId }
        });

    }

    /**
     * Handle remove_object_request message (includes cascade deletion logic)
     */
    async handleRemoveObject(ws, payload) {
        const { chunkId, objectId, name, position, quality, scale, objectData } = payload;
        const chunkData = await this.chunkManager.loadChunk(chunkId);

        // Check if this object exists with ANY action (add or remove)
        let objectIndex = chunkData.objectChanges.findIndex(c => c.id === objectId);

        // If not found and objectData provided, this is a natural object on first interaction
        if (objectIndex === -1 && objectData) {
            const changeEntry = {
                action: 'add',
                id: objectId,
                name: objectData.name,
                position: objectData.position,
                quality: objectData.quality,
                scale: objectData.scale,
                totalResources: objectData.totalResources,
                remainingResources: objectData.remainingResources,
                chunkId: chunkId,
                harvestedBy: null,
                harvestStartTime: null
            };

            chunkData.objectChanges.push(changeEntry);
            await this.chunkManager.saveChunk(chunkId);
            objectIndex = chunkData.objectChanges.length - 1;
        }

        // Get existing object data for needsRemoveEntry check
        const existingObject = objectIndex !== -1 ? chunkData.objectChanges[objectIndex] : null;

        // Artillery with militia: only owner or enemy faction can demolish
        if (existingObject && existingObject.name === 'artillery' && existingObject.hasMilitia) {
            const isOwner = existingObject.owner === ws.clientId || existingObject.owner === ws.accountId;
            const isEnemy = ws.factionId && existingObject.factionId && ws.factionId !== existingObject.factionId;
            if (!isOwner && !isEnemy) {
                return;
            }
        }

        // Check if this object needs a "remove" entry (procedural) or can be deleted entirely
        if (needsRemoveEntry(name, existingObject)) {
            // Procedural object - needs "remove" entry so client knows it's gone
            const change = { action: 'remove', id: objectId, name, position, quality, scale, chunkId };
            await this.chunkManager.addObjectChange(chunkId, change);
        } else {
            // Non-procedural (player-built, logs) - just delete the entry entirely
            if (objectIndex !== -1) {
                chunkData.objectChanges.splice(objectIndex, 1);
                await this.chunkManager.saveChunk(chunkId);
            }
        }

        // Audit log structure removal
        if (this.auditLogger) {
            const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
            this.auditLogger.logStructureRemove(
                name, objectId,
                parsed?.chunkX, parsed?.chunkZ,
                ws.clientId, ws.accountId,
                existingObject?.owner, ws.username, ws.fingerprintHash
            );
        }

        this.messageRouter.broadcastTo3x3Grid(chunkId, {
            type: 'object_removed',
            payload: { chunkId, objectId, name, position, quality, scale }
        });
    }

    /**
     * Handle harvest_resource_request message
     */
    async handleHarvestResource(ws, payload) {
        try {
            const { chunkId, objectId, harvestType, clientId, objectData } = payload;
            const chunkData = await this.chunkManager.loadChunk(chunkId);

            // First, check if this resource exists with ANY action (add or remove)
            let resourceIndex = chunkData.objectChanges.findIndex(c => c.id === objectId);

            // If found with action='remove', it's already depleted - reject the request
            if (resourceIndex !== -1 && chunkData.objectChanges[resourceIndex].action === 'remove') {
                console.warn(`Resource ${objectId} already depleted, rejecting harvest request`);
                this.messageRouter.sendToClient(clientId, {
                    type: 'harvest_lock_failed',
                    payload: {
                        objectId,
                        reason: 'This resource has already been depleted'
                    }
                });
                return;
            }

            // Create change entry for natural resources on first interaction
            if (resourceIndex === -1) {
                // Reject if client sends depleted resource (stale cache after log was already deleted)
                if (objectData.remainingResources !== undefined && objectData.remainingResources <= 0) {
                    return;
                }

                const changeEntry = {
                    action: 'add',
                    id: objectId,
                    name: objectData.name,
                    position: objectData.position,
                    quality: objectData.quality,
                    scale: objectData.scale,
                    totalResources: objectData.totalResources,
                    remainingResources: objectData.remainingResources,
                    chunkId: chunkId,
                    harvestedBy: null,
                    harvestStartTime: null
                };

                chunkData.objectChanges.push(changeEntry);
                resourceIndex = chunkData.objectChanges.length - 1;
            }

            const resource = chunkData.objectChanges[resourceIndex];
            const now = Date.now();

            // Check if resource is locked by another player
            if (resource.harvestedBy && resource.harvestedBy !== clientId) {
                const lockAge = now - (resource.harvestStartTime || 0);
                if (lockAge < 15000) {
                    // Still locked
                    this.messageRouter.sendToClient(clientId, {
                        type: 'harvest_lock_failed',
                        payload: {
                            objectId,
                            reason: 'Another player is harvesting this resource'
                        }
                    });
                    return;
                } else {
                    // Lock timed out - clear stale lock
                    resource.harvestedBy = null;
                    resource.harvestStartTime = null;
                }
            }

            // Acquire lock
            resource.harvestedBy = clientId;
            resource.harvestStartTime = now;

            // Decrement resources
            if (resource.remainingResources > 0) {
                resource.remainingResources -= 1;

                if (resource.remainingResources <= 0) {
                    // Check if this is a procedural resource (trees, rocks) or dynamic (logs)
                    if (needsRemoveEntry(resource.name, resource)) {
                        // Procedural - mark as removed so client knows not to render
                        resource.action = 'remove';
                        resource.harvestedBy = null;
                        resource.harvestStartTime = null;
                    } else {
                        // Dynamic (logs) - delete entry entirely
                        chunkData.objectChanges.splice(resourceIndex, 1);
                    }
                } else {
                    resource.harvestedBy = null;
                    resource.harvestStartTime = null;
                }

                await this.chunkManager.saveChunk(chunkId);

                // Audit log the harvest
                if (this.auditLogger) {
                    const parsed = ChunkCoordinates.parseChunkIdSafe(chunkId);
                    this.auditLogger.logHarvest(
                        resource.name, objectId,
                        parsed?.chunkX, parsed?.chunkZ,
                        clientId, ws.accountId,
                        resource.remainingResources, ws.username, ws.fingerprintHash
                    );
                }

                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'resource_harvested',
                    payload: {
                        chunkId,
                        objectId,
                        harvestType,
                        remainingResources: resource.remainingResources,
                        depleted: resource.remainingResources <= 0,
                        harvestedBy: clientId
                    }
                });
            }
        } catch (error) {
            console.error('ERROR in harvest_resource_request:', error);
        }
    }

    /**
     * Handle WebRTC signaling messages (offer, answer, ice_candidate)
     */
    handleWebRTCSignaling(messageType, rawMessage, payload) {
        const recipientId = payload.recipientId;
        const senderId = payload.senderId;
        this.messageRouter.forwardMessage(senderId, recipientId, rawMessage);
    }

    // NOTE: Firewood depletion methods removed - now handled client-side via tick-based calculation
    // See CrateInventoryUI._calculateFirewoodDurability() and _checkAndRemoveDepletedFirewood()

    // NOTE: processCooking() removed - cooking now handled client-side via tick calculation
    // Client sends 'cooking_complete' message when item is ready

    /**
     * Handle cooking_complete message from client
     * Validates and transforms cooked item
     */
    async handleCookingComplete(ws, payload) {
        const { structureId, itemId, chunkId } = payload;

        if (!structureId || !itemId || !chunkId) {
            console.error('[COOKING] Invalid cooking_complete payload:', payload);
            return;
        }

        if (!this.cookingSystem) {
            console.error('[COOKING] CookingSystem not initialized');
            return;
        }

        const result = await this.cookingSystem.completeCooking(structureId, itemId, chunkId);

    }

    /**
     * Handle processing_complete message from client (for tileworks and ironworks)
     * Validates and transforms processed item
     */
    async handleProcessingComplete(ws, payload) {
        const { structureId, itemId, chunkId } = payload;

        if (!structureId || !itemId || !chunkId) {
            console.error('[PROCESSING] Invalid processing_complete payload:', payload);
            return;
        }

        try {
            // Load chunk to determine structure type
            const chunkData = await this.chunkManager.loadChunk(chunkId);
            const structure = chunkData.objectChanges.find(
                c => c.id === structureId && c.action === 'add'
            );

            if (!structure) {
                console.error(`[PROCESSING] Structure ${structureId} not found in chunk ${chunkId}`);
                return;
            }

            // Route to appropriate processing system based on structure type
            if (structure.name === 'tileworks') {
                if (!this.tileworksSystem) {
                    console.error('[TILEWORKS] TileworksSystem not initialized');
                    return;
                }
                await this.tileworksSystem.completeProcessing(structureId, itemId, chunkId);
            } else if (structure.name === 'ironworks') {
                if (!this.ironworksSystem) {
                    console.error('[IRONWORKS] IronworksSystem not initialized');
                    return;
                }
                await this.ironworksSystem.completeProcessing(structureId, itemId, chunkId);
            } else if (structure.name === 'blacksmith') {
                if (!this.blacksmithSystem) {
                    console.error('[BLACKSMITH] BlacksmithSystem not initialized');
                    return;
                }
                await this.blacksmithSystem.completeProcessing(structureId, itemId, chunkId);
            } else if (structure.name === 'bakery') {
                if (!this.bakerySystem) {
                    console.error('[BAKERY] BakerySystem not initialized');
                    return;
                }
                await this.bakerySystem.completeProcessing(structureId, itemId, chunkId);
            } else if (structure.name === 'fisherman') {
                if (!this.fishermanSystem) {
                    console.error('[FISHERMAN] FishermanSystem not initialized');
                    return;
                }
                await this.fishermanSystem.completeProcessing(structureId, itemId, chunkId);
            } else {
                console.error(`[PROCESSING] Unknown processing structure type: ${structure.name}`);
            }
        } catch (error) {
            console.error('[PROCESSING] Error handling processing_complete:', error);
        }
    }

    // NOTE: processTileworks() removed - processing now handled client-side via tick calculation
    // Client sends 'processing_complete' message when item is ready

    /**
     * Clean up stale players from chunk files
     * Called by TimeTrackerService every minute
     */
    async cleanupStalePlayers() {
        try {
            // Track all stale players to clean up their resources
            const allStalePlayerIds = new Set();

            for (const chunkId of this.chunkManager.getCachedChunkIds()) {
                const chunkData = this.chunkManager.getChunk(chunkId);
                if (!chunkData || !chunkData.players) continue;

                const playersToRemove = [];

                chunkData.players.forEach(player => {
                    const clientData = this.clients.get(player.id);
                    // Check if client is disconnected or WebSocket is not open
                    if (!clientData || !clientData.ws || clientData.ws.readyState !== 1) { // 1 = OPEN
                        playersToRemove.push(player.id);
                        allStalePlayerIds.add(player.id);
                    }
                });

                if (playersToRemove.length > 0) {
                    chunkData.players = chunkData.players.filter(p => !playersToRemove.includes(p.id));
                    await this.chunkManager.saveChunk(chunkId);
                    this.messageRouter.queueProximityUpdate(chunkId);
                }
            }

            // Clean up resources for all stale players (same as ws.on('close'))
            for (const clientId of allStalePlayerIds) {
                await this.releaseAllLocksForClient(clientId);
                await this.cleanupMobileEntitiesForClient(clientId);
                await this.cleanupLoadedCratesForClient(clientId);
            }
        } catch (error) {
            console.error('ERROR in cleanupStalePlayers:', error);
        }
    }

    // NOTE: processTreeGrowth() removed - tree growth now handled client-side via tick calculation
    // Client calculates scale from plantedAtTick and sends 'tree_growth_complete' when done

    /**
     * Handle tree_growth_complete message from client
     * Validates and marks tree as fully grown
     */
    async handleTreeGrowthComplete(ws, payload) {
        const { treeId, chunkId } = payload;

        if (!treeId || !chunkId) {
            console.error('[TREE GROWTH] Invalid tree_growth_complete payload:', payload);
            return;
        }

        try {
            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData?.objectChanges) return;

            const treeIndex = chunkData.objectChanges.findIndex(
                obj => obj.id === treeId && obj.action === 'add'
            );

            if (treeIndex === -1) {
                console.warn(`[TREE GROWTH] Tree ${treeId} not found in chunk ${chunkId}`);
                return;
            }

            const tree = chunkData.objectChanges[treeIndex];

            // Validate tree was growing and enough ticks elapsed
            if (!tree.isGrowing || !tree.plantedAtTick) {
                return;
            }

            const ticksElapsed = (this.serverTick || 0) - tree.plantedAtTick;
            const requiredTicks = tree.growthDurationTicks || 1800;
            const tolerance = 10; // Allow 10 tick tolerance

            if (ticksElapsed < requiredTicks - tolerance) {
                return;
            }

            // Mark tree as fully grown
            tree.isGrowing = false;
            tree.scale = 1.0;
            delete tree.plantedAtTick;
            delete tree.growthDurationTicks;

            // Initialize apple tree inventory when fully grown (same as natural trees)
            if (tree.name === 'apple' && !tree.inventory) {
                const quality = tree.quality || 50;
                const baseDurability = 5;
                const items = [];

                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const itemId = `apple_${Date.now()}_${x + y * 3}_${Math.random().toString(36).substr(2, 9)}`;
                        items.push({
                            id: itemId,
                            type: 'apple',
                            x: x,
                            y: y,
                            width: 1,
                            height: 1,
                            rotation: 0,
                            quality: quality,
                            durability: Math.round(baseDurability * (quality / 100))
                        });
                    }
                }

                tree.inventory = { items };
                tree.lastSpawnTick = this.serverTick || 0;
            }

            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast to nearby clients
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'tree_growth_complete',
                payload: { treeId, chunkId }
            });

        } catch (error) {
            console.error('[TREE GROWTH] Error completing tree growth:', error);
        }
    }

    /**
     * Get all chunks that have active players (for optimization)
     * @returns {Array<string>} Array of active chunk IDs
     */
    getActiveChunks() {
        const activeChunks = new Set();
        const renderDistance = 2; // Process chunks within 2 chunks of any player

        for (const [clientId, clientData] of this.clients) {
            if (clientData.currentChunk) {
                const parsed = ChunkCoordinates.parseChunkIdSafe(clientData.currentChunk);
                if (!parsed) continue; // Skip invalid chunk IDs
                const { chunkX: x, chunkZ: z } = parsed;

                for (let dx = -renderDistance; dx <= renderDistance; dx++) {
                    for (let dz = -renderDistance; dz <= renderDistance; dz++) {
                        activeChunks.add(`${x + dx},${z + dz}`);
                    }
                }
            }
        }

        return Array.from(activeChunks);
    }

    /**
     * Handle repair_structure message (Phase 2: Repair System)
     * Repairs a structure by resetting lastRepairTime and averaging quality with materials
     */
    async handleRepairStructure(payload) {
        try {
            const { structureId, chunkKey, materials } = payload;
            const fullChunkId = `chunk_${chunkKey}`;
            const chunkData = await this.chunkManager.loadChunk(fullChunkId);

            if (!chunkData || !chunkData.objectChanges) {
                console.error(`[repair_structure] Chunk ${fullChunkId} not found`);
                return;
            }

            // Find the structure in chunk data
            const structure = chunkData.objectChanges.find(obj =>
                obj.id === structureId && obj.action === 'add'
            );

            if (!structure) {
                console.error(`[repair_structure] Structure ${structureId} not found in chunk ${fullChunkId}`);
                return;
            }

            // Validate materials array
            if (!materials || materials.length === 0) {
                console.error(`[repair_structure] No materials provided for repair`);
                return;
            }

            // Calculate new quality as weighted average
            const currentQuality = structure.quality || 50;
            const currentWeight = 1; // Structure's current quality counts as 1 unit
            const materialWeight = materials.length; // Each material counts as 1 unit

            let materialQualitySum = 0;
            materials.forEach(mat => {
                materialQualitySum += (mat.quality || 50);
            });

            const materialAvgQuality = materialQualitySum / materials.length;

            // Weighted average: (current * 1 + materials * count) / (1 + count)
            let newQuality = clampQuality(
                Math.round((currentQuality * currentWeight + materialAvgQuality * materialWeight) / (currentWeight + materialWeight))
            );

            // Apply structure-specific quality cap if defined
            const qualityCap = CONFIG.CONSTRUCTION.STRUCTURE_QUALITY_CAPS?.[structure.name];
            if (qualityCap) {
                newQuality = Math.min(newQuality, qualityCap);
            }

            // Update structure quality and reset repair time
            structure.quality = newQuality;
            structure.lastRepairTime = Date.now();

            // Save chunk
            await this.chunkManager.saveChunk(fullChunkId, chunkData);

            // Calculate new durability values for broadcast
            const durabilityInfo = enrichStructureWithDurability(structure);

            // Broadcast repair update to all clients in 3x3 grid
            this.messageRouter.broadcastTo3x3Grid(fullChunkId, {
                type: 'structure_repaired',
                payload: {
                    chunkId: fullChunkId,
                    structureId: structureId,
                    quality: newQuality,
                    currentDurability: durabilityInfo.currentDurability,
                    hoursUntilRuin: durabilityInfo.hoursUntilRuin
                }
            });
        } catch (error) {
            console.error('ERROR in repair_structure:', error);
        }
    }

    /**
     * Find a house or tent owned by a player (for setting home after account upgrade)
     * Returns the most recently built structure
     * @param {string} ownerId - Player's account ID
     * @returns {Promise<{id: string, x: number, z: number}|null>}
     */
    async findOwnedHome(ownerId) {
        try {
            const chunkFiles = this.chunkManager.getAllChunkFiles();
            let mostRecent = null;

            for (const chunkFile of chunkFiles) {
                // Keep chunk_ prefix - loadChunk expects format like "chunk_0,0"
                const chunkId = chunkFile.replace('.JSON', '');
                const chunkData = await this.chunkManager.loadChunk(chunkId);
                if (!chunkData?.objectChanges) continue;

                for (const obj of chunkData.objectChanges) {
                    // Look for house or tent owned by this player
                    if (obj.owner === ownerId && (obj.name === 'house' || obj.name === 'tent')) {
                        const buildTime = obj.lastRepairTime || 0;
                        if (!mostRecent || buildTime > mostRecent.buildTime) {
                            mostRecent = {
                                id: obj.id,
                                name: obj.name,
                                x: obj.position[0],
                                z: obj.position[2],
                                buildTime: buildTime
                            };
                        }
                    }
                }
            }

            if (mostRecent) {
                return {
                    id: mostRecent.id,
                    x: mostRecent.x,
                    z: mostRecent.z
                };
            }

            return null;
        } catch (error) {
            console.error('ERROR in findOwnedHome:', error);
            return null;
        }
    }

    /**
     * Transfer ownership of all structures from one clientId to another
     * Used when a guest player registers and gets an account ID
     */
    async transferStructureOwnership(fromClientId, toAccountId) {
        try {
            // Get all chunk files
            const chunkFiles = this.chunkManager.getAllChunkFiles();
            let structuresTransferred = 0;

            for (const chunkFile of chunkFiles) {
                // Keep chunk_ prefix - loadChunk expects format like "chunk_0,0"
                const chunkId = chunkFile.replace('.JSON', '');

                const chunkData = await this.chunkManager.loadChunk(chunkId);
                if (!chunkData?.objectChanges) continue;

                let chunkModified = false;

                // Check each object for ownership
                for (const obj of chunkData.objectChanges) {
                    // Transfer ownership if this object belongs to the old client ID
                    if (obj.owner === fromClientId) {
                        obj.owner = toAccountId;
                        chunkModified = true;
                        structuresTransferred++;
                    }
                }

                // Save chunk if any structures were updated
                if (chunkModified) {
                    await this.chunkManager.saveChunk(chunkId, chunkData);
                }
            }

            return structuresTransferred;
        } catch (error) {
            console.error('ERROR in transferStructureOwnership:', error);
            return 0;
        }
    }

    /**
     * Handle convert_to_ruin message from client
     * Client has calculated that a structure's durability reached 0
     * Server trusts client, converts structure to ruin, broadcasts
     */
    async handleConvertToRuin(ws, payload) {
        try {
            const { structureId, chunkId } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData || !chunkData.objectChanges) {
                return;
            }

            // Find the structure
            const structureIndex = chunkData.objectChanges.findIndex(
                obj => obj.id === structureId && obj.action === 'add'
            );

            if (structureIndex === -1) {
                // Structure already removed (another client beat us)
                return;
            }

            const structure = chunkData.objectChanges[structureIndex];

            // Skip if already a ruin or construction site
            if (structure.isRuin || structure.isConstructionSite) {
                return;
            }

            // Bandit/trapper structures don't decay naturally, but CAN be destroyed by artillery
            // Mark as removed (don't delete) so they don't respawn when chunk reloads
            if (structure.isBanditStructure || structure.isTrapperStructure) {
                structure.action = 'remove';
                await this.chunkManager.saveChunk(chunkId);

                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'object_removed',
                    payload: { chunkId, objectId: structureId }
                });

                return;
            }

            // Sold worker structures don't decay naturally (handled in periodic decay tick)
            // but CAN be destroyed by artillery - so don't block here

            // Skip roads - they don't decay and can't be destroyed
            if (structure.name === 'road') {
                return;
            }

            // Clean up militia if structure had one
            if (structure.hasMilitia) {
                // Clear militia fields from structure data
                structure.hasMilitia = false;
                delete structure.militiaOwner;
                delete structure.militiaFaction;
                delete structure.militiaType;

                // Broadcast militia cleared so clients despawn the militia entity
                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'structure_militia_updated',
                    payload: {
                        structureId,
                        chunkId,
                        hasMilitia: false
                    }
                });
            }

            // Determine construction site model for the ruin
            // Must match CONSTRUCTION_MODELS in config.js
            const constructionSiteMapping = {
                'house': 'construction',
                'market': '2x8construction',
                'fisherman': '2x2construction',
                'tileworks': '2x2construction',
                'ironworks': '2x2construction',
                'blacksmith': '2x2construction',
                'bakery': 'construction',
                'gardener': 'construction',
                'miner': 'construction',
                'woodcutter': 'construction',
                'stonemason': '2x2construction'
            };

            const ruinModel = constructionSiteMapping[structure.name];
            if (!ruinModel) {
                // Unknown structure type, just remove it
                chunkData.objectChanges.splice(structureIndex, 1);
                await this.chunkManager.saveChunk(chunkId, chunkData);

                this.messageRouter.broadcastTo3x3Grid(chunkId, {
                    type: 'object_removed',
                    payload: { chunkId, objectId: structureId }
                });
                return;
            }

            // Remove original structure
            chunkData.objectChanges.splice(structureIndex, 1);

            // Create ruin
            const ruinId = `ruin_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const ruin = {
                action: 'add',
                id: ruinId,
                name: ruinModel,
                position: structure.position,
                quality: 50,
                lastRepairTime: Date.now(), // Ruin has 1-hour lifespan from now
                scale: structure.scale || 1.0,
                rotation: structure.rotation || 0,
                chunkId: chunkId,
                isConstructionSite: true,
                isRuin: true,
                originalStructure: structure.name,
                targetStructure: null,
                requiredMaterials: {},
                materials: {}
            };

            chunkData.objectChanges.push(ruin);

            // Save chunk
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast removal of original structure
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_removed',
                payload: { chunkId, objectId: structureId }
            });

            // Broadcast ruin creation
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_added',
                payload: {
                    chunkId,
                    objectId: ruinId,
                    objectType: ruinModel,
                    position: ruin.position,
                    quality: 50,
                    currentDurability: 50,
                    hoursUntilRuin: 1.0,
                    scale: ruin.scale,
                    rotation: ruin.rotation,
                    isConstructionSite: true,
                    isRuin: true,
                    targetStructure: null,
                    requiredMaterials: {},
                    materials: {}
                }
            });


        } catch (error) {
            console.error('ERROR in convert_to_ruin:', error);
        }
    }

    /**
     * Handle artillery_boat_sink message from client
     * Boat destroyed by artillery - broadcast sinking animation to all clients,
     * then remove after animation completes (no ruin for boats)
     */
    async handleArtilleryBoatSink(ws, payload) {
        try {
            const { objectId, chunkKey, modelType } = payload;
            const chunkId = `chunk_${chunkKey}`;

            // Broadcast boat_sinking to all clients in range to play animation
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'boat_sinking',
                payload: { objectId, chunkKey, modelType }
            });

            // Schedule actual removal after sinking animation (7 seconds = SINK_DURATION)
            setTimeout(async () => {
                try {
                    const chunkData = await this.chunkManager.loadChunk(chunkId);
                    if (!chunkData || !chunkData.objectChanges) {
                        return;
                    }

                    // Find and remove the boat
                    const boatIndex = chunkData.objectChanges.findIndex(
                        obj => obj.id === objectId && obj.action === 'add'
                    );

                    if (boatIndex === -1) {
                        // Boat already removed
                        return;
                    }

                    // Remove boat from chunk data (no ruin - boats just disappear)
                    chunkData.objectChanges.splice(boatIndex, 1);
                    await this.chunkManager.saveChunk(chunkId, chunkData);

                    // Broadcast removal to all clients
                    this.messageRouter.broadcastTo3x3Grid(chunkId, {
                        type: 'object_removed',
                        payload: { chunkId, objectId }
                    });

                } catch (error) {
                    console.error('ERROR in artillery_boat_sink timeout:', error);
                }
            }, 7000); // 7 seconds = BoatSinkingSystem SINK_DURATION

        } catch (error) {
            console.error('ERROR in artillery_boat_sink:', error);
        }
    }

    /**
     * Handle remove_ruin message from client
     * Client has calculated that a ruin's 1-hour lifespan expired
     */
    async handleRemoveRuin(ws, payload) {
        try {
            const { structureId, chunkId } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData || !chunkData.objectChanges) {
                return;
            }

            // Find the structure to remove (ruin, expired construction site, or decayed structure)
            const ruinIndex = chunkData.objectChanges.findIndex(
                obj => obj.id === structureId && obj.action === 'add'
            );

            if (ruinIndex === -1) {
                // Already removed
                return;
            }

            // Remove the ruin
            chunkData.objectChanges.splice(ruinIndex, 1);
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast removal
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'object_removed',
                payload: { chunkId, objectId: structureId }
            });


        } catch (error) {
            console.error('ERROR in remove_ruin:', error);
        }
    }

    /**
     * Handle trigger_dock_ship message from client
     * Client has calculated that 30 minutes elapsed since lastShipSpawn
     * Server trusts client, updates dock, processes market trade, broadcasts
     */
    async handleTriggerDockShip(ws, payload) {
        try {
            const { dockId, chunkId } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData || !chunkData.objectChanges) {
                console.warn(`[Ship] Chunk ${chunkId} not found or has no objects`);
                return;
            }

            // Find the dock
            const dock = chunkData.objectChanges.find(
                obj => obj.id === dockId && obj.action === 'add' && obj.name === 'dock'
            );

            if (!dock) {
                console.warn(`[Ship] Dock ${dockId} not found in chunk ${chunkId}`);
                return;
            }

            // Check if nearest market has merchant ships enabled
            const marketInfo = await this.spawnTasks.findNearestMarketToDock(dock.position);
            if (!marketInfo) {
                return;
            }

            const market = await this.chunkManager.findObjectChange(marketInfo.chunkId, marketInfo.marketId);
            if (!market) {
                return;
            }

            // Require merchant ships to be explicitly enabled (default is false)
            if (market.merchantShipsEnabled !== true) {
                return;
            }

            const now = Date.now();

            // In-memory duplicate prevention (protects against concurrent message race)
            const lastTrigger = this.recentShipSpawnTriggers.get(dockId);
            if (lastTrigger && (now - lastTrigger) < 5000) {
                return;
            }
            // Mark as triggered in memory BEFORE async operations
            this.recentShipSpawnTriggers.set(dockId, now);

            // Also check persistent lastShipSpawn (for server restarts)
            if (dock.lastShipSpawn && (now - dock.lastShipSpawn) < 5000) {
                return;
            }

            // Update lastShipSpawn
            dock.lastShipSpawn = now;

            // Save chunk
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast ship spawn event
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'dock_ship_spawned',
                payload: {
                    dockId: dock.id,
                    dockPosition: dock.position,
                    dockRotation: dock.rotation,
                    lastShipSpawn: now,
                    chunkId: chunkId
                }
            });

            // Note: Trade processing moved to ship_departing handler (when ship leaves)

        } catch (error) {
            console.error('ERROR in trigger_dock_ship:', error);
        }
    }

    /**
     * Handle toggle_market_shipments message from client
     * Toggles the shipmentsPaused flag on a market structure
     */
    async handleToggleMarketShipments(ws, payload) {
        try {
            const { marketId, chunkId, paused } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData?.objectChanges) {
                console.warn(`[Market] Chunk ${chunkId} not found`);
                return;
            }

            const market = chunkData.objectChanges.find(
                obj => obj.id === marketId && obj.action === 'add' && obj.name === 'market'
            );

            if (!market) {
                console.warn(`[Market] Market ${marketId} not found in chunk ${chunkId}`);
                return;
            }

            // Validate ownership - only market owner can toggle shipments
            const requesterId = ws.accountId || ws.clientId;
            if (market.owner && market.owner !== requesterId) {
                console.warn(`[Market] ${ws.username || requesterId} attempted to toggle shipments on market they don't own`);
                return;
            }

            market.shipmentsPaused = paused;
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast to nearby players
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_shipments_toggled',
                payload: { marketId, chunkId, shipmentsPaused: paused }
            });


        } catch (error) {
            console.error('ERROR in toggle_market_shipments:', error);
        }
    }

    /**
     * Handle toggle_merchant_ships message from client
     * Toggles the merchantShipsEnabled flag on a market structure
     */
    async handleToggleMerchantShips(ws, payload) {
        try {
            const { marketId, chunkId, enabled } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData?.objectChanges) {
                console.warn(`[Market] Chunk ${chunkId} not found or no objectChanges`);
                return;
            }

            const market = chunkData.objectChanges.find(
                obj => obj.id === marketId && obj.action === 'add' && obj.name === 'market'
            );

            if (!market) {
                console.warn(`[Market] Market ${marketId} not found in chunk ${chunkId}`);
                return;
            }

            // Validate ownership - only market owner can toggle merchant ships
            const requesterId = ws.accountId || ws.clientId;
            if (market.owner && market.owner !== requesterId) {
                console.warn(`[Market] ${ws.username || requesterId} attempted to toggle merchant ships on market they don't own`);
                return;
            }

            market.merchantShipsEnabled = enabled;
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Broadcast to nearby players
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_merchant_ships_toggled',
                payload: { marketId, chunkId, merchantShipsEnabled: enabled }
            });

        } catch (error) {
            console.error('ERROR in toggle_merchant_ships:', error);
        }
    }

    /**
     * Handle ship_departing message from client
     * Client detected ship transitioning from DOCKED to BACKUP phase (starting departure)
     * Closes any open market UIs, then processes trade
     */
    async handleShipDeparting(ws, payload) {
        try {
            const { dockId, chunkId } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData || !chunkData.objectChanges) {
                console.warn(`[Ship Trade] Chunk ${chunkId} not found`);
                return;
            }

            // Find the dock
            const dock = chunkData.objectChanges.find(
                obj => obj.id === dockId && obj.action === 'add' && obj.name === 'dock'
            );

            if (!dock) {
                console.warn(`[Ship Trade] Dock ${dockId} not found in chunk ${chunkId}`);
                return;
            }

            // Prevent duplicate trade processing for the same ship cycle
            // Use lastShipSpawn as identifier for this ship's departure
            const lastProcessed = this.processedShipDepartures.get(dockId);
            if (lastProcessed && lastProcessed === dock.lastShipSpawn) {
                return;
            }
            // Mark this departure as processed
            this.processedShipDepartures.set(dockId, dock.lastShipSpawn);

            // Find nearby market to get its ID for closing UIs
            const marketInfo = await this.spawnTasks.findNearestMarketToDock(dock.position);
            if (marketInfo) {
                // Broadcast close_market_for_trade to all clients near this market
                // This will close any player's market UI before the trade modifies inventory
                this.messageRouter.broadcastTo3x3Grid(marketInfo.chunkId, {
                    type: 'close_market_for_trade',
                    payload: {
                        marketId: marketInfo.marketId,
                        reason: 'Ship departing - processing trade'
                    }
                });

                // Small delay to allow clients to process close before trade
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Process ship trading with nearby market
            await this.spawnTasks.processShipTrading(dock, chunkId);

        } catch (error) {
            console.error('ERROR in ship_departing:', error);
        }
    }

    // =========================================================================
    // NPC BAKER INVENTORY HANDLERS
    // =========================================================================

    /**
     * Handle NPC collecting apples from apple tree
     * @param {WebSocket} ws
     * @param {object} payload - { npcType, bakeryId, treeId, chunkId, maxCount }
     */
    async handleNPCCollectApples(ws, payload) {
        const { npcType, bakeryId, treeId, chunkId, maxCount } = payload;

        if (npcType !== 'baker') {
            ws.send(JSON.stringify({
                type: 'npc_collect_apples_response',
                payload: {
                    success: false,
                    bakeryId,
                    treeId,
                    collected: [],
                    reason: 'invalid_npc'
                }
            }));
            return;
        }

        try {
            // Get live reference to tree
            let tree = await this.chunkManager.findObjectChange(chunkId, treeId);

            // Initialize tree inventory if needed
            if (!tree?.inventory?.items) {
                if (treeId.includes('apple')) {
                    // Atomicity check: prevent race condition
                    if (this.initializingAppleTrees.has(treeId)) {
                        ws.send(JSON.stringify({
                            type: 'npc_collect_apples_response',
                            payload: {
                                success: false,
                                bakeryId,
                                treeId,
                                collected: [],
                                reason: 'tree_initializing'
                            }
                        }));
                        return;
                    }
                    this.initializingAppleTrees.add(treeId);
                    try {
                        const position = tree?.position || [0, 0, 0];
                        const scale = tree?.scale || 1;
                        const rotation = tree?.rotation || 0;
                        tree = await this.spawnTasks.initializeAppleTree(treeId, chunkId, position, scale, rotation);
                    } finally {
                        this.initializingAppleTrees.delete(treeId);
                    }
                if (!tree?.inventory?.items) {
                    ws.send(JSON.stringify({
                        type: 'npc_collect_apples_response',
                        payload: {
                            success: false,
                            bakeryId,
                            treeId,
                            collected: [],
                            reason: 'tree_not_found'
                        }
                    }));
                    return;
                }
            }
            }

            // Check for pending respawns before collecting (so NPC-only trees can regrow)
            if (this.spawnTasks && this.serverTick) {
                await this.spawnTasks.checkAndSpawnItems(tree, chunkId, this.serverTick);
            }

            // Collect apples from grid-based inventory
            const collected = [];
            let remaining = maxCount || 2;

            tree.inventory.items = tree.inventory.items.filter(item => {
                if (remaining > 0 && item.type === 'apple') {
                    const itemSize = this._getItemSize(item.type);
                    collected.push({ ...item, width: itemSize.width, height: itemSize.height });
                    remaining--;
                    return false;
                }
                return true;
            });

            // Save chunk
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast update
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'crate_inventory_updated',
                payload: {
                    crateId: treeId,  // Problem 2 Fix: Use crateId to match client expectation
                    chunkId,
                    inventory: tree.inventory
                }
            });

            ws.send(JSON.stringify({
                type: 'npc_collect_apples_response',
                payload: {
                    success: collected.length > 0,
                    bakeryId,
                    treeId,
                    collected
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCCollectApples:', error);
            ws.send(JSON.stringify({
                type: 'npc_collect_apples_response',
                payload: {
                    success: false,
                    bakeryId,
                    treeId,
                    collected: [],
                    reason: 'error'
                }
            }));
        }
    }

    /**
     * Handle NPC depositing items to bakery
     * @param {WebSocket} ws
     * @param {object} payload - { npcType, bakeryId, structureId, chunkId, items }
     */
    async handleNPCDeposit(ws, payload) {
        const { npcType, bakeryId, structureId, chunkId, items } = payload;

        const validNpcTypes = ['baker', 'tileworker', 'ironworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: false,
                    npcType,
                    structureId,
                    reason: 'invalid_npc'
                }
            }));
            return;
        }

        try {
            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);
            if (!structure?.inventory) {
                ws.send(JSON.stringify({
                    type: 'npc_deposit_response',
                    payload: {
                        success: false,
                        npcType,
                        structureId,
                        reason: 'structure_not_found'
                    }
                }));
                return;
            }

            // Grid-based: find empty slots (4x4 for bakery)
            const gridSize = 4;

            // Problem 6 Fix: Build occupancy map considering item width/height
            const occupiedSlots = new Set();
            for (const existingItem of (structure.inventory.items || [])) {
                const ew = existingItem.rotation === 90 ? (existingItem.height || 1) : (existingItem.width || 1);
                const eh = existingItem.rotation === 90 ? (existingItem.width || 1) : (existingItem.height || 1);
                for (let dy = 0; dy < eh; dy++) {
                    for (let dx = 0; dx < ew; dx++) {
                        occupiedSlots.add(`${existingItem.x + dx},${existingItem.y + dy}`);
                    }
                }
            }

            if (!structure.inventory.items) {
                structure.inventory.items = [];
            }

            const addedItems = [];
            for (const item of items) {
                // Ensure item has dimensions
                const itemSize = this._getItemSize(item.type);
                if (!item.width) item.width = itemSize.width;
                if (!item.height) item.height = itemSize.height;
                // Problem 6 Fix: Consider item dimensions when placing
                const itemWidth = item.rotation === 90 ? item.height : item.width;
                const itemHeight = item.rotation === 90 ? item.width : item.height;

                let foundSlot = false;
                for (let y = 0; y <= gridSize - itemHeight && !foundSlot; y++) {
                    for (let x = 0; x <= gridSize - itemWidth && !foundSlot; x++) {
                        // Check if all cells for this item are free
                        let allCellsFree = true;
                        for (let dy = 0; dy < itemHeight && allCellsFree; dy++) {
                            for (let dx = 0; dx < itemWidth && allCellsFree; dx++) {
                                if (occupiedSlots.has(`${x + dx},${y + dy}`)) {
                                    allCellsFree = false;
                                }
                            }
                        }

                        if (allCellsFree) {
                            item.x = x;
                            item.y = y;
                            structure.inventory.items.push(item);
                            // Mark all cells as occupied
                            for (let dy = 0; dy < itemHeight; dy++) {
                                for (let dx = 0; dx < itemWidth; dx++) {
                                    occupiedSlots.add(`${x + dx},${y + dy}`);
                                }
                            }
                            addedItems.push(item);
                            foundSlot = true;
                        }
                    }
                }
                if (!foundSlot) break;
            }

            if (addedItems.length === 0) {
                ws.send(JSON.stringify({
                    type: 'npc_deposit_response',
                    payload: {
                        success: false,
                        npcType,
                        structureId,
                        reason: 'inventory_full'
                    }
                }));
                return;
            }

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'crate_inventory_updated',
                payload: {
                    crateId: structureId,  // Problem 2 Fix: Use crateId to match client expectation
                    chunkId,
                    inventory: structure.inventory
                }
            });

            // Trigger processing for the appropriate structure type
            if (structure.name === 'bakery' && this.bakerySystem) {
                this.bakerySystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            } else if (structure.name === 'fisherman' && this.fishermanSystem) {
                this.fishermanSystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            } else if (structure.name === 'tileworks' && this.tileworksSystem) {
                this.tileworksSystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            } else if (structure.name === 'ironworks' && this.ironworksSystem) {
                this.ironworksSystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            } else if (structure.name === 'blacksmith' && this.blacksmithSystem) {
                this.blacksmithSystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            }

            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: true,
                    npcType,
                    structureId,
                    added: addedItems.length
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCDeposit:', error);
            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: false,
                    npcType,
                    structureId,
                    reason: 'error'
                }
            }));
        }
    }

    /**
     * Handle NPC collecting items from grid-based structure (bakery tarts, etc.)
     * @param {WebSocket} ws
     * @param {object} payload - { npcType, bakeryId, structureId, chunkId, itemType, count }
     */
    async handleNPCCollectFromStructure(ws, payload) {
        const { npcType, bakeryId, structureId, chunkId, itemType, count } = payload;

        const validNpcTypes = ['baker', 'tileworker', 'ironworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: false,
                    npcType,
                    bakeryId,
                    structureId,
                    itemType,
                    reason: 'invalid_npc'
                }
            }));
            return;
        }

        try {
            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);
            if (!structure?.inventory?.items) {
                ws.send(JSON.stringify({
                    type: 'npc_collect_response',
                    payload: {
                        success: false,
                        npcType,
                        bakeryId,
                        structureId,
                        itemType,
                        reason: 'structure_not_found'
                    }
                }));
                return;
            }

            const collected = [];
            let remaining = count || 10;

            structure.inventory.items = structure.inventory.items.filter(item => {
                if (remaining > 0 && item.type === itemType) {
                    const itemSize = this._getItemSize(item.type);
                    collected.push({ ...item, width: itemSize.width, height: itemSize.height });
                    remaining--;
                    return false;
                }
                return true;
            });

            if (collected.length === 0) {
                ws.send(JSON.stringify({
                    type: 'npc_collect_response',
                    payload: {
                        success: false,
                        npcType,
                        bakeryId,
                        structureId,
                        itemType,
                        reason: 'item_not_found'
                    }
                }));
                return;
            }

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'crate_inventory_updated',
                payload: {
                    crateId: structureId,  // Problem 2 Fix: Use crateId to match client expectation
                    chunkId,
                    inventory: structure.inventory
                }
            });

            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: true,
                    npcType,
                    bakeryId,
                    structureId,
                    itemType,
                    collected
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCCollectFromStructure:', error);
            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: false,
                    npcType,
                    bakeryId,
                    structureId,
                    itemType,
                    reason: 'error'
                }
            }));
        }
    }

    /**
     * Handle NPC collecting items from market
     * @param {WebSocket} ws
     * @param {object} payload - { npcType, structureId, bakeryId, marketId, chunkId, itemType, count }
     */
    async handleNPCCollectFromMarket(ws, payload) {
        const { npcType, bakeryId, structureId, marketId, chunkId, itemType, count } = payload;
        const buildingId = structureId || bakeryId; // Support both old and new field names

        // Valid NPC types that can collect from market
        const validNpcTypes = ['baker', 'stonemason', 'ironworker', 'tileworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: false,
                    npcType,
                    structureId: buildingId,
                    marketId,
                    reason: 'invalid_npc'
                }
            }));
            return;
        }

        try {
            const market = await this.chunkManager.findObjectChange(chunkId, marketId);
            if (!market?.inventory?.items) {
                ws.send(JSON.stringify({
                    type: 'npc_collect_response',
                    payload: {
                        success: false,
                        npcType,
                        structureId: buildingId,
                        marketId,
                        reason: 'market_not_found'
                    }
                }));
                return;
            }

            const inventory = market.inventory;

            // Find matching items (any firewood variant for 'firewood' request)
            const matchingTypes = [];
            for (const type of Object.keys(inventory.items)) {
                if (type === itemType || (itemType === 'firewood' && type.endsWith('firewood'))) {
                    matchingTypes.push(type);
                }
            }

            if (matchingTypes.length === 0) {
                ws.send(JSON.stringify({
                    type: 'npc_collect_response',
                    payload: {
                        success: false,
                        npcType,
                        structureId: buildingId,
                        marketId,
                        itemType,
                        reason: 'item_not_found'
                    }
                }));
                return;
            }

            const collected = [];
            let remaining = count || 1;

            for (const type of matchingTypes) {
                if (remaining <= 0) break;

                const qualityTiers = inventory.items[type];
                for (const qualityKey of Object.keys(qualityTiers)) {
                    if (remaining <= 0) break;

                    const available = qualityTiers[qualityKey];
                    if (available <= 0) continue;

                    const toTake = Math.min(remaining, available);

                    const parts = qualityKey.split(',');
                    const quality = parseInt(parts[0]) || 50;
                    const durability = parts[1] ? parseInt(parts[1]) : 100;

                    for (let i = 0; i < toTake; i++) {
                        // Fix 1: Use proper item dimensions for firewood/planks
                        const itemSize = this._getItemSize(type);
                        collected.push({
                            id: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            type: type,
                            x: 0, y: 0,
                            width: itemSize.width,
                            height: itemSize.height,
                            rotation: 0,
                            quality: quality,
                            durability: durability
                        });
                    }

                    qualityTiers[qualityKey] = available - toTake;
                    if (qualityTiers[qualityKey] <= 0) {
                        delete qualityTiers[qualityKey];
                    }

                    remaining -= toTake;
                }
            }

            if (collected.length === 0) {
                ws.send(JSON.stringify({
                    type: 'npc_collect_response',
                    payload: {
                        success: false,
                        npcType,
                        structureId: buildingId,
                        marketId,
                        itemType,
                        reason: 'no_stock'
                    }
                }));
                return;
            }

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_inventory_updated',
                payload: {
                    marketId,
                    items: inventory.items
                }
            });

            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: true,
                    npcType,
                    structureId: buildingId,
                    marketId,
                    itemType,
                    collected
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCCollectFromMarket:', error);
            ws.send(JSON.stringify({
                type: 'npc_collect_response',
                payload: {
                    success: false,
                    npcType,
                    structureId: buildingId,
                    marketId,
                    itemType,
                    reason: 'error'
                }
            }));
        }
    }

    /**
     * Handle NPC depositing items to market
     * @param {WebSocket} ws
     * @param {object} payload - { npcType, structureId, bakeryId, marketId, chunkId, items }
     */
    async handleNPCDepositToMarket(ws, payload) {
        const { npcType, structureId, bakeryId, gardenerId, woodcutterId, minerId, stonemasonId, marketId, chunkId, items } = payload;
        const npcId = structureId || bakeryId || gardenerId || woodcutterId || minerId || stonemasonId;

        const validNpcTypes = ['baker', 'gardener', 'woodcutter', 'miner', 'stonemason', 'ironworker', 'tileworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: false,
                    npcType,
                    npcId,
                    structureId: marketId,
                    reason: 'invalid_npc'
                }
            }));
            return;
        }

        try {
            const market = await this.chunkManager.findObjectChange(chunkId, marketId);
            if (!market?.inventory?.items) {
                ws.send(JSON.stringify({
                    type: 'npc_deposit_response',
                    payload: {
                        success: false,
                        npcType,
                        npcId,
                        structureId: marketId,
                        reason: 'market_not_found'
                    }
                }));
                return;
            }

            const inventory = market.inventory;
            const durabilityItems = CONFIG.MARKET?.DURABILITY_ITEMS || [];

            for (const item of items) {
                if (!inventory.items[item.type]) {
                    inventory.items[item.type] = {};
                }

                const hasDurability = durabilityItems.includes(item.type);
                const key = hasDurability
                    ? `${item.quality},${item.durability}`
                    : `${item.quality}`;

                const currentCount = inventory.items[item.type][key] || 0;
                inventory.items[item.type][key] = currentCount + 1;
            }

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'market_inventory_updated',
                payload: {
                    marketId,
                    items: inventory.items
                }
            });

            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: true,
                    npcType,
                    npcId,
                    structureId: marketId,
                    added: items.length
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCDepositToMarket:', error);
            ws.send(JSON.stringify({
                type: 'npc_deposit_response',
                payload: {
                    success: false,
                    npcType,
                    npcId,
                    structureId: marketId,
                    reason: 'error'
                }
            }));
        }
    }

    /**
     * Handle NPC baker checking bakery for completed processing
     * This allows tarts to complete without player interaction
     */
    async handleNPCCheckBakeryProcessing(ws, payload) {
        const { bakeryId, chunkId } = payload;

        if (!bakeryId || !chunkId) {
            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: { success: false, bakeryId, reason: 'invalid_payload' }
            }));
            return;
        }

        try {
            if (!this.bakerySystem) {
                ws.send(JSON.stringify({
                    type: 'npc_check_processing_response',
                    payload: { success: false, bakeryId, reason: 'system_not_ready' }
                }));
                return;
            }

            const result = await this.bakerySystem.checkAndCompleteProcessing(bakeryId, chunkId);

            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: {
                    success: result.success,
                    bakeryId,
                    completedCount: result.completedCount,
                    tartCount: result.tartCount
                }
            }));


        } catch (error) {
            console.error('[NPC] Error in handleNPCCheckBakeryProcessing:', error);
            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: { success: false, bakeryId, reason: 'error' }
            }));
        }
    }

    /**
     * Handle NPC worker checking structure for completed processing
     * Generic handler for tileworks, ironworks, blacksmith, fisherman
     * This allows items to complete without player interaction
     */
    async handleNPCCheckStructureProcessing(ws, payload) {
        const { structureId, structureType, chunkId } = payload;

        if (!structureId || !structureType || !chunkId) {
            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: { success: false, structureId, reason: 'invalid_payload' }
            }));
            return;
        }

        // Map structureType to system
        const systemMap = {
            'tileworks': this.tileworksSystem,
            'ironworks': this.ironworksSystem,
            'blacksmith': this.blacksmithSystem,
            'bakery': this.bakerySystem,
            'fisherman': this.fishermanSystem
        };

        const system = systemMap[structureType];
        if (!system) {
            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: { success: false, structureId, reason: 'invalid_structure_type' }
            }));
            return;
        }

        try {
            const result = await system.checkAndCompleteProcessing(structureId, chunkId);

            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: {
                    success: result.success,
                    structureId,
                    completedCount: result.completedCount,
                    outputCount: result.outputCount
                }
            }));


        } catch (error) {
            console.error(`[NPC] Error in handleNPCCheckStructureProcessing for ${structureType}:`, error);
            ws.send(JSON.stringify({
                type: 'npc_check_processing_response',
                payload: { success: false, structureId, reason: 'error' }
            }));
        }
    }

    async handleNPCRemoveExcessFirewood(ws, payload) {
        const { npcType, bakeryId, structureId, chunkId, keepCount = 1 } = payload;
        const buildingId = structureId || bakeryId;

        // Valid NPC types that use firewood
        const validNpcTypes = ['baker', 'ironworker', 'tileworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_remove_firewood_response',
                payload: { success: false, npcType, structureId: buildingId, reason: 'invalid_npc' }
            }));
            return;
        }

        try {
            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);
            if (!structure?.inventory?.items) {
                ws.send(JSON.stringify({
                    type: 'npc_remove_firewood_response',
                    payload: { success: false, npcType, structureId: buildingId, reason: 'structure_not_found' }
                }));
                return;
            }

            let removedCount = 0;
            let keptCount = 0;

            structure.inventory.items = structure.inventory.items.filter(item => {
                if (item?.type?.endsWith('firewood') && item.durability > 0) {
                    if (keptCount < keepCount) {
                        keptCount++;
                        return true;
                    } else {
                        removedCount++;
                        return false;
                    }
                }
                return true;
            });

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'crate_inventory_updated',
                payload: {
                    crateId: structureId,
                    chunkId,
                    inventory: structure.inventory
                }
            });

            ws.send(JSON.stringify({
                type: 'npc_remove_firewood_response',
                payload: {
                    success: true,
                    npcType,
                    structureId: buildingId,
                    removedCount
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCRemoveExcessFirewood:', error);
            ws.send(JSON.stringify({
                type: 'npc_remove_firewood_response',
                payload: { success: false, npcType, structureId: buildingId, reason: 'error' }
            }));
        }
    }

    async handleNPCClearLeftSlotAndDeposit(ws, payload) {
        const { npcType, bakeryId, structureId, chunkId, itemToDeposit } = payload;
        const buildingId = structureId || bakeryId;

        // Valid NPC types that use firewood
        const validNpcTypes = ['baker', 'ironworker', 'tileworker', 'blacksmith', 'fisherman'];
        if (!validNpcTypes.includes(npcType)) {
            ws.send(JSON.stringify({
                type: 'npc_clear_deposit_response',
                payload: { success: false, npcType, structureId: buildingId, reason: 'invalid_npc' }
            }));
            return;
        }

        try {
            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);
            if (!structure?.inventory) {
                ws.send(JSON.stringify({
                    type: 'npc_clear_deposit_response',
                    payload: { success: false, npcType, structureId: buildingId, reason: 'structure_not_found' }
                }));
                return;
            }

            if (!structure.inventory.items) {
                structure.inventory.items = [];
            }

            // LEFT SLOT: x=0-1, y=0-3 (the 2x4 firewood area)
            const leftSlotMaxX = 1;
            const leftSlotMaxY = 3;

            // Remove any items that overlap with the left slot
            const clearedItems = [];
            structure.inventory.items = structure.inventory.items.filter(item => {
                const itemW = item.rotation === 90 ? (item.height || 1) : (item.width || 1);
                const itemH = item.rotation === 90 ? (item.width || 1) : (item.height || 1);

                const itemMaxX = item.x + itemW - 1;
                const itemMaxY = item.y + itemH - 1;

                const overlapsLeft = item.x <= leftSlotMaxX && itemMaxX >= 0 &&
                                     item.y <= leftSlotMaxY && itemMaxY >= 0;

                if (overlapsLeft) {
                    clearedItems.push(item);
                    return false;
                }
                return true;
            });

            // Place firewood at position (0, 0)
            itemToDeposit.x = 0;
            itemToDeposit.y = 0;
            // Ensure item has dimensions
            const itemSize = this._getItemSize(itemToDeposit.type);
            if (!itemToDeposit.width) itemToDeposit.width = itemSize.width;
            if (!itemToDeposit.height) itemToDeposit.height = itemSize.height;
            // Stamp placedAtTick for tick-based depletion tracking (same as player-placed firewood)
            if (itemToDeposit.type?.endsWith('firewood') && !itemToDeposit.placedAtTick) {
                itemToDeposit.placedAtTick = this.serverTick || 0;
            }
            structure.inventory.items.push(itemToDeposit);

            await this.chunkManager.saveChunk(chunkId);

            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'crate_inventory_updated',
                payload: {
                    crateId: structureId,
                    chunkId,
                    inventory: structure.inventory
                }
            });

            if (structure.name === 'bakery' && this.bakerySystem) {
                this.bakerySystem.checkForProcessableItems(structureId, chunkId, structure.inventory);
            }

            ws.send(JSON.stringify({
                type: 'npc_clear_deposit_response',
                payload: {
                    success: true,
                    npcType,
                    structureId: buildingId,
                    clearedCount: clearedItems.length
                }
            }));

        } catch (error) {
            console.error('[NPC] Error in handleNPCClearLeftSlotAndDeposit:', error);
            ws.send(JSON.stringify({
                type: 'npc_clear_deposit_response',
                payload: { success: false, npcType, structureId: buildingId, reason: 'error' }
            }));
        }
    }

    /**
     * Handle artillery structure damage
     * Minimal server - trust client validation (matches existing combat patterns)
     */
    async handleArtilleryStructureDamage(ws, payload) {
        try {
            const { structureId, chunkId, lastRepairTime } = payload;

            const chunkData = await this.chunkManager.loadChunk(chunkId);
            if (!chunkData?.objectChanges) return;

            const structure = chunkData.objectChanges.find(
                obj => obj.id === structureId && obj.action === 'add'
            );
            if (!structure) return;

            // Basic sanity check only (prevents errors, not anti-cheat)
            if (structure.isRuin) return;

            // Apply damage (prevent future times)
            structure.lastRepairTime = Math.min(lastRepairTime, Date.now());

            // Save chunk
            await this.chunkManager.saveChunk(chunkId, chunkData);

            // Enrich with durability info for broadcast
            const durabilityInfo = enrichStructureWithDurability(structure);

            // Broadcast to nearby players
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_damaged',
                payload: {
                    structureId: structureId,
                    chunkId: chunkId,
                    lastRepairTime: structure.lastRepairTime,
                    currentDurability: durabilityInfo.currentDurability,
                    hoursUntilRuin: durabilityInfo.hoursUntilRuin
                }
            });

        } catch (error) {
            console.error('[Artillery] Error in handleArtilleryStructureDamage:', error);
        }
    }

    /**
     * Handle sell_to_proprietor message
     * Player sells their worker structure to an NPC proprietor
     * Structure stops decaying and player loses inventory access
     */
    async handleSellToProprietor(ws, payload) {
        try {
            const { structureId, chunkId } = payload;
            const clientId = ws.clientId;

            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);

            if (!structure) {
                ws.send(JSON.stringify({
                    type: 'sell_to_proprietor_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'Structure not found'
                    }
                }));
                return;
            }

            // Verify structure type is sellable
            const sellableTypes = ['bakery', 'woodcutter', 'gardener', 'miner', 'stonemason', 'blacksmith', 'ironworks', 'tileworks', 'fisherman'];
            if (!sellableTypes.includes(structure.name)) {
                ws.send(JSON.stringify({
                    type: 'sell_to_proprietor_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'This structure type cannot be sold'
                    }
                }));
                return;
            }

            // Verify ownership
            if (structure.owner !== clientId && structure.owner !== ws.accountId) {
                ws.send(JSON.stringify({
                    type: 'sell_to_proprietor_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'Only the owner can sell this structure'
                    }
                }));
                return;
            }

            // Check if already sold
            if (structure.proprietor === 'npc' || structure.isSoldWorkerStructure) {
                ws.send(JSON.stringify({
                    type: 'sell_to_proprietor_response',
                    payload: {
                        structureId,
                        success: false,
                        reason: 'This structure has already been sold'
                    }
                }));
                return;
            }

            // Mark as sold to proprietor
            structure.proprietor = 'npc';
            structure.isSoldWorkerStructure = true;

            // Save chunk
            await this.chunkManager.saveChunk(chunkId);

            // Send success to requesting client
            ws.send(JSON.stringify({
                type: 'sell_to_proprietor_response',
                payload: {
                    structureId,
                    chunkId,
                    success: true
                }
            }));

            // Broadcast to 3x3 grid so all clients update their state
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_sold_to_proprietor',
                payload: {
                    structureId,
                    chunkId
                }
            });

        } catch (error) {
            console.error('[Proprietor] Error in handleSellToProprietor:', error);
            ws.send(JSON.stringify({
                type: 'sell_to_proprietor_response',
                payload: {
                    structureId: payload.structureId,
                    success: false,
                    reason: 'Server error'
                }
            }));
        }
    }

    /**
     * Handle request_militia message
     * Player spawns militia at their owned tent by spending influence
     */
    async handleRequestMilitia(ws, payload) {
        try {
            const { tentId, chunkId, factionId } = payload;
            const clientId = ws.clientId;
            const accountId = ws.accountId;

            // 1. Verify tent exists
            const tent = await this.chunkManager.findObjectChange(chunkId, tentId);
            if (!tent) {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'Tent not found' }
                }));
                return;
            }

            // 2. Verify it's a tent
            if (tent.name !== 'tent') {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'Not a tent' }
                }));
                return;
            }

            // 3. Verify ownership
            if (tent.owner !== clientId && tent.owner !== accountId) {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'You do not own this tent' }
                }));
                return;
            }

            // 4. Verify player has faction
            // Fall back to database lookup if ws.factionId not set (handles session sync issues)
            let playerFaction = ws.factionId;
            if (!playerFaction && accountId && this.authManager) {
                playerFaction = await this.authManager.getFactionById(accountId);
                // Update ws.factionId so future checks don't need DB lookup
                if (playerFaction) {
                    ws.factionId = playerFaction;
                }
            }
            if (!playerFaction) {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'You must join a faction first' }
                }));
                return;
            }

            // 5. Check if tent already has militia
            if (tent.hasMilitia) {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'Tent already has militia' }
                }));
                return;
            }

            // 6. Verify influence
            const MILITIA_COST = 1;
            const currentInfluence = await this.authManager.getInfluence(accountId) || 0;

            if (currentInfluence < MILITIA_COST) {
                ws.send(JSON.stringify({
                    type: 'request_militia_response',
                    payload: { tentId, success: false, reason: 'Not enough influence' }
                }));
                return;
            }

            // 7. Deduct influence
            await this.authManager.addInfluence(accountId, -MILITIA_COST);

            // 8. Save militia flag to structure
            tent.hasMilitia = true;
            tent.militiaOwner = accountId;
            tent.militiaFaction = playerFaction;
            tent.militiaType = 'militia';
            await this.chunkManager.saveChunk(chunkId);

            // 9. Send success response
            ws.send(JSON.stringify({
                type: 'request_militia_response',
                payload: { tentId, chunkId, success: true }
            }));

            // 10. Broadcast to 3x3 grid so other clients know
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_militia_updated',
                payload: {
                    structureId: tentId,
                    chunkId,
                    hasMilitia: true,
                    militiaOwner: accountId,
                    militiaFaction: playerFaction,
                    militiaType: 'militia'
                }
            });

        } catch (error) {
            console.error('[Militia] Error in handleRequestMilitia:', error);
            ws.send(JSON.stringify({
                type: 'request_militia_response',
                payload: { tentId: payload.tentId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle request_outpost_militia message
     * Player spawns militia at an owned or same-faction outpost by spending influence
     */
    async handleRequestOutpostMilitia(ws, payload) {
        try {
            const { outpostId, chunkId, factionId } = payload;
            const clientId = ws.clientId;
            const accountId = ws.accountId;

            // 1. Verify outpost exists
            const outpost = await this.chunkManager.findObjectChange(chunkId, outpostId);
            if (!outpost) {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'Outpost not found' }
                }));
                return;
            }

            // 2. Verify it's an outpost
            if (outpost.name !== 'outpost') {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'Not an outpost' }
                }));
                return;
            }

            // 3. Verify player has faction (must check before same-faction check)
            // Fall back to database lookup if ws.factionId not set (handles session sync issues)
            let playerFaction = ws.factionId;
            if (!playerFaction && accountId && this.authManager) {
                playerFaction = await this.authManager.getFactionById(accountId);
                // Update ws.factionId so future checks don't need DB lookup
                if (playerFaction) {
                    ws.factionId = playerFaction;
                }
            }
            if (!playerFaction) {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'You must join a faction first' }
                }));
                return;
            }

            // 4. Verify ownership OR same faction
            const isOwner = outpost.owner === clientId || outpost.owner === accountId;
            const isSameFaction = outpost.ownerFactionId && outpost.ownerFactionId === playerFaction;

            if (!isOwner && !isSameFaction) {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'Not your outpost or faction' }
                }));
                return;
            }

            // 5. Check if outpost already has militia
            if (outpost.hasMilitia) {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'Outpost already has militia' }
                }));
                return;
            }

            // 6. Verify influence
            const MILITIA_COST = 1;
            const currentInfluence = await this.authManager.getInfluence(accountId) || 0;

            if (currentInfluence < MILITIA_COST) {
                ws.send(JSON.stringify({
                    type: 'request_outpost_militia_response',
                    payload: { outpostId, success: false, reason: 'Not enough influence' }
                }));
                return;
            }

            // 7. Deduct influence
            await this.authManager.addInfluence(accountId, -MILITIA_COST);

            // 8. Save militia flag to structure
            outpost.hasMilitia = true;
            outpost.militiaOwner = accountId;
            outpost.militiaFaction = playerFaction;
            outpost.militiaType = 'outpostMilitia';
            await this.chunkManager.saveChunk(chunkId);

            // 9. Send success response with outpost position
            ws.send(JSON.stringify({
                type: 'request_outpost_militia_response',
                payload: {
                    outpostId,
                    chunkId,
                    success: true,
                    position: outpost.position
                }
            }));

            // 10. Broadcast to 3x3 grid so other clients know
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_militia_updated',
                payload: {
                    structureId: outpostId,
                    chunkId,
                    hasMilitia: true,
                    militiaOwner: accountId,
                    militiaFaction: playerFaction,
                    militiaType: 'outpostMilitia'
                }
            });

        } catch (error) {
            console.error('[OutpostMilitia] Error in handleRequestOutpostMilitia:', error);
            ws.send(JSON.stringify({
                type: 'request_outpost_militia_response',
                payload: { outpostId: payload.outpostId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle request_artillery_militia message
     * Player spawns gunner militia at an owned or same-faction artillery by spending influence
     */
    async handleRequestArtilleryMilitia(ws, payload) {
        try {
            const { artilleryId, chunkId, factionId } = payload;
            const clientId = ws.clientId;
            const accountId = ws.accountId;

            // 1. Verify artillery exists
            const artillery = await this.chunkManager.findObjectChange(chunkId, artilleryId);
            if (!artillery) {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'Artillery not found' }
                }));
                return;
            }

            // 2. Verify it's an artillery
            if (artillery.name !== 'artillery') {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'Not an artillery' }
                }));
                return;
            }

            // 3. Verify player has faction (must check before same-faction check)
            // Fall back to database lookup if ws.factionId not set (handles session sync issues)
            let playerFaction = ws.factionId;
            if (!playerFaction && accountId && this.authManager) {
                playerFaction = await this.authManager.getFactionById(accountId);
                // Update ws.factionId so future checks don't need DB lookup
                if (playerFaction) {
                    ws.factionId = playerFaction;
                }
            }
            if (!playerFaction) {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'You must join a faction first' }
                }));
                return;
            }

            // 4. Verify ownership OR same faction
            const isOwner = artillery.owner === clientId || artillery.owner === accountId;
            const isSameFaction = artillery.ownerFactionId && artillery.ownerFactionId === playerFaction;

            if (!isOwner && !isSameFaction) {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'Not your artillery or faction' }
                }));
                return;
            }

            // 5. Check if artillery already has militia
            if (artillery.hasMilitia) {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'Artillery already has militia' }
                }));
                return;
            }

            // 6. Verify influence
            const MILITIA_COST = 1;
            const currentInfluence = await this.authManager.getInfluence(accountId) || 0;

            if (currentInfluence < MILITIA_COST) {
                ws.send(JSON.stringify({
                    type: 'request_artillery_militia_response',
                    payload: { artilleryId, success: false, reason: 'Not enough influence' }
                }));
                return;
            }

            // 7. Deduct influence
            await this.authManager.addInfluence(accountId, -MILITIA_COST);

            // 8. Save militia flag to structure
            artillery.hasMilitia = true;
            artillery.militiaOwner = accountId;
            artillery.militiaFaction = playerFaction;
            artillery.militiaType = 'artilleryMilitia';
            await this.chunkManager.saveChunk(chunkId);

            // 9. Send success response with artillery position
            ws.send(JSON.stringify({
                type: 'request_artillery_militia_response',
                payload: {
                    artilleryId,
                    chunkId,
                    success: true,
                    position: artillery.position
                }
            }));

            // 10. Broadcast to 3x3 grid so other clients know
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_militia_updated',
                payload: {
                    structureId: artilleryId,
                    chunkId,
                    hasMilitia: true,
                    militiaOwner: accountId,
                    militiaFaction: playerFaction,
                    militiaType: 'artilleryMilitia'
                }
            });

        } catch (error) {
            console.error('[ArtilleryMilitia] Error in handleRequestArtilleryMilitia:', error);
            ws.send(JSON.stringify({
                type: 'request_artillery_militia_response',
                payload: { artilleryId: payload.artilleryId, success: false, reason: 'Server error' }
            }));
        }
    }

    /**
     * Handle get_influence message
     * Returns the player's current influence points
     */
    async handleGetInfluence(ws, payload) {
        const accountId = ws.accountId;
        const influence = await this.authManager.getInfluence(accountId);
        ws.send(JSON.stringify({
            type: 'influence_response',
            payload: { influence }
        }));
    }

    /**
     * Handle militia_death message
     * Clears militia flag from structure when militia is killed
     */
    async handleMilitiaDeath(ws, payload) {
        try {
            const { structureId, chunkId } = payload;

            const structure = await this.chunkManager.findObjectChange(chunkId, structureId);
            if (!structure) {
                return;
            }

            // Only process if structure actually has militia
            if (!structure.hasMilitia) {
                return;
            }

            // Clear militia flag
            structure.hasMilitia = false;
            delete structure.militiaOwner;
            delete structure.militiaFaction;
            delete structure.militiaType;
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast to 3x3 grid so other clients know
            this.messageRouter.broadcastTo3x3Grid(chunkId, {
                type: 'structure_militia_updated',
                payload: {
                    structureId,
                    chunkId,
                    hasMilitia: false
                }
            });

        } catch (error) {
            console.error('[MilitiaDeath] Error in handleMilitiaDeath:', error);
        }
    }

    /**
     * Handle bandit_death message
     * Records bandit death time on structure so bandit never respawns
     */
    async handleBanditDeath(ws, payload) {
        try {
            const { tentId, chunkId } = payload;

            const structure = await this.chunkManager.findObjectChange(chunkId, tentId);
            if (!structure) {
                return;
            }

            // Only process if this is a bandit structure
            if (!structure.isBanditStructure) {
                return;
            }

            // Only record if not already dead (prevent duplicate processing)
            if (structure.banditDeathTime) {
                return;
            }

            // Record death time - bandit will never respawn
            structure.banditDeathTime = Date.now();
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast to all clients with this chunk loaded (LOAD_RADIUS, not just 3x3)
            this.messageRouter.broadcastToProximity(chunkId, {
                type: 'bandit_death_recorded',
                payload: {
                    tentId,
                    chunkId,
                    banditDeathTime: structure.banditDeathTime
                }
            });

        } catch (error) {
            console.error('[BanditDeath] Error in handleBanditDeath:', error);
        }
    }

    /**
     * Handle bear_death message
     * Records bear death time on den structure for 60-minute respawn cooldown
     */
    async handleBearDeath(ws, payload) {
        try {
            const { denId, chunkId } = payload;

            const structure = await this.chunkManager.findObjectChange(chunkId, denId);
            if (!structure) {
                return;
            }

            // Only process if this is a brown bear structure
            if (!structure.isBrownBearStructure) {
                return;
            }

            // Record death time for respawn cooldown
            structure.bearDeathTime = Date.now();
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast to all clients with this chunk loaded
            this.messageRouter.broadcastToProximity(chunkId, {
                type: 'bear_death_recorded',
                payload: {
                    denId,
                    chunkId,
                    bearDeathTime: structure.bearDeathTime
                }
            });

        } catch (error) {
            console.error('[BearDeath] Error in handleBearDeath:', error);
        }
    }

    /**
     * Handle deer_death message
     * Records deer death time on tree structure for 60-minute respawn cooldown
     */
    async handleDeerDeath(ws, payload) {
        try {
            const { treeId, chunkId } = payload;

            const structure = await this.chunkManager.findObjectChange(chunkId, treeId);
            if (!structure) {
                return;
            }

            // Only process if this is a deer tree structure
            if (!structure.isDeerTreeStructure) {
                return;
            }

            // Record death time for respawn cooldown
            structure.deerDeathTime = Date.now();
            await this.chunkManager.saveChunk(chunkId);

            // Broadcast to all clients with this chunk loaded
            this.messageRouter.broadcastToProximity(chunkId, {
                type: 'deer_death_recorded',
                payload: {
                    treeId,
                    chunkId,
                    deerDeathTime: structure.deerDeathTime
                }
            });

        } catch (error) {
            console.error('[DeerDeath] Error in handleDeerDeath:', error);
        }
    }

    /**
     * Clean up stale claims that were never completed (lease expiration)
     * Called periodically from server tick to prevent permanently stuck entities
     */
    cleanupStaleClaims() {
        const now = Date.now();
        const staleIds = [];

        for (const [entityId, claimData] of this.claimedMobileEntities) {
            if (now - claimData.claimedAt > this.CLAIM_LEASE_TIMEOUT) {
                staleIds.push(entityId);
            }
        }

        for (const entityId of staleIds) {
            console.warn(`[ClaimCleanup] Releasing stale claim: ${entityId}`);
            this.claimedMobileEntities.delete(entityId);
        }
    }

    /**
     * Handle query_claim_state message
     * Allows client to check if their claim succeeded after timeout
     */
    async handleQueryClaimState(ws, payload) {
        const { entityId, clientId } = payload;

        // Check if entity is in client's claimed entities
        const clientEntities = this.clientMobileEntities.get(clientId) || [];
        const isClaimed = clientEntities.some(e => e.entityId === entityId);

        ws.send(JSON.stringify({
            type: 'claim_state_response',
            payload: {
                entityId,
                claimedByMe: isClaimed,
                clientId
            }
        }));
    }
}

module.exports = MessageHandlers;
