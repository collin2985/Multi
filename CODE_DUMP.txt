
================================================================================
                         CODE DUMP - Multiplayer Game
================================================================================
Generated: 2025-10-23T07:41:50.721Z
Total Files: 11
================================================================================


================================================================================
FILE 1/11: package.json
Location: C:\Users\colli\Desktop\test horses\horses\package.json
Lines: 18
================================================================================

{
  "name": "horses",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "ws": "^8.18.3"
  }
}



================================================================================
FILE 2/11: server.js
Location: C:\Users\colli\Desktop\test horses\horses\server.js
Lines: 953
================================================================================

// File: server.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\server.js

const WebSocket = require('ws');
const fs = require('fs');

// Create a new WebSocket server on port 8080
const wss = new WebSocket.Server({ port: 8080 });
console.log('Server started on port 8080');

// A simple in-memory cache to hold our chunk data
const chunkCache = new Map();
// A map to store client data with WebSocket, currentChunk, and lastChunk
const clients = new Map();

// Define a global terrain seed (can be fixed or dynamically generated)
const terrainSeed = 12345; // Example: Random seed per server start

// Queue for rate-limiting notifications
const notificationQueue = [];
const notificationInterval = 100; // Process every 100ms

// Save the chunk state to its file
function saveChunk(chunkId) {
    if (chunkCache.has(chunkId)) {
        const filePath = `./public/${chunkId}.JSON`;
        const chunkData = chunkCache.get(chunkId);
        fs.writeFileSync(filePath, JSON.stringify(chunkData, null, 2), 'utf8');
        console.log(`Saved chunk: ${chunkId}`);
    }
}

// Load a chunk from file
function loadChunk(chunkId) {
    if (chunkCache.has(chunkId)) {
        return chunkCache.get(chunkId);
    }
    
    const filePath = `./public/${chunkId}.JSON`;
    
    try {
        const fileData = fs.readFileSync(filePath, 'utf8');
        const chunkData = JSON.parse(fileData);
        chunkCache.set(chunkId, chunkData);
        console.log(`Loaded chunk: ${chunkId}`);
        return chunkData;
    } catch (error) {
        // File doesn't exist = pristine chunk with no modifications
        console.log(`Chunk ${chunkId} has no saved data, creating empty state`);
        const emptyChunkData = { players: [], objectChanges: [], seed: terrainSeed };
        chunkCache.set(chunkId, emptyChunkData);
        return emptyChunkData;
    }
}

// Broadcast a message to all clients in a specific chunk
function broadcastToChunk(chunkId, message) {
    const recipients = [];
    clients.forEach((clientData, clientId) => {
        if (clientData && clientData.currentChunk === chunkId &&
            clientData.ws && clientData.ws.readyState === WebSocket.OPEN) {
            try {
                clientData.ws.send(JSON.stringify(message));
                recipients.push(clientId);
            } catch (err) {
                console.error(`Failed to send ${message.type} to ${clientId}:`, err);
            }
        }
    });
    console.log(`Broadcasted ${message.type} to chunk ${chunkId}. Recipients: ${recipients.join(',')}`);
}


// Get players in a 3x3 grid around a chunk
function getPlayersInProximity(chunkId) {
    const [chunkX, chunkZ] = chunkId.replace('chunk_', '').split(',').map(Number);

    const players = [];

    // Check 3x3 grid (1-chunk radius)
    for (let x = chunkX - 1; x <= chunkX + 1; x++) {
    for (let z = chunkZ - 1; z <= chunkZ + 1; z++) {
        const targetChunkId = `chunk_${x},${z}`;
        const chunkData = loadChunk(targetChunkId); // Use loadChunk instead of chunkCache.get
        if (chunkData && chunkData.players) {
            chunkData.players.forEach(player => {
                players.push({ id: player.id, chunkId: targetChunkId });
            });
        }
    }
}
    return players;
}

// Process notification queue for rate limiting
function processNotificationQueue() {
    if (notificationQueue.length === 0) return;

    // Group events by affected chunk to avoid duplicate notifications
    const chunksToNotify = new Set(notificationQueue.map(event => event.chunkId));
    notificationQueue.length = 0; // Clear queue

    chunksToNotify.forEach(chunkId => {
        // Get players in the 3x3 grid around this chunk
        const proximatePlayers = getPlayersInProximity(chunkId);
        const affectedClients = new Set(proximatePlayers.map(p => p.id));

        // For each affected client, compute their own 3x3 grid player list
        affectedClients.forEach(clientId => {
            const clientData = clients.get(clientId);
            if (!clientData || !clientData.ws || clientData.ws.readyState !== WebSocket.OPEN) return;

            const clientPlayers = getPlayersInProximity(clientData.currentChunk);
            try {
    clientData.ws.send(JSON.stringify({
        type: 'proximity_update',
        payload: { players: clientPlayers }
    }));
    console.log(`Sent proximity_update to ${clientId} with ${clientPlayers.length} players`);
} catch (err) {
    console.error(`Failed to send proximity_update to ${clientId}:`, err);
}

        });
    });
}

// Start notification queue processing
setInterval(processNotificationQueue, notificationInterval);

function broadcastTo3x3Grid(chunkId, message) {
    const [chunkX, chunkZ] = chunkId.replace('chunk_', '').split(',').map(Number);
    const radius = 1;


    // build set of target chunk ids
    const targetChunks = new Set();
    for (let x = chunkX - radius; x <= chunkX + radius; x++) {
        for (let z = chunkZ - radius; z <= chunkZ + radius; z++) {
            targetChunks.add(`chunk_${x},${z}`);
        }
    }

    const recipients = [];
    clients.forEach((clientData, clientId) => {
        if (clientData && clientData.currentChunk && targetChunks.has(clientData.currentChunk) &&
            clientData.ws && clientData.ws.readyState === WebSocket.OPEN) {
            try {
                clientData.ws.send(JSON.stringify(message));
                recipients.push(clientId);
            } catch (err) {
                console.error(`Failed to send ${message.type} to ${clientId}:`, err);
            }
        }
    });

    console.log(`Broadcasted ${message.type} to 3x3 grid around chunk ${chunkId}. Recipients: ${recipients.join(',')}`);
}


// Handle new connections
wss.on('connection', ws => {
    console.log('A new client connected');

    // Send a welcome message
    ws.send(JSON.stringify({ type: 'welcome', message: 'Welcome to the server!' }));

    ws.on('message', message => {
        let parsedMessage;
        try {
            parsedMessage = JSON.parse(message);
        } catch (error) {
            console.error('Invalid message received:', error);
            return;
        }
        console.log('Received message:', parsedMessage);

        switch (parsedMessage.type) {
            case 'join_chunk':
                const chunkId = parsedMessage.payload.chunkId;
                const clientId = parsedMessage.payload.clientId; // Get clientId from message
                if (!clientId) {
                    console.error('No clientId provided in join_chunk');
                    ws.send(JSON.stringify({ type: 'error', message: 'No clientId provided' }));
                    return;
                }
                ws.clientId = clientId;
                clients.set(clientId, { ws, currentChunk: chunkId, lastChunk: null });

                let chunkData = loadChunk(chunkId);
                if (!chunkData) {
                    // Initialize chunk if it doesn't exist
                    chunkData = { players: [], objectChanges: [], seed: terrainSeed };
                    chunkCache.set(chunkId, chunkData);
                    saveChunk(chunkId);
                }

                const isPlayerInChunk = chunkData.players.some(p => p.id === clientId);
                if (!isPlayerInChunk) {
                    chunkData.players.push({ id: clientId });
                    console.log(`Client ${clientId} joined chunk: ${chunkId}`);
                    saveChunk(chunkId);
                }

                notificationQueue.push({ chunkId });
                // Send chunk_objects_state for 3x3 grid
const [chunkX, chunkZ] = chunkId.replace('chunk_', '').split(',').map(Number);

const objectChanges = [];
for (let x = chunkX - 1; x <= chunkX + 1; x++) {
    for (let z = chunkZ - 1; z <= chunkZ + 1; z++) {
        const targetChunkId = `chunk_${x},${z}`;
        const targetChunkData = loadChunk(targetChunkId); // Use loadChunk instead of chunkCache.get
        if (targetChunkData && targetChunkData.objectChanges) {
            targetChunkData.objectChanges.forEach(change => {
                objectChanges.push({ ...change, chunkId: targetChunkId });
            });
        }
    }
}
                ws.send(JSON.stringify({
                    type: 'chunk_objects_state',
                    payload: { chunkId, objectChanges }
                }));
                console.log(`Sent chunk_objects_state for 3x3 grid around ${chunkId} to ${clientId}`);
                break;

            case 'chunk_update':
                const { clientId: updateClientId, newChunkId, lastChunkId } = parsedMessage.payload;
                const clientData = clients.get(updateClientId);
                if (!clientData) {
                    console.error(`Client ${updateClientId} not found for chunk_update`);
                    return;
                }

                // Update client data
                clientData.currentChunk = newChunkId;
                clientData.lastChunk = lastChunkId;

                // Update chunk data
                if (lastChunkId) {
                    const oldChunkData = chunkCache.get(lastChunkId);
                    if (oldChunkData) {
                        oldChunkData.players = oldChunkData.players.filter(p => p.id !== updateClientId);
                        saveChunk(lastChunkId);
                    }
                }

                let newChunkData = chunkCache.get(newChunkId);
                if (!newChunkData) {
                    newChunkData = { players: [], objectChanges: [], seed: terrainSeed };
                    chunkCache.set(newChunkId, newChunkData);
                }
                if (!newChunkData.players.some(p => p.id === updateClientId)) {
                    newChunkData.players.push({ id: updateClientId });
                    saveChunk(newChunkId);
                }

                // Send chunk_objects_state for 3x3 grid
                const [updateChunkX, updateChunkZ] = newChunkId.replace('chunk_', '').split(',').map(Number);

                const updateObjectChanges = [];
for (let x = updateChunkX - 1; x <= updateChunkX + 1; x++) {
    for (let z = updateChunkZ - 1; z <= updateChunkZ + 1; z++) {
        const targetChunkId = `chunk_${x},${z}`;
        const targetChunkData = loadChunk(targetChunkId); // Use loadChunk instead of chunkCache.get
        if (targetChunkData && targetChunkData.objectChanges) {
            targetChunkData.objectChanges.forEach(change => {
                updateObjectChanges.push({ ...change, chunkId: targetChunkId });
            });
        }
    }
}
                clientData.ws.send(JSON.stringify({
                    type: 'chunk_objects_state',
                    payload: { chunkId: newChunkId, objectChanges: updateObjectChanges }
                }));
                console.log(`Sent chunk_objects_state for 3x3 grid around ${newChunkId} to ${updateClientId}`);

                // Queue notifications for both chunks
                notificationQueue.push({ chunkId: newChunkId });
                if (lastChunkId) {
                    notificationQueue.push({ chunkId: lastChunkId });
                }
                console.log(`Processed chunk_update for ${updateClientId}: ${lastChunkId || 'none'} -> ${newChunkId}`);
                break;

            case 'add_box_request':
                const addChunkId = parsedMessage.payload.chunkId;
                const addChunkData = chunkCache.get(addChunkId);
                if (addChunkData) {
                    addChunkData.boxPresent = true;
                    saveChunk(addChunkId);
                    broadcastToChunk(addChunkId, {
                        type: 'chunk_state_change',
                        payload: { chunkId: addChunkId, state: addChunkData }
                    });
                }
                break;

            case 'remove_box_request':
                const removeChunkId = parsedMessage.payload.chunkId;
                const removeChunkData = chunkCache.get(removeChunkId);
                if (removeChunkData) {
                    removeChunkData.boxPresent = false;
                    saveChunk(removeChunkId);
                    broadcastToChunk(removeChunkId, {
                        type: 'chunk_state_change',
                        payload: { chunkId: removeChunkId, state: removeChunkData }
                    });
                }
                break;

            case 'add_object_request':
                try {
                    const { chunkId: addObjChunkId, objectType, objectPosition, objectQuality, objectScale, objectId: addObjectId, totalResources, remainingResources } = parsedMessage.payload;

                    let addObjChunkData = loadChunk(addObjChunkId);

                    const addChange = {
                        action: 'add',
                        id: addObjectId,
                        name: objectType,
                        position: objectPosition,
                        quality: objectQuality,
                        scale: objectScale,
                        chunkId: addObjChunkId,
                        totalResources: totalResources || null,
                        remainingResources: remainingResources || null,
                        harvestedBy: null,
                        harvestStartTime: null
                    };
                    addObjChunkData.objectChanges.push(addChange);

                    saveChunk(addObjChunkId);

                    broadcastTo3x3Grid(addObjChunkId, {
                        type: 'object_added',
                        payload: {
                            chunkId: addObjChunkId,
                            objectId: addObjectId,
                            objectType,
                            position: objectPosition,
                            quality: objectQuality,
                            scale: objectScale,
                            totalResources,
                            remainingResources
                        }
                    });

                    console.log(`Processed add_object_request for ${objectType} (quality: ${objectQuality}, resources: ${remainingResources}/${totalResources}) in chunk ${addObjChunkId}`);
                } catch (error) {
                    console.error('ERROR in add_object_request:', error);
                }
                break;

            case 'place_construction_site':
                try {
                    const { position, rotation, scale, targetStructure, finalFoundationY, finalCrateY, foundationId } = parsedMessage.payload;

                    // Calculate chunk from position
                    const chunkX = Math.floor(position[0] / 16);
                    const chunkZ = Math.floor(position[2] / 16);
                    const constructionChunkId = `chunk_${chunkX},${chunkZ}`;

                    // Generate unique ID for construction site
                    const constructionId = `construction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    let constructionChunkData = loadChunk(constructionChunkId);

                    // ADDING NEW STRUCTURES - STEP 5: MATERIAL REQUIREMENTS
                    // Define what materials are needed to build your structure.
                    // Format: { 'material_id': quantity }
                    // Material IDs must match inventory item IDs.
                    // Add your structure type here with its required materials.
                    let requiredMaterials;
                    if (targetStructure === 'crate') {
                        requiredMaterials = { 'oakplank': 1 };  // Crates require oak planks
                    } else if (targetStructure === 'outpost') {
                        requiredMaterials = { 'oakplank': 1 };  // Outpost requires just 1 oak plank
                    } else {
                        requiredMaterials = { 'chiseledlimestone': 1 };  // Foundations require chiseled limestone
                        // Add more structure types here:
                        // } else if (targetStructure === 'mystructure') {
                        //     requiredMaterials = { 'material1': 2, 'material2': 1 };
                    }

                    const constructionChange = {
                        action: 'add',
                        id: constructionId,
                        name: 'construction',
                        position: position,
                        quality: null,
                        scale: scale,
                        chunkId: constructionChunkId,
                        totalResources: null,
                        remainingResources: null,
                        harvestedBy: null,
                        harvestStartTime: null,
                        isConstructionSite: true,
                        targetStructure: targetStructure,
                        rotation: rotation,
                        requiredMaterials: requiredMaterials,
                        materials: {},
                        finalFoundationY: finalFoundationY,  // Store preview Y for final foundation
                        finalCrateY: finalCrateY,  // Store Y for crate
                        foundationId: foundationId  // Link to foundation (for crates)
                    };
                    constructionChunkData.objectChanges.push(constructionChange);

                    saveChunk(constructionChunkId);

                    broadcastTo3x3Grid(constructionChunkId, {
                        type: 'object_added',
                        payload: {
                            chunkId: constructionChunkId,
                            objectId: constructionId,
                            objectType: 'construction',
                            position: position,
                            quality: null,
                            scale: scale,
                            rotation: rotation,
                            totalResources: null,
                            remainingResources: null,
                            isConstructionSite: true,
                            targetStructure: targetStructure,
                            requiredMaterials: requiredMaterials,
                            materials: {},
                            finalFoundationY: finalFoundationY,
                            finalCrateY: finalCrateY,
                            foundationId: foundationId
                        }
                    });

                    console.log(`Processed place_construction_site in chunk ${constructionChunkId} at position [${position}], target: ${targetStructure}`);
                } catch (error) {
                    console.error('ERROR in place_construction_site:', error);
                }
                break;

            case 'build_construction':
                try {
                    const { constructionId, chunkKey } = parsedMessage.payload;

                    // Add "chunk_" prefix to match file naming convention
                    const fullChunkId = `chunk_${chunkKey}`;
                    let buildChunkData = loadChunk(fullChunkId);

                    // Find the construction site in objects or objectChanges
                    let constructionSite = null;

                    // Check in existing objects (if array exists)
                    if (Array.isArray(buildChunkData.objects)) {
                        for (const obj of buildChunkData.objects) {
                            if (obj.id === constructionId && obj.isConstructionSite) {
                                constructionSite = obj;
                                break;
                            }
                        }
                    }

                    // Check in objectChanges if not found
                    if (!constructionSite && Array.isArray(buildChunkData.objectChanges)) {
                        for (const change of buildChunkData.objectChanges) {
                            if (change.action === 'add' && change.id === constructionId && change.isConstructionSite) {
                                constructionSite = change;
                                break;
                            }
                        }
                    }

                    if (!constructionSite) {
                        console.error(`Construction site ${constructionId} not found in chunk ${chunkKey}`);
                        break;
                    }

                    // Get construction site data
                    const csPosition = constructionSite.position;
                    const csRotation = constructionSite.rotation;
                    const csTargetStructure = constructionSite.targetStructure;
                    const csFinalFoundationY = constructionSite.finalFoundationY;
                    const csFinalCrateY = constructionSite.finalCrateY;
                    const csFoundationId = constructionSite.foundationId;  // For crates

                    // Calculate average quality from materials (default to 50 if no materials)
                    const materials = constructionSite.materials || {};
                    let totalQuality = 0;
                    let materialCount = 0;

                    for (const [materialType, quantity] of Object.entries(materials)) {
                        // For now, assume quality of 50 for materials (could be enhanced later)
                        totalQuality += 50 * quantity;
                        materialCount += quantity;
                    }

                    const structureQuality = materialCount > 0 ? Math.round(totalQuality / materialCount) : 50;

                    // Remove construction site
                    const removeChange = {
                        action: 'remove',
                        id: constructionId,
                        chunkId: fullChunkId
                    };
                    buildChunkData.objectChanges.push(removeChange);

                    // Generate ID for structure
                    const structureId = `${csTargetStructure}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    // Determine final Y position based on structure type
                    let finalY;
                    if (csTargetStructure === 'crate') {
                        finalY = csFinalCrateY;
                    } else {
                        finalY = csFinalFoundationY;
                    }

                    // Add structure at the appropriate Y position
                    const structurePosition = [csPosition[0], finalY, csPosition[2]];

                    // Determine scale based on structure type (outpost is smaller - 40% reduction from 0.05)
                    const structureScale = (csTargetStructure === 'outpost') ? 0.03 : 0.5;

                    const structureChange = {
                        action: 'add',
                        id: structureId,
                        name: csTargetStructure,
                        position: structurePosition,
                        quality: structureQuality,
                        scale: structureScale,
                        chunkId: fullChunkId,
                        totalResources: null,
                        remainingResources: null,
                        harvestedBy: null,
                        harvestStartTime: null,
                        rotation: csRotation
                    };

                    // For crates, store reference to foundation for cascade deletion
                    if (csTargetStructure === 'crate' && csFoundationId) {
                        structureChange.foundationId = csFoundationId;
                    }

                    buildChunkData.objectChanges.push(structureChange);

                    saveChunk(fullChunkId);

                    // Broadcast removal of construction site
                    broadcastTo3x3Grid(fullChunkId, {
                        type: 'object_removed',
                        payload: {
                            chunkId: fullChunkId,
                            objectId: constructionId
                        }
                    });

                    // Broadcast addition of structure (foundation or crate)
                    broadcastTo3x3Grid(fullChunkId, {
                        type: 'object_added',
                        payload: {
                            chunkId: fullChunkId,
                            objectId: structureId,
                            objectType: csTargetStructure,
                            position: structurePosition,
                            quality: structureQuality,
                            scale: structureScale,
                            rotation: csRotation,
                            totalResources: null,
                            remainingResources: null
                        }
                    });

                    console.log(`Processed build_construction: removed ${constructionId}, added ${structureId} (${csTargetStructure}) in chunk ${fullChunkId}`);
                } catch (error) {
                    console.error('ERROR in build_construction:', error);
                }
                break;

            case 'get_crate_inventory':
                try {
                    const { crateId, chunkId: crateChunkId } = parsedMessage.payload;
                    const crateChunkData = loadChunk(crateChunkId);

                    // Find the crate in the chunk
                    const crateChange = crateChunkData.objectChanges.find(c => c.id === crateId && c.action === 'add');

                    let crateInventory = { items: [] };
                    if (crateChange && crateChange.inventory) {
                        crateInventory = crateChange.inventory;
                    }

                    // Send inventory back to client
                    ws.send(JSON.stringify({
                        type: 'crate_inventory_response',
                        payload: {
                            crateId: crateId,
                            inventory: crateInventory
                        }
                    }));

                    console.log(`Sent crate inventory for ${crateId}: ${crateInventory.items.length} items`);
                } catch (error) {
                    console.error('ERROR in get_crate_inventory:', error);
                }
                break;

            case 'save_crate_inventory':
                try {
                    const { crateId, chunkId: saveChunkId, inventory } = parsedMessage.payload;
                    const saveChunkData = loadChunk(saveChunkId);

                    // Find the crate in the chunk
                    const crateIndex = saveChunkData.objectChanges.findIndex(c => c.id === crateId && c.action === 'add');

                    if (crateIndex !== -1) {
                        // Update crate inventory
                        saveChunkData.objectChanges[crateIndex].inventory = inventory;
                        saveChunk(saveChunkId);

                        console.log(`Saved crate inventory for ${crateId}: ${inventory.items.length} items`);

                        // Broadcast inventory update to all clients
                        broadcastToChunk(saveChunkId, {
                            type: 'crate_inventory_updated',
                            payload: {
                                crateId: crateId,
                                inventory: inventory
                            }
                        });
                    } else {
                        console.error(`Crate ${crateId} not found in chunk ${saveChunkId}`);
                    }
                } catch (error) {
                    console.error('ERROR in save_crate_inventory:', error);
                }
                break;

            case 'remove_object_request':
                const { chunkId: removeObjChunkId, objectId, name, position, quality, scale } = parsedMessage.payload;
                // loadChunk now always returns valid data, never null
let removeObjChunkData = loadChunk(removeObjChunkId);
                const change = { action: 'remove', id: objectId, name, position, quality, scale, chunkId: removeObjChunkId };
                const existingIndex = removeObjChunkData.objectChanges.findIndex(c => c.id === objectId);
                if (existingIndex !== -1) {
                    removeObjChunkData.objectChanges[existingIndex] = change;
                } else {
                    removeObjChunkData.objectChanges.push(change);
                }
                saveChunk(removeObjChunkId);
                broadcastTo3x3Grid(removeObjChunkId, {
                    type: 'object_removed',
                    payload: { chunkId: removeObjChunkId, objectId, name, position, quality, scale }
                });
                console.log(`Processed remove_object_request for ${objectId} (quality: ${quality}, scale: ${scale}) in chunk ${removeObjChunkId}`);

                // ADDING NEW STRUCTURES - STEP 6: CASCADE DELETION (OPTIONAL)
                // If your structure depends on another (like crate on foundation),
                // add cascade deletion logic here to remove dependent structures
                // when the base structure is removed.
                // Check foundationId field to identify dependencies.
                if (name === 'foundation' || name === 'foundationcorner' || name === 'foundationroundcorner') {
                    console.log(`Foundation ${objectId} removed, checking for crates and construction sites to cascade delete`);

                    // Search through all loaded chunks for structures linked to this foundation
                    const cratesToRemove = [];
                    const constructionSitesToRemove = [];

                    // Get all chunk files to search
                    const chunkFiles = fs.readdirSync('./public').filter(f => f.startsWith('chunk_') && f.endsWith('.JSON'));

                    for (const chunkFile of chunkFiles) {
                        const searchChunkId = chunkFile.replace('.JSON', ''); // Keep "chunk_" prefix
                        const searchChunkData = loadChunk(searchChunkId);

                        // Find crates and construction sites in this chunk that reference the removed foundation
                        for (const change of searchChunkData.objectChanges) {
                            if (change.action === 'add') {
                                // Debug: log all items with foundationId
                                if (change.foundationId) {
                                    console.log(`  Found object with foundationId: ${change.name} (id: ${change.id}, foundationId: ${change.foundationId})`);
                                }
                                // Check for crates linked to this foundation
                                if (change.name === 'crate' && change.foundationId === objectId) {
                                    console.log(`  -> Found crate to cascade delete: ${change.id}`);
                                    cratesToRemove.push({
                                        chunkId: searchChunkId,
                                        crateId: change.id,
                                        crateName: change.name,
                                        cratePosition: change.position,
                                        crateQuality: change.quality,
                                        crateScale: change.scale
                                    });
                                }
                                // Check for construction sites targeting crates on this foundation
                                else if (change.name === 'construction' && change.foundationId === objectId) {
                                    console.log(`  -> Found construction site to cascade delete: ${change.id}`);
                                    constructionSitesToRemove.push({
                                        chunkId: searchChunkId,
                                        siteId: change.id,
                                        siteName: change.name,
                                        sitePosition: change.position,
                                        siteQuality: change.quality,
                                        siteScale: change.scale
                                    });
                                }
                            }
                        }
                    }

                    // Remove all found crates
                    for (const crateInfo of cratesToRemove) {
                        let crateChunkData = loadChunk(crateInfo.chunkId);
                        const crateChange = {
                            action: 'remove',
                            id: crateInfo.crateId,
                            name: crateInfo.crateName,
                            position: crateInfo.cratePosition,
                            quality: crateInfo.crateQuality,
                            scale: crateInfo.crateScale,
                            chunkId: crateInfo.chunkId
                        };

                        const crateExistingIndex = crateChunkData.objectChanges.findIndex(c => c.id === crateInfo.crateId);
                        if (crateExistingIndex !== -1) {
                            crateChunkData.objectChanges[crateExistingIndex] = crateChange;
                        } else {
                            crateChunkData.objectChanges.push(crateChange);
                        }

                        saveChunk(crateInfo.chunkId);
                        broadcastTo3x3Grid(crateInfo.chunkId, {
                            type: 'object_removed',
                            payload: {
                                chunkId: crateInfo.chunkId,
                                objectId: crateInfo.crateId,
                                name: crateInfo.crateName,
                                position: crateInfo.cratePosition,
                                quality: crateInfo.crateQuality,
                                scale: crateInfo.crateScale
                            }
                        });

                        console.log(`Cascade deleted crate ${crateInfo.crateId} from chunk ${crateInfo.chunkId}`);
                    }

                    // Remove all found construction sites
                    for (const siteInfo of constructionSitesToRemove) {
                        let siteChunkData = loadChunk(siteInfo.chunkId);
                        const siteChange = {
                            action: 'remove',
                            id: siteInfo.siteId,
                            name: siteInfo.siteName,
                            position: siteInfo.sitePosition,
                            quality: siteInfo.siteQuality,
                            scale: siteInfo.siteScale,
                            chunkId: siteInfo.chunkId
                        };

                        const siteExistingIndex = siteChunkData.objectChanges.findIndex(c => c.id === siteInfo.siteId);
                        if (siteExistingIndex !== -1) {
                            siteChunkData.objectChanges[siteExistingIndex] = siteChange;
                        } else {
                            siteChunkData.objectChanges.push(siteChange);
                        }

                        saveChunk(siteInfo.chunkId);
                        broadcastTo3x3Grid(siteInfo.chunkId, {
                            type: 'object_removed',
                            payload: {
                                chunkId: siteInfo.chunkId,
                                objectId: siteInfo.siteId,
                                name: siteInfo.siteName,
                                position: siteInfo.sitePosition,
                                quality: siteInfo.siteQuality,
                                scale: siteInfo.siteScale
                            }
                        });

                        console.log(`Cascade deleted construction site ${siteInfo.siteId} from chunk ${siteInfo.chunkId}`);
                    }

                    if (cratesToRemove.length > 0 || constructionSitesToRemove.length > 0) {
                        console.log(`Cascade deletion complete: removed ${cratesToRemove.length} crate(s) and ${constructionSitesToRemove.length} construction site(s)`);
                    }
                }
                break;

            case 'harvest_resource_request':
                try {
                    const { chunkId: harvestChunkId, objectId: harvestObjectId, harvestType, clientId, objectData } = parsedMessage.payload;
                    let harvestChunkData = loadChunk(harvestChunkId);

                    // Find the resource in objectChanges
                    let resourceIndex = harvestChunkData.objectChanges.findIndex(c => c.id === harvestObjectId && c.action === 'add');

                    // If not found, this is a natural resource being interacted with for the first time
                    if (resourceIndex === -1) {
                        console.log(`Natural resource ${harvestObjectId} first interaction - creating change entry`);

                        // Create change entry using client-provided data
                        const changeEntry = {
                            action: 'add',
                            id: harvestObjectId,
                            name: objectData.name,
                            position: objectData.position,
                            quality: objectData.quality,
                            scale: objectData.scale,
                            totalResources: objectData.totalResources,
                            remainingResources: objectData.remainingResources,
                            chunkId: harvestChunkId,
                            harvestedBy: null,
                            harvestStartTime: null
                        };

                        harvestChunkData.objectChanges.push(changeEntry);
                        resourceIndex = harvestChunkData.objectChanges.length - 1;
                    }

                    const resource = harvestChunkData.objectChanges[resourceIndex];
                    const now = Date.now();

                    // Check if resource is locked by another player
                    if (resource.harvestedBy && resource.harvestedBy !== clientId) {
                        // Check if lock has timed out (15 seconds)
                        const lockAge = now - (resource.harvestStartTime || 0);
                        if (lockAge < 15000) {
                            // Still locked by another player
                            const clientData = clients.get(clientId);
                            if (clientData && clientData.ws) {
                                clientData.ws.send(JSON.stringify({
                                    type: 'harvest_lock_failed',
                                    payload: {
                                        objectId: harvestObjectId,
                                        reason: 'Another player is harvesting this resource'
                                    }
                                }));
                            }
                            console.log(`Harvest lock failed for ${harvestObjectId}: locked by ${resource.harvestedBy}`);
                            break;
                        } else {
                            // Lock timed out, clear it
                            console.log(`Lock timeout for ${harvestObjectId}, clearing stale lock`);
                            resource.harvestedBy = null;
                            resource.harvestStartTime = null;
                        }
                    }

                    // Acquire lock for this harvest
                    resource.harvestedBy = clientId;
                    resource.harvestStartTime = now;

                    // Decrement resources
                    if (resource.remainingResources > 0) {
                        resource.remainingResources -= 1;

                        // If depleted, mark for removal and clear lock
                        if (resource.remainingResources <= 0) {
                            resource.action = 'remove';
                            resource.harvestedBy = null;
                            resource.harvestStartTime = null;
                        } else {
                            // Clear lock after successful harvest
                            resource.harvestedBy = null;
                            resource.harvestStartTime = null;
                        }

                        saveChunk(harvestChunkId);

                        // Broadcast update to all clients in 3x3 grid
                        broadcastTo3x3Grid(harvestChunkId, {
                            type: 'resource_harvested',
                            payload: {
                                chunkId: harvestChunkId,
                                objectId: harvestObjectId,
                                harvestType: harvestType,
                                remainingResources: resource.remainingResources,
                                depleted: resource.remainingResources <= 0,
                                harvestedBy: clientId
                            }
                        });

                        console.log(`Processed harvest_resource_request: ${harvestObjectId} (${harvestType}), remaining: ${resource.remainingResources}`);
                    } else {
                        console.warn(`Resource ${harvestObjectId} already depleted`);
                    }
                } catch (error) {
                    console.error('ERROR in harvest_resource_request:', error);
                }
                break;

            case 'webrtc_offer':
            case 'webrtc_answer':
            case 'webrtc_ice_candidate':
                const recipientId = parsedMessage.payload.recipientId;
                const recipientData = clients.get(recipientId);
                if (recipientData && recipientData.ws) {
                    recipientData.ws.send(message);
                    console.log(`Forwarded ${parsedMessage.type} from ${ws.clientId} to ${recipientId}`);
                } else {
                    console.error(`Recipient ${recipientId} not found`);
                }
                break;

            default:
                console.error('Unknown message type:', parsedMessage.type);
        }
    });

    ws.on('close', () => {
        if (ws.clientId) {
            console.log(`Client ${ws.clientId} disconnected`);
            const clientData = clients.get(ws.clientId);
            if (clientData && clientData.currentChunk) {
                const chunkData = chunkCache.get(clientData.currentChunk);
                if (chunkData) {
                    chunkData.players = chunkData.players.filter(p => p.id !== ws.clientId);
                    console.log(`Client ${ws.clientId} left chunk: ${clientData.currentChunk}`);
                    saveChunk(clientData.currentChunk);
                    notificationQueue.push({ chunkId: clientData.currentChunk });
                    console.log(`Queued proximity_update for chunk ${clientData.currentChunk} due to disconnection`);
                }
            }
            clients.delete(ws.clientId);
        }
    });
});

// A periodic check to verify players from the file are still connected
const interval = setInterval(() => {
    console.log('Starting periodic player check...');
    chunkCache.forEach((chunkData, chunkId) => {
        const playersToRemove = [];
        chunkData.players.forEach(player => {
            const clientData = clients.get(player.id);
            if (!clientData || !clientData.ws || clientData.ws.readyState !== WebSocket.OPEN) {
                console.log(`Removing disconnected player ${player.id} from chunk ${chunkId}`);
                playersToRemove.push(player.id);
            }
        });

        if (playersToRemove.length > 0) {
            chunkData.players = chunkData.players.filter(p => !playersToRemove.includes(p.id));
            saveChunk(chunkId);
            notificationQueue.push({ chunkId });
            console.log(`Queued proximity_update for chunk ${chunkId} due to cleanup`);
        }
    });
    console.log('Periodic player check finished');
}, 60000);

// Clean up the interval when the server closes
wss.on('close', () => {
    clearInterval(interval);
});


================================================================================
FILE 3/11: public/client.html
Location: C:\Users\colli\Desktop\test horses\horses\public\client.html
Lines: 958
================================================================================

<!-- File: public/client.html -->
<!-- Location: C:\Users\colli\Desktop\test Horses\Horses\public\client.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Game - Server/P2P Hybrid</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; }
        canvas { display: block; }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        button {
            margin-right: 10px;
            padding: 10px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #inventoryToggleBtn {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            background: #2196F3 !important;
            position: relative !important;
        }
        #inventoryToggleBtn:hover {
            background: #1976D2 !important;
        }
        #inventoryToggleBtn:disabled {
            background: #2196F3 !important;
            opacity: 0.8 !important;
            cursor: pointer !important;
        }
        #buildMenuToggleBtn {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            background: #FF9800 !important;
            position: relative !important;
        }
        #buildMenuToggleBtn:hover {
            background: #F57C00 !important;
        }
        #buildMenuToggleBtn:disabled {
            background: #FF9800 !important;
            opacity: 0.8 !important;
            cursor: pointer !important;
        }
        #connectionStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .status-connecting {
            background: #ff9800;
            color: white;
            animation: pulse 1.5s infinite;
        }
        .status-connected {
            background: #4caf50;
            color: white;
        }
        .status-disconnected {
            background: #f44336;
            color: white;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #peerInfo {
            position: absolute;
            top: 90px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
        }
        #fpsCounter {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }
        #zoomControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }
        #zoomControls button {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
        }
        #zoomControls button:hover {
            background: rgba(76, 175, 80, 0.3);
            border-color: #66BB6A;
        }
        #zoomControls button:active {
            background: rgba(76, 175, 80, 0.5);
        }
    </style>
</head>
<body>
    <div class="controls">
<button id="inventoryToggleBtn">Backpack (I)</button>
<button id="buildMenuToggleBtn">Build (B)</button>
<button id="constructionInventoryBtn" style="display: none;">Construction</button>
<button id="crateInventoryBtn" style="display: none;">Crate</button>
<button id="addBoxBtn" disabled>Add Tree</button>
<button id="removeBoxBtn" disabled>Remove Tree</button>
<button id="sawPlanksBtn" disabled>Saw Planks</button>
    </div>

    <div id="nearestObject">No object nearby</div>

    <!-- STATUS LINES -->
    <div id="statusLine1"></div>
    <div id="statusLine2"></div>

    <style>
        #nearestObject {
            position: absolute;
            top: 100px; /* Below buttons: addBoxBtn at 10px, removeBoxBtn at ~55px */
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 150px;
        }

        #statusLine1, #statusLine2 {
            position: absolute;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 150px;
            max-width: 400px;
            display: none; /* Hidden by default, shown when message is set */
        }

        #statusLine1 {
            top: 150px; /* Below nearestObject */
        }

        #statusLine2 {
            top: 180px; /* Below statusLine1 */
            color: #ffeb3b; /* Yellow for secondary messages */
        }
    </style>

    <div id="connectionStatus" class="status-connecting">🔄 Connecting...</div>
    <div id="peerInfo">P2P Connections: 0</div>
    <div id="fpsCounter">FPS: --</div>

    <!-- Zoom Controls -->
    <div id="zoomControls">
        <button id="zoomOutBtn" title="Zoom Out">🔍−</button>
        <button id="zoomInBtn" title="Zoom In">🔍+</button>
    </div>

    <!-- INVENTORY SYSTEM -->
    <div id="inventoryOverlay" class="inventory-overlay" style="display: none;">
        <div class="inventory-panel">
            <div class="inventory-header">
                <h2>Inventory</h2>
                <button id="inventoryCloseBtn" class="inventory-close-btn">✕</button>
            </div>
            <div class="inventory-content-wrapper">
                <div class="backpack-container">
                    <div class="backpack-section-header">
                        <h3>Backpack</h3>
                    </div>
                    <div class="inventory-grid-container">
                        <div id="inventoryGrid" class="inventory-grid">
                            <!-- 5x10 grid slots (50 total) -->
                        </div>
                        <div id="inventoryItems" class="inventory-items">
                            <!-- Items positioned absolutely over grid -->
                        </div>
                    </div>
                </div>

                <!-- CONSTRUCTION SECTION (appears when near construction site and stopped) -->
                <div id="constructionSection" class="construction-section" style="display: none;">
                    <div class="construction-section-header">
                        <h3>Construction Site</h3>
                    </div>
                    <div class="construction-building-info">
                        <h4>Building: <span id="constructionBuildingType">Foundation</span></h4>
                    </div>
                    <div class="construction-requirements">
                        <h4>Required Materials:</h4>
                        <div id="constructionRequirements"></div>
                    </div>
                    <div class="construction-slots-container">
                        <div id="constructionSlots" class="construction-slots">
                            <!-- Material slots will be dynamically created -->
                        </div>
                    </div>
                    <button id="constructionBuildBtn" class="construction-build-btn" disabled>Build</button>
                </div>

                <!-- CRATE SECTION (appears when near crate and stopped) -->
                <div id="crateSection" class="crate-section" style="display: none;">
                    <div class="crate-section-header">
                        <h3>Crate</h3>
                    </div>
                    <div class="crate-grid-container">
                        <div id="crateGrid" class="crate-grid">
                            <!-- 10x10 grid slots (100 total) -->
                        </div>
                        <div id="crateItems" class="crate-items">
                            <!-- Items positioned absolutely over grid -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- INVENTORY TOOLTIP -->
    <div id="inventoryTooltip" class="inventory-tooltip" style="display: none;">
        <div class="tooltip-title"></div>
        <div class="tooltip-stat">Quality: <span class="tooltip-quality"></span></div>
        <div class="tooltip-stat">Durability: <span class="tooltip-durability"></span></div>
    </div>

    <!-- DISCARD CONFIRMATION MODAL -->
    <div id="discardModal" class="discard-modal" style="display: none;">
        <div class="discard-modal-content">
            <p id="discardMessage">Are you sure you want to trash this item?</p>
            <div class="discard-buttons">
                <button id="discardCancel" class="discard-btn discard-cancel">Cancel</button>
                <button id="discardConfirm" class="discard-btn discard-confirm">OK</button>
            </div>
        </div>
    </div>

    <!-- BUILD MENU SYSTEM -->
    <div id="buildMenuOverlay" class="build-menu-overlay" style="display: none;">
        <div class="build-menu-panel">
            <div class="build-menu-header">
                <h2>Build</h2>
                <button id="buildMenuCloseBtn" class="build-menu-close-btn">✕</button>
            </div>
            <div class="build-menu-grid-container">
                <div id="buildMenuGrid" class="build-menu-grid">
                    <!-- 5x10 grid slots (50 total) -->
                </div>
                <div id="buildMenuStructures" class="build-menu-structures">
                    <!-- Structures positioned absolutely over grid -->
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD MENU TOOLTIP -->
    <div id="buildMenuTooltip" class="build-menu-tooltip" style="display: none;">
        <div class="tooltip-title"></div>
    </div>

    <style>
        /* INVENTORY STYLES */
        .inventory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 50px;
            cursor: pointer; /* Clicking background closes menu */
        }

        .inventory-panel {
            background: #2a2a2a;
            cursor: default; /* Normal cursor on panel */
            border: 3px solid #444;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1010; /* Above overlay background */
            position: relative;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #444;
        }

        .inventory-header h2 {
            margin: 0;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 24px;
        }

        .inventory-close-btn {
            background: #d32f2f;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
        }

        .inventory-close-btn:hover {
            background: #b71c1c;
        }

        .inventory-content-wrapper {
            display: flex;
            flex-direction: row;
            gap: 0;
        }

        .inventory-grid-container {
            position: relative;
            width: fit-content;
            flex-shrink: 0;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(10, 60px);
            gap: 2px;
            background: #1a1a1a;
            padding: 2px;
            border: 2px solid #555;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            background: #333;
            border: 1px solid #555;
            box-sizing: border-box;
        }

        .inventory-slot:hover {
            background: #3a3a3a;
            border-color: #777;
        }

        .inventory-items {
            position: absolute;
            top: 4px;
            left: 4px;
            pointer-events: none;
        }

        .inventory-item-wrapper {
            position: absolute;
            pointer-events: all;
            cursor: grab;
        }

        .inventory-item {
            position: relative;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .inventory-item:active {
            cursor: grabbing;
        }

        .inventory-item-wrapper.dragging {
            opacity: 0.8;
            z-index: 1001;
            cursor: grabbing;
        }

        .inventory-item-wrapper.invalid-placement {
            outline: 3px solid #ff0000;
            outline-offset: -3px;
        }

        .inventory-item-wrapper.chisel-target {
            outline: 5px solid #00ff00 !important;
            outline-offset: -5px;
            box-shadow: 0 0 15px #00ff00 !important;
        }

        /* INVENTORY TOOLTIP */
        .inventory-tooltip {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #666;
            border-radius: 6px;
            padding: 10px 12px;
            pointer-events: none;
            z-index: 2000;
            font-family: Arial, sans-serif;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .tooltip-title {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            text-transform: capitalize;
        }

        .tooltip-stat {
            color: #ccc;
            font-size: 12px;
            margin: 3px 0;
        }

        .tooltip-quality,
        .tooltip-durability {
            font-weight: bold;
        }

        .stat-good {
            color: #4caf50;
        }

        .stat-worn {
            color: #ffeb3b;
        }

        .stat-poor {
            color: #f44336;
        }

        /* DISCARD BUTTON ON ITEMS */
        .item-discard-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #fff;
            border-radius: 3px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: all;
        }

        .item-discard-btn:hover {
            background: rgba(255, 0, 0, 0.8);
            border-color: #fff;
        }

        /* DISCARD CONFIRMATION MODAL */
        .discard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .discard-modal-content {
            background: #2a2a2a;
            border: 3px solid #666;
            border-radius: 8px;
            padding: 30px;
            min-width: 300px;
            text-align: center;
        }

        .discard-modal-content p {
            color: #fff;
            font-size: 16px;
            margin: 0 0 20px 0;
        }

        .discard-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .discard-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }

        .discard-cancel {
            background: #666;
            color: #fff;
        }

        .discard-cancel:hover {
            background: #777;
        }

        .discard-confirm {
            background: #d32f2f;
            color: #fff;
        }

        .discard-confirm:hover {
            background: #b71c1c;
        }

        /* BUILD MENU STYLES */
        .build-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 50px;
        }

        .build-menu-panel {
            background: #2a2a2a;
            border: 3px solid #444;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .build-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #FF9800;
        }

        .build-menu-header h2 {
            margin: 0;
            color: #FF9800;
            font-family: Arial, sans-serif;
            font-size: 24px;
        }

        .build-menu-close-btn {
            background: #d32f2f;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
        }

        .build-menu-close-btn:hover {
            background: #b71c1c;
        }

        .build-menu-grid-container {
            position: relative;
            width: fit-content;
        }

        .build-menu-grid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(10, 60px);
            gap: 2px;
            background: #1a1a1a;
            padding: 2px;
            border: 2px solid #555;
        }

        .build-menu-slot {
            width: 60px;
            height: 60px;
            background: #333;
            border: 1px solid #555;
            box-sizing: border-box;
        }

        .build-menu-slot:hover {
            background: #3a3a3a;
            border-color: #777;
        }

        .build-menu-structures {
            position: absolute;
            top: 2px;
            left: 2px;
            pointer-events: none;
        }

        .build-menu-structure-wrapper {
            position: absolute;
            pointer-events: all;
            cursor: pointer;
        }

        .build-menu-structure-wrapper:hover {
            filter: brightness(1.2);
        }

        .build-menu-structure {
            position: relative;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* BUILD MENU TOOLTIP */
        .build-menu-tooltip {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #FF9800;
            border-radius: 6px;
            padding: 10px 12px;
            pointer-events: none;
            z-index: 2000;
            font-family: Arial, sans-serif;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .build-menu-tooltip .tooltip-title {
            color: #FF9800;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
        }

        /* BACKPACK CONTAINER */
        .backpack-container {
            flex-shrink: 0;
        }

        /* BACKPACK SECTION HEADER */
        .backpack-section-header {
            margin-bottom: 15px;
        }

        .backpack-section-header h3 {
            color: #2196F3;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
        }

        /* CONSTRUCTION SECTION (integrated into backpack) */
        .construction-section {
            margin-left: 20px;
            padding-left: 20px;
            border-left: 3px solid #4CAF50;
            transition: all 0.3s ease;
            min-width: 350px;
            max-width: 450px;
            flex-shrink: 0;
        }

        .construction-section-header {
            margin-bottom: 10px;
        }

        .construction-section-header h3 {
            color: #4CAF50;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
        }

        .construction-building-info {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }

        .construction-building-info h3,
        .construction-building-info h4 {
            color: #fff;
            font-size: 16px;
            margin: 0;
        }

        .construction-building-info span {
            color: #4CAF50;
            font-weight: bold;
        }

        .construction-requirements {
            margin-bottom: 20px;
        }

        .construction-requirements h3,
        .construction-requirements h4 {
            color: #4CAF50;
            font-size: 16px;
            margin-bottom: 10px;
            margin-top: 0;
        }

        #constructionRequirements {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .construction-slots-container {
            margin-bottom: 20px;
        }

        .construction-slots {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            min-height: 80px;
        }

        .construction-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .construction-slot.filled {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .construction-slot-label {
            position: absolute;
            bottom: -20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: #aaa;
        }

        .construction-build-btn {
            width: 100%;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .construction-build-btn:hover:not(:disabled) {
            background: #45a049;
        }

        .construction-build-btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* CRATE SECTION (integrated into backpack) */
        .crate-section {
            margin-left: 20px;
            padding-left: 20px;
            border-left: 3px solid #FF9800;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .crate-section-header {
            margin-bottom: 15px;
        }

        .crate-section-header h3 {
            color: #FF9800;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
        }

        .crate-grid-container {
            position: relative;
            width: fit-content;
            flex-shrink: 0;
        }

        .crate-grid {
            display: grid;
            /* Grid template set dynamically via JS based on window size */
            background: #1a1a1a;
            padding: 2px;
            border-radius: 4px;
            overflow-y: auto;
        }

        .crate-slot {
            /* Size set dynamically via JS based on window size */
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 2px;
        }

        .crate-slot:hover {
            background: #3a3a3a;
            border-color: #777;
        }

        .crate-items {
            position: absolute;
            top: 2px;
            left: 2px;
            pointer-events: none;
        }

        .crate-item {
            position: absolute;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: auto;
            cursor: grab;
            border: 2px solid transparent;
            border-radius: 2px;
            box-sizing: border-box;
        }

        .crate-item:hover {
            border-color: #FF9800;
        }

        .crate-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
    </style>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
          }
        }
    </script>
    <script type="module" src="./game.js"></script>
</body>
</html>



================================================================================
FILE 4/11: public/game.js
Location: C:\Users\colli\Desktop\test horses\horses\public\game.js
Lines: 5145
================================================================================

// File: public/game.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\game.js

/**
 * ==========================================
 * MAIN GAME ENGINE
 * ==========================================
 *
 * This is the core game logic file that handles:
 * - Game initialization and main loop
 * - Player movement and controls
 * - Inventory management (backpack, crate, construction)
 * - Object interaction (trees, rocks, structures)
 * - Networking (WebSocket to server, WebRTC peer-to-peer)
 * - Chunk loading/unloading
 * - Action system (chopping, building, harvesting)
 *
 * KEY CONFIGURATION:
 * - All game constants are in './config.js' - modify there for balance changes
 * - Use CONFIG.CATEGORY.VALUE to access configuration values
 * - Example: CONFIG.ACTIONS.CHOP_TREE_DURATION for tree chopping time
 *
 * MAJOR SYSTEMS:
 * 1. Inventory System (lines ~2400-3700)
 *    - renderInventory() - Renders backpack UI
 *    - renderCrateInventory() - Renders crate storage UI
 *    - onItemMouseDown/Move/Up() - Drag and drop logic
 *
 * 2. Network System (lines ~260-700)
 *    - NetworkManager class - Handles all networking
 *    - Server messages via WebSocket
 *    - P2P connections via WebRTC
 *
 * 3. Action System (lines ~1700-2200)
 *    - startChoppingAction() - Trees and structures
 *    - startHarvestAction() - Logs and stones
 *    - startBuildAction() - Construction
 *    - startChiselingAction() - Stone crafting
 *
 * 4. Chunk System (lines ~750-1000)
 *    - loadChunk() - Loads terrain and objects
 *    - unloadChunk() - Removes distant chunks
 *    - updateChunks() - Manages chunk loading based on player position
 *
 * ADDING NEW FEATURES:
 * - New items: Add to inventory system, update item images in public/items/
 * - New structures: See comments at lines ~180-225 for build menu
 * - New actions: Follow pattern of existing action methods
 * - New tools: Add to CONFIG.TOOLS in config.js
 *
 * DEBUGGING TIPS:
 * - Set CONFIG.DEBUG options in config.js for diagnostics
 * - Check browser console for [CATEGORY] tagged messages
 * - Network issues: Look for "📥" and "📤" prefixed messages
 */

// ==========================================
// GUIDE: ADDING NEW BUILDABLE STRUCTURES
// ==========================================
// To add a new buildable structure to the game, follow these steps:
//
// 1. MODEL REGISTRATION (objects.js):
//    Add model to MODEL_CONFIG with path, category='structure', zero density
//
// 2. BUILD MENU (game.js ~line 146):
//    Add structure definition with id, type, name, imagePath
//    Set requiresFoundation=true if it needs a foundation
//
// 3. ICON IMAGE:
//    Create 64x64 px icon in public/structures/[structurename].png
//
// 4. PLACEMENT VALIDATION (game.js validateFoundationPlacement ~line 3336):
//    Default validation checks terrain slope and object proximity
//    Structures with requiresFoundation skip terrain checks
//    Add custom validation logic if needed
//
// 5. Y POSITION (game.js updateFoundationPreview ~line 3244):
//    For foundation-based structures, calculate:
//    Y = foundation.y + (foundationHeight/2) + (structureHeight/2) + gap
//
// 6. MATERIAL REQUIREMENTS (server.js place_construction_site ~line 371):
//    Define required materials in format { 'material_id': quantity }
//
// 7. CASCADE DELETION (server.js remove_object_request ~line 591):
//    If structure depends on foundation, add to cascade deletion logic
//    Store foundationId when placing, check it when foundation removed
//
// See crate implementation as reference example.

import * as THREE from 'three';
import { ui } from './ui.js';
import { WaterRenderer } from './WaterRenderer.js';
import { CONFIG, COMPUTED } from './config.js';
import { SimpleTerrainRenderer, CONFIG as TERRAIN_CONFIG, roundCoord } from './terrain.js';
import { objectPlacer, modelManager } from './objects.js';
import { BlobShadow } from './blobshadow.js';
import { AudioManager } from './audio.js';
// AVATAR CLONING FIX: Import SkeletonUtils for proper skinned mesh cloning
// If this doesn't work, revert to alternative approach (load model multiple times)
import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

// ==========================================
// GAME STATE MANAGEMENT
// ==========================================

class GameState {
    constructor() {
        this.clientId = 'client_' + Math.random().toString(36).substr(2, 12);
        this.isInChunk = false;
        this.currentPlayerChunkX = 0;
        this.currentPlayerChunkZ = 0;
        this.lastChunkX = null;
        this.lastChunkZ = null;

        // Movement state
        this.isMoving = false;
        this.playerTargetPosition = new THREE.Vector3();
        this.cameraTargetPosition = new THREE.Vector3();

        // Camera zoom (1.0 = default, 0.75 = 25% closer/zoomed in)
        this.cameraZoom = 1.0;
        this.cameraZoomMin = 0.75; // 25% closer than default
        this.cameraZoomMax = 1.0;  // Default distance

        // Object tracking
        this.nearestObject = null;
        this.nearestObjectDistance = Infinity;
        this.removedObjectsCache = new Map(); // Key: chunkKey, Value: Set of removed objectIds

        // Chopping/harvesting action state
        this.activeChoppingAction = null; // { object, startTime, duration, sound }
        this.harvestCooldown = null; // { endTime: timestamp }

        // Inventory system (configuration from config.js)
        this.inventoryOpen = false;
        this.inventory = {
            rows: CONFIG.INVENTORY.BACKPACK_ROWS,  // 10 rows from config
            cols: CONFIG.INVENTORY.BACKPACK_COLS,  // 5 columns from config
            slotSize: CONFIG.INVENTORY.DEFAULT_SLOT_SIZE,  // 60px, recalculated on resize
            gap: CONFIG.INVENTORY.DEFAULT_GAP,     // 2px gap, recalculated on resize
            items: [
                // Test item: pickaxe at position (0, 0)
                {
                    id: 'test_pickaxe',
                    type: 'pickaxe',
                    x: 0,
                    y: 0,
                    width: 2,
                    height: 5,
                    rotation: 0,
                    quality: 85,
                    durability: 60
                },
                // Test item: axe at position (0, 5)
                {
                    id: 'test_axe',
                    type: 'axe',
                    x: 0,
                    y: 5,
                    width: 2,
                    height: 5,
                    rotation: 0,
                    quality: 72,
                    durability: 88
                },
                // Test item: saw at position (2, 0)
                {
                    id: 'test_saw',
                    type: 'saw',
                    x: 2,
                    y: 0,
                    width: 2,
                    height: 5,
                    rotation: 0,
                    quality: 91,
                    durability: 45
                },
                // Test item: hammer at position (2, 5)
                {
                    id: 'test_hammer',
                    type: 'hammer',
                    x: 2,
                    y: 5,
                    width: 1,
                    height: 2,
                    rotation: 0,
                    quality: 68,
                    durability: 82
                },
                // Test item: chisel at position (2, 7)
                {
                    id: 'test_chisel',
                    type: 'chisel',
                    x: 2,
                    y: 7,
                    width: 1,
                    height: 2,
                    rotation: 0,
                    quality: 55,
                    durability: 71
                },
                // Test item: chiseled limestone at position (3, 7)
                {
                    id: 'test_chiseledlimestone',
                    type: 'chiseledlimestone',
                    x: 3,
                    y: 7,
                    width: 1,
                    height: 1,
                    rotation: 0,
                    quality: 80,
                    durability: null
                }
            ]
        };

        // Inventory interaction state (click-based pickup/place)
        this.inventoryPickedItem = null; // Item currently being held
        this.inventoryPickedOriginalX = 0;
        this.inventoryPickedOriginalY = 0;
        this.inventoryPickedOriginalRotation = 0;
        this.inventoryMouseX = 0;
        this.inventoryMouseY = 0;
        this.inventoryIgnoreNextMouseUp = false; // Flag to ignore mouseup from pickup click

        // Build menu system (configuration from config.js)
        this.buildMenuOpen = false;
        this.buildMenu = {
            rows: CONFIG.BUILD_MENU.ROWS,          // 10 rows from config
            cols: CONFIG.BUILD_MENU.COLS,          // 5 columns from config
            slotSize: CONFIG.INVENTORY.DEFAULT_SLOT_SIZE,  // 60px, recalculated on resize
            gap: CONFIG.INVENTORY.DEFAULT_GAP,     // 2px gap, recalculated on resize
            // ADDING NEW STRUCTURES - STEP 2: BUILD MENU ENTRY
            // Add your structure definition to this array to make it appear in the build menu.
            // Required fields:
            // - id: Unique identifier for the structure
            // - type: Must match the model name in objects.js MODEL_CONFIG
            // - name: Display name shown to player
            // - width/height: Grid size in build menu (usually 1x1)
            // - imagePath: Path to icon image in ./structures/ folder (64x64 px recommended)
            // Optional fields:
            // - requiresFoundation: true if structure must be placed on foundation (like crates)
            structures: [
                // Foundation structure
                {
                    id: 'foundation',
                    type: 'foundation',
                    name: 'Foundation',
                    width: 1,
                    height: 1,
                    imagePath: './structures/foundation.png'
                },
                {
                    id: 'foundationcorner',
                    type: 'foundationcorner',
                    name: 'Corner Foundation',
                    width: 1,
                    height: 1,
                    imagePath: './structures/foundationcorner.png'
                },
                {
                    id: 'foundationroundcorner',
                    type: 'foundationroundcorner',
                    name: 'Round Corner Foundation',
                    width: 1,
                    height: 1,
                    imagePath: './structures/foundationroundcorner.png'
                },
                // Crate structure (requires foundation)
                {
                    id: 'crate',
                    type: 'crate',
                    name: 'Crate',
                    width: 1,
                    height: 1,
                    imagePath: './structures/crate.png',
                    requiresFoundation: true  // Special flag for structures that need foundation
                },
                // Outpost structure (places on terrain like foundation)
                {
                    id: 'outpost',
                    type: 'outpost',
                    name: 'Outpost',
                    width: 1,
                    height: 1,
                    imagePath: './structures/outpost.png'
                }
            ]
        };

        // Build menu interaction state
        this.buildMenuPickedStructure = null; // Structure currently being held for placement

        // Construction inventory system
        this.constructionInventoryOpen = false;
        this.nearestConstructionSite = null;
        this.nearestConstructionSiteDistance = Infinity;

        // Crate inventory system
        this.crateInventoryOpen = false;
        this.nearestCrate = null;
        this.nearestCrateDistance = Infinity;

        // Foundation placement state
        this.foundationPlacement = {
            active: false,
            phase: null,  // 'position' -> 'rotation' -> 'height' -> 'confirmed'
            structure: null,
            position: { x: 0, y: 0, z: 0 },
            rotation: 0,  // In degrees (snaps to 15°)
            height: 0,    // Relative to terrain (snaps to 0.5)
            previewBox: null,
            isValid: false,
            invalidReason: '',
            initialMouseY: 0  // Track mouse Y when entering height phase
        };

        // Chiseling state
        this.chiselTarget = null;

        // Timing
        this.lastChunkUpdateTime = 0;
        this.lastProximityCheckTime = 0;
        this.lastPeerCheckTime = 0;
        this.lastFrameTime = performance.now();
    }

    updateChunkPosition(newX, newZ) {
        this.lastChunkX = this.currentPlayerChunkX;
        this.lastChunkZ = this.currentPlayerChunkZ;
        this.currentPlayerChunkX = newX;
        this.currentPlayerChunkZ = newZ;
    }
}

// ==========================================
// NETWORK MANAGER
// ==========================================

class NetworkManager {
    constructor(gameState, onMessageCallback) {
        this.gameState = gameState;
        this.onMessageCallback = onMessageCallback;
        this.ws = null;
        this.wsRetryAttempts = 0;
        this.wsMaxRetries = 10;
        this.wsRetryInterval = 5000;

        // P2P state
        this.peers = new Map();
        this.avatars = new Map();
        this.playerObject = null; // Set later by setPlayerObject()
        this.audioManager = null; // Set later by setAudioManager()
    }

    setPlayerObject(playerObject) {
        this.playerObject = playerObject;
    }

    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }

connect(online = false) {
    const url = online ? 'wss://multiplayer-game-dcwy.onrender.com' : 'ws://localhost:8080';
    
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.close();
    }

    this.ws = new WebSocket(url);
    this.setupWebSocketHandlers();
}

    setupWebSocketHandlers() {
        this.ws.onopen = () => {
            ui.updateStatus("✅ Connected to server");
            ui.updateConnectionStatus('connected', '✅ Server Connected');
            this.wsRetryAttempts = 0;
            this.onMessageCallback('server_connected', {});
        };

        this.ws.onclose = (event) => {
            ui.updateStatus(`❌ Server disconnected (${event.code})`);
            ui.updateConnectionStatus('disconnected', '❌ Server Disconnected');
            this.gameState.isInChunk = false;
            ui.updateButtonStates(false, null, false, false, false, null, false);
            this.attemptReconnect();
        };

        this.ws.onerror = (error) => {
            ui.updateStatus(`❌ Server error: ${error.message || 'Unknown error'}`);
            ui.updateConnectionStatus('disconnected', '❌ Server Error');
        };

        this.ws.onmessage = async (event) => {
            const messageData = event.data instanceof Blob ?
                await event.data.text() : event.data;

            try {
                const data = JSON.parse(messageData);
                console.log('RAW MESSAGE RECEIVED:', data);
                ui.updateStatus(`📥 Server: ${data.type}`);
                this.onMessageCallback(data.type, data.payload);
            } catch (error) {
                ui.updateStatus(`❌ Invalid server message: ${error.message}`);
            }
        };
    }

    attemptReconnect() {
        if (this.wsRetryAttempts < this.wsMaxRetries) {
            this.wsRetryAttempts++;
            ui.updateStatus(`Attempting reconnection ${this.wsRetryAttempts} of ${this.wsMaxRetries}...`);
            setTimeout(() => this.connect(), this.wsRetryInterval);
        } else {
            ui.updateStatus(`❌ Max reconnection attempts reached. Please refresh.`);
            ui.updateConnectionStatus('disconnected', '❌ Disconnected');
        }
    }

    sendMessage(type, payload) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type, payload }));
            ui.updateStatus(`📤 Sent ${type} to server`);
            return true;
        }
        ui.updateStatus(`❌ Failed to send ${type}: No server connection`);
        return false;
    }

    // --- P2P Methods ---
    createPeerConnection(peerId, isInitiator = false) {
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        const connection = new RTCPeerConnection(config);
        const peerState = {
            connection,
            dataChannel: null,
            state: 'connecting',
            isInitiator,
            targetPosition: null,
            moveStartTime: null
        };

        this.peers.set(peerId, peerState);

        connection.onicecandidate = (event) => {
            if (event.candidate) {
                this.sendMessage('webrtc_ice_candidate', {
                    recipientId: peerId,
                    senderId: this.gameState.clientId,
                    candidate: event.candidate
                });
            }
        };

        connection.onconnectionstatechange = () => {
            peerState.state = connection.connectionState;
            ui.updateStatus(`P2P ${peerId}: ${connection.connectionState}`);
            ui.updatePeerInfo(this.peers, this.avatars);
        };

        if (isInitiator) {
            const dataChannel = connection.createDataChannel('game', { ordered: true });
            this.setupDataChannel(dataChannel, peerId);
            peerState.dataChannel = dataChannel;
        } else {
            connection.ondatachannel = (event) => {
                this.setupDataChannel(event.channel, peerId);
                peerState.dataChannel = event.channel;
            };
        }

        return connection;
    }

    setupDataChannel(dataChannel, peerId) {
        dataChannel.onopen = () => {
            ui.updateStatus(`P2P data channel opened with ${peerId}`);
            ui.updatePeerInfo(this.peers, this.avatars);

            // Send initial state to newly connected peer (mutual sync)
            if (this.playerObject) {
                const message = {
                    type: 'player_sync',
                    payload: {
                        position: this.playerObject.position.toArray(),
                        target: this.gameState.isMoving ?
                                this.gameState.playerTargetPosition.toArray() : null
                    }
                };
                dataChannel.send(JSON.stringify(message));
                console.log(`Sent initial state to peer ${peerId}`);
            }
        };

        dataChannel.onclose = () => {
            ui.updateStatus(`P2P data channel closed with ${peerId}`);
            ui.updatePeerInfo(this.peers, this.avatars);
        };

        dataChannel.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                this.handleP2PMessage(message, peerId);
            } catch (error) {
                ui.updateStatus(`❌ Invalid P2P message from ${peerId}: ${error.message}`);
            }
        };
    }

    handleP2PMessage(message, fromPeer) {
        const peer = this.peers.get(fromPeer);
        const avatar = this.avatars.get(fromPeer);

        if (!peer || !avatar) return;

        switch (message.type) {
            case 'player_move':
                avatar.position.fromArray(message.payload.start);
                peer.targetPosition = new THREE.Vector3().fromArray(message.payload.target);
                peer.moveStartTime = performance.now();
                break;

            case 'player_sync':
                avatar.position.fromArray(message.payload.position);
                if (message.payload.target) {
                    peer.targetPosition = new THREE.Vector3().fromArray(message.payload.target);
                    peer.moveStartTime = performance.now();
                }
                break;

            case 'player_harvest':
                // Store harvest state for this peer
                peer.harvestState = {
                    harvestType: message.payload.harvestType,
                    startTime: message.payload.startTime,
                    duration: message.payload.duration,
                    endTime: message.payload.startTime + message.payload.duration
                };

                // Play chopping animation for peer avatar if available
                if (peer.animationMixer && peer.choppingAction) {
                    peer.choppingAction.reset();
                    peer.choppingAction.play();
                }

                console.log(`Peer ${fromPeer} started harvesting ${message.payload.harvestType}`);
                break;

            case 'player_sound':
                // Play positional sound attached to peer's avatar
                if (this.audioManager && avatar) {
                    this.audioManager.playPositionalSound(message.payload.soundType, avatar);
                    console.log(`Playing ${message.payload.soundType} sound for peer ${fromPeer}`);
                }
                break;
        }
    }

    broadcastP2P(message) {
        let sentCount = 0;
        this.peers.forEach((peer) => {
            if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                try {
                    peer.dataChannel.send(JSON.stringify(message));
                    sentCount++;
                } catch (error) {
                    console.error('Failed to send P2P message:', error);
                }
            }
        });
        return sentCount;
    }

    cleanupPeer(peerId, scene) {
        const peer = this.peers.get(peerId);
        if (peer) {
            if (peer.dataChannel) peer.dataChannel.close();
            if (peer.connection) peer.connection.close();
            this.peers.delete(peerId);
        }

        const avatar = this.avatars.get(peerId);
        if (avatar) {
            scene.remove(avatar);
            if (avatar.geometry) avatar.geometry.dispose();
            if (avatar.material) avatar.material.dispose();
            this.avatars.delete(peerId);
        }

        ui.updatePeerInfo(this.peers, this.avatars);
    }
}

// ==========================================
// CHUNK MANAGER
// ==========================================

class ChunkManager {
    constructor(gameState, terrainRenderer, scene) {
        this.gameState = gameState;
        this.terrainRenderer = terrainRenderer;
        this.scene = scene;
        this.loadRadius = TERRAIN_CONFIG.TERRAIN.renderDistance;
        this.chunkSize = TERRAIN_CONFIG.TERRAIN.chunkSize;
        this.pendingChunkCreations = []; // Queue for throttled chunk creation
        this.pendingChunkDisposals = []; // Queue for deferred chunk disposal
        this.lastPlayerChunkX = 0;
        this.lastPlayerChunkZ = 0;
        this.movementDirectionX = 0;
        this.movementDirectionZ = 0;
        this.scheduleIdleCleanup();
    }

    updatePlayerChunk(playerX, playerZ) {
        const newChunkX = Math.floor(roundCoord(playerX) / this.chunkSize);
        const newChunkZ = Math.floor(roundCoord(playerZ) / this.chunkSize);

        if (newChunkX === this.gameState.currentPlayerChunkX &&
            newChunkZ === this.gameState.currentPlayerChunkZ) {
            return false; // No change
        }

        // Track movement direction for predictive loading
        if (this.lastPlayerChunkX !== 0 || this.lastPlayerChunkZ !== 0) {
            this.movementDirectionX = newChunkX - this.lastPlayerChunkX;
            this.movementDirectionZ = newChunkZ - this.lastPlayerChunkZ;
        } else {
            // First move - initialize last position
            this.lastPlayerChunkX = this.gameState.currentPlayerChunkX;
            this.lastPlayerChunkZ = this.gameState.currentPlayerChunkZ;
        }

        this.lastPlayerChunkX = newChunkX;
        this.lastPlayerChunkZ = newChunkZ;

        this.gameState.updateChunkPosition(newChunkX, newChunkZ);
        this.updateChunksAroundPlayer(newChunkX, newChunkZ);
        return true;
    }

    updateChunksAroundPlayer(chunkX, chunkZ) {
        const chunksToKeep = new Set();
        const chunksToCreate = [];

        for (let x = -this.loadRadius; x <= this.loadRadius; x++) {
            for (let z = -this.loadRadius; z <= this.loadRadius; z++) {
                const gridX = chunkX + x;
                const gridZ = chunkZ + z;
                const key = `${gridX},${gridZ}`;
                chunksToKeep.add(key);

                if (!this.terrainRenderer.chunkMap.has(key)) {
                    // Calculate distance from player chunk and alignment with movement
                    const distance = Math.abs(x) + Math.abs(z);
                    const alignment = (x * this.movementDirectionX) + (z * this.movementDirectionZ);

                    // Instead of creating immediately, add to pending queue with priority
                    chunksToCreate.push({
                        gridX,
                        gridZ,
                        key,
                        distance,
                        alignment
                    });
                }
            }
        }

        // Clear old pending chunks that are no longer needed
        this.pendingChunkCreations = this.pendingChunkCreations.filter(pending =>
            chunksToKeep.has(pending.key)
        );

        // Add new chunks to queue (avoid duplicates)
        chunksToCreate.forEach(chunk => {
            if (!this.pendingChunkCreations.some(pending => pending.key === chunk.key)) {
                this.pendingChunkCreations.push(chunk);
            }
        });

        // Sort queue by priority: prefer chunks in movement direction, then by distance
        this.pendingChunkCreations.sort((a, b) => {
            // Higher alignment (in movement direction) = higher priority (lower sort value)
            // Lower distance = higher priority (lower sort value)
            const priorityA = a.distance - (a.alignment * 2); // Weight alignment heavily
            const priorityB = b.distance - (b.alignment * 2);
            return priorityA - priorityB;
        });

        Array.from(this.terrainRenderer.chunkMap.keys()).forEach(key => {
            if (!chunksToKeep.has(key)) {
                // Queue chunk for disposal instead of disposing immediately
                if (!this.pendingChunkDisposals.includes(key)) {
                    this.pendingChunkDisposals.push(key);
                }
            }
        });
    }

    scheduleIdleCleanup() {
        // Don't use requestIdleCallback in games - it waits for browser idle which rarely happens
        // Instead, use a regular timer to ensure chunks get disposed promptly
        // Process disposal queue every 4 seconds to prioritize new chunk creation when crossing borders
        setTimeout(() => {
            this.processDisposalQueue();
            // Reschedule for continuous cleanup
            this.scheduleIdleCleanup();
        }, 4000); // Process every 4 seconds to prioritize new chunk creation
    }

    processDisposalQueue() {
        // Process up to 4 chunk disposals per idle callback (increased from 2)
        const batchSize = 4;
        let processed = 0;
        const startTime = performance.now();
        let attempts = 0;
        const maxAttempts = this.pendingChunkDisposals.length; // Prevent infinite loop

        // Log when disposal runs
        if (this.pendingChunkDisposals.length > 0) {
            console.log(`🔄 Processing disposal queue (${this.pendingChunkDisposals.length} chunks pending)`);
        }

        while (this.pendingChunkDisposals.length > 0 && processed < batchSize && attempts < maxAttempts) {
            attempts++;
            const key = this.pendingChunkDisposals[0]; // PEEK at first item, don't remove yet

            // Check if chunk exists OR is still being processed OR in vertex queue
            const inChunkMap = this.terrainRenderer.chunkMap.has(key);
            const inProcessing = this.terrainRenderer.processingChunks.has(key);
            const inVertexQueue = this.terrainRenderer.pendingVertexUpdates.some(task => task.key === key);

            console.log(`  Checking chunk ${key}: map=${inChunkMap}, processing=${inProcessing}, vertex=${inVertexQueue}`);

            if (inChunkMap || inProcessing || inVertexQueue) {
                // Now we can remove it from queue and dispose
                this.pendingChunkDisposals.shift();
                const disposeStartTime = performance.now();
                this.disposeChunk(key);
                const disposeTime = performance.now() - disposeStartTime;
                if (disposeTime > 5) {
                    console.log(`⚠️ Chunk disposal took ${disposeTime.toFixed(2)}ms for ${key}`);
                }
                processed++;

                // Log what state the chunk was in when disposed
                if (!inChunkMap && (inProcessing || inVertexQueue)) {
                    console.log(`🧹 Disposed in-progress chunk ${key} (processing: ${inProcessing}, queued: ${inVertexQueue})`);
                }
            } else {
                // Chunk not found anywhere - might be truly stuck or already gone
                this.pendingChunkDisposals.shift(); // Remove it anyway
                console.log(`❓ Chunk ${key} not found anywhere, removing from disposal queue`);
            }
        }

        const totalTime = performance.now() - startTime;
        if (processed > 0 && totalTime > 10) {
            console.log(`⚠️ Disposal batch took ${totalTime.toFixed(2)}ms for ${processed} chunks`);
        }
    }

    processChunkQueue() {
        // Process only 1 chunk per frame for smooth performance
        if (this.pendingChunkCreations.length > 0) {
            const startTime = performance.now();
            const chunk = this.pendingChunkCreations.shift();
            this.createChunk(chunk.gridX, chunk.gridZ);
            const elapsed = performance.now() - startTime;
            if (elapsed > 5) {
                console.log(`⚠️ Chunk creation took ${elapsed.toFixed(2)}ms for ${chunk.key}`);
            }
            return true; // Chunk was created
        }
        return false; // No chunks to create
    }

createChunk(gridX, gridZ) {
    const worldX = gridX * this.chunkSize;
    const worldZ = gridZ * this.chunkSize;
    const chunkKey = `${gridX},${gridZ}`;

    // ALWAYS ensure cache has an entry for this chunk (even if empty)
    if (!this.gameState.removedObjectsCache.has(chunkKey)) {
        this.gameState.removedObjectsCache.set(chunkKey, new Set());
    }

    // Get cached removals for this chunk (now guaranteed to be a Set)
    const removedIds = this.gameState.removedObjectsCache.get(chunkKey);

    // Pass removals to terrain renderer
    this.terrainRenderer.createChunk(worldX, worldZ, removedIds);
}

    applyChunkRemovals(chunkKey) {
    const objects = this.terrainRenderer.chunkTrees.get(chunkKey);
    if (!objects) {
        return;
    }

    const removedIds = this.gameState.removedObjectsCache.get(chunkKey);
    if (!removedIds || removedIds.size === 0) {
        return;
    }

    // Remove objects that are in the removal list
    objects.forEach(obj => {
        const objectId = obj.userData.objectId;
        if (removedIds.has(objectId)) {
            this.scene.remove(obj);
            this.disposeObject(obj);
        }
    });

    // Filter out the removed objects from the tracked array
    const keptObjects = objects.filter(obj => !removedIds.has(obj.userData.objectId));
    this.terrainRenderer.chunkTrees.set(chunkKey, keptObjects);
}

    disposeChunk(key) {
    this.terrainRenderer.disposeChunk(key);
}

    removeObject(objectId) {
        const object = objectPlacer.findObjectById(this.scene, objectId);
        if (object && object.userData.chunkKey) {
            const chunkKey = object.userData.chunkKey;

            // Add to cache
            if (!this.gameState.removedObjectsCache.has(chunkKey)) {
                this.gameState.removedObjectsCache.set(chunkKey, new Set());
            }
            this.gameState.removedObjectsCache.get(chunkKey).add(objectId);

            // Remove from scene
            this.scene.remove(object);
            this.disposeObject(object);
            // Remove from chunkTrees array
        const trees = this.terrainRenderer.chunkTrees.get(chunkKey);
        if (trees) {
            const filteredTrees = trees.filter(obj => obj.userData.objectId !== objectId);
            this.terrainRenderer.chunkTrees.set(chunkKey, filteredTrees);
        }

            // Update nearest object if this was it
            if (this.gameState.nearestObject && this.gameState.nearestObject.id === objectId) {
                this.gameState.nearestObject = null;
                this.gameState.nearestObjectDistance = Infinity;
                ui.updateNearestObject(null, null, null, null, null);
                ui.updateButtonStates(this.gameState.isInChunk, null, false, false, false, null, this.gameState.isMoving);
            }
            return true;
        }
        return false;
    }

    disposeObject(object) {
        // Dispose blob shadow first
        if (object.userData && object.userData.blobShadow) {
            object.userData.blobShadow.dispose();
            object.userData.blobShadow = null;
        }

        // Dispose mesh resources
        object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        });
    }
}


// ==========================================
// MAIN GAME CLASS
// ==========================================

class MultiplayerGame {
    constructor() {
        this.gameState = new GameState();
        this.setupScene();
        this.setupRenderers();
        this.setupNetworking();
        this.setupInput();
        this.setupUI();

        // Animation constants
        this.playerSpeed = 0.0105;  // change to 0.0005 when done testing
        this.stopThreshold = 0.01;
        this.chunkUpdateInterval = 1000;
        this.proximityCheckInterval = 2000;
        this.peerCheckInterval = 5000;

        // Create throttled validation function to reduce lag spikes
        this.validationThrottleTimeout = null;
        this.validateFoundationPlacementThrottled = () => {
            // Clear existing timeout
            if (this.validationThrottleTimeout) {
                clearTimeout(this.validationThrottleTimeout);
            }
            // Set new timeout for validation (50ms delay)
            this.validationThrottleTimeout = setTimeout(() => {
                this.validateFoundationPlacement();
            }, 50);
        };

        // FPS tracking
        this.fpsFrames = 0;
        this.fpsLastTime = performance.now();
        this.fpsUpdateInterval = 500; // Update FPS display every 500ms

        // Frame counter for diagnostic logging
        this.frameCount = 0;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1.0, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x000011);
        // Shadow mapping disabled - using blob shadows instead
        document.body.appendChild(this.renderer.domElement);

        // Increase ambient light for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Increased from 0.6
        this.scene.add(ambientLight);

        // Add a second directional light from the opposite side for fill lighting
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-10, 10, -10);
        this.scene.add(fillLight);

        this.directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        this.directionalLight.position.set(15, 20, 0);
        this.scene.add(this.directionalLight);

        // Create player object (will be replaced with man model after loading)
        this.playerObject = new THREE.Group();
        this.playerObject.position.set(1.5, 1.21, -2);
        this.scene.add(this.playerObject);

        // Player scale
        this.playerScale = 0.0325; // 30% bigger than 0.025

        // Animation support
        this.animationMixer = null;
        this.animationAction = null;

        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();

        // Initialize audio manager
        this.audioManager = new AudioManager(this.camera);
        this.audioManager.loadSounds();
    }

    setupRenderers() {
        this.terrainRenderer = new SimpleTerrainRenderer(this.scene);
        this.waterRenderer = new WaterRenderer(this.scene, 1.02, this.terrainRenderer);
        this.terrainRenderer.setWaterRenderer(this.waterRenderer);

        this.chunkManager = new ChunkManager(
            this.gameState,
            this.terrainRenderer,
            this.scene
        );
    }

    setupNetworking() {
        this.networkManager = new NetworkManager(
            this.gameState,
            this.handleServerMessage.bind(this)
        );

        // Set audio manager reference in NetworkManager for P2P sounds
        this.networkManager.setAudioManager(this.audioManager);
    }

    setupInput() {
        window.addEventListener('pointerdown', this.onPointerDown.bind(this));
        window.addEventListener('pointermove', this.onPointerMove.bind(this));

        // Keyboard input for inventory and build menu toggle
        window.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                this.toggleInventory();
            }
            if (event.key === 'b' || event.key === 'B') {
                this.toggleBuildMenu();
            }
            // ESC key cancels foundation placement
            if (event.key === 'Escape' && this.gameState.foundationPlacement.active) {
                this.cancelFoundationPlacement();
                ui.updateStatusLine1('Placement cancelled', 3000);
            }
        });

        // Zoom controls
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => {
                this.zoomIn();
            });
        }

        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => {
                this.zoomOut();
            });
        }
    }

    setupUI() {
        ui.initializeUI({
            sendServerMessage: this.networkManager.sendMessage.bind(this.networkManager),
            clientId: this.gameState.clientId,
            getCurrentChunkX: () => this.gameState.currentPlayerChunkX,
            getCurrentChunkZ: () => this.gameState.currentPlayerChunkZ,
            getNearestObject: () => this.gameState.nearestObject,
            onRemoveObject: (object) => {
                if (object) {
                    // Check if it's a log - if so, treat as firewood harvest
                    const isLog = object.name.endsWith('_log') || object.name === 'log';
                    const isRock = object.name === 'limestone' || object.name === 'sandstone';

                    if (isLog) {
                        this.startHarvestAction(object, 'firewood');
                    } else if (isRock) {
                        this.startHarvestAction(object, 'stone');
                    } else {
                        // Start the chopping action for trees (includes timer, animation, sound)
                        this.startChoppingAction(object);
                    }
                }
            },
            onHarvestLog: (object, harvestType) => {
                if (object) {
                    this.startHarvestAction(object, harvestType);
                }
            },
            onResize: this.onResize.bind(this),
            resumeAudio: () => {
                if (this.audioManager) {
                    this.audioManager.resumeContext();
                }
            },
            toggleInventory: this.toggleInventory.bind(this),
            toggleBuildMenu: this.toggleBuildMenu.bind(this),
            toggleConstructionInventory: this.toggleConstructionInventory.bind(this),
            onBuildConstruction: this.startBuildAction.bind(this)
        });
        window.addEventListener('resize', this.onResize.bind(this));
    }

    async start() {
        ui.updateStatus("🎮 Game initialized");
        ui.updateConnectionStatus('connecting', '🔄 Connecting...');

        // Wait for models to load before setting up player
        ui.updateStatus("⏳ Loading player model...");
        await modelManager.loadAllModels();
        ui.updateStatus("✅ Models loaded");

        // Load and setup player model
        this.setupPlayerModel();

        // Initialize inventory UI
        this.initializeInventory();

        // Initialize build menu UI
        this.initializeBuildMenu();

        this.networkManager.connect();
        this.animate();
    }

    setupPlayerModel() {
        const manGLTF = modelManager.getGLTF('man');

        if (!manGLTF) {
            console.error('Man model not loaded');
            return;
        }

        // CRITICAL FIX: Use original scene directly - cloning breaks skeleton binding for SkinnedMesh
        const playerMesh = manGLTF.scene;
        playerMesh.scale.set(this.playerScale, this.playerScale, this.playerScale);

        // Debug: Log all meshes in the model
        console.log('Man model structure:');
        playerMesh.traverse((child) => {
            if (child.isMesh || child.isSkinnedMesh) {
                const matInfo = child.material ?
                    `mat: ${child.material.type}, opacity: ${child.material.opacity}, transparent: ${child.material.transparent}` :
                    'no material';
                console.log(`  - ${child.name} (${child.type}), visible: ${child.visible}, ${matInfo}, hasGeometry: ${!!child.geometry}`);
            }
        });

        // Setup materials and proper lighting
        playerMesh.traverse((child) => {
            if (child.isMesh || child.isSkinnedMesh) {
                child.visible = true; // Ensure visibility
                child.frustumCulled = false; // Disable frustum culling
                child.renderOrder = 1; // Render after terrain

                // Fix dark materials - ensure they respond to lighting
                if (child.material) {
                    // Re-enable depth testing (need this for proper rendering)
                    child.material.depthWrite = true;
                    child.material.depthTest = true;

                    // MeshStandardMaterial should already work with lights
                    // But make sure it's not too dark
                    if (child.material.type === 'MeshStandardMaterial') {
                        // Don't override color, but ensure it receives light properly
                        child.material.needsUpdate = true;
                    }
                }
            }
        });

        // Add to player object
        this.playerObject.add(playerMesh);

        // Calculate bounding box to find model's dimensions
        const box = new THREE.Box3().setFromObject(playerMesh);
        const center = box.getCenter(new THREE.Vector3());
        const size = new THREE.Vector3();
        box.getSize(size);

        // Store the Z offset needed to align feet with click position
        this.playerModelOffset = center.z;

        // Store actual model height for terrain following
        this.playerModelHeight = size.y;

        console.log(`Player model center offset: ${this.playerModelOffset}`);
        console.log(`Player model height: ${this.playerModelHeight.toFixed(3)}`);

        // Setup animation
        if (manGLTF.animations && manGLTF.animations.length > 0) {
            this.animationMixer = new THREE.AnimationMixer(playerMesh);

            // Search for walk animation by name
            const walkAnimation = manGLTF.animations.find(anim =>
                anim.name.toLowerCase().includes('walk')
            );

            if (walkAnimation) {
                console.log(`Found walk animation: ${walkAnimation.name}`);
                this.animationAction = this.animationMixer.clipAction(walkAnimation);
                this.animationAction.play();
            } else {
                console.warn('Walk animation not found, available animations:',
                    manGLTF.animations.map(a => a.name));
            }

            // Search for chopping/pickaxe animation
            const choppingAnimation = manGLTF.animations.find(anim => {
                const name = anim.name.toLowerCase();
                return name.includes('chop') || name.includes('pickaxe') ||
                       name.includes('axe') || name.includes('swing') ||
                       name.includes('mine') || name.includes('dig');
            });

            if (choppingAnimation) {
                console.log(`Found chopping animation: ${choppingAnimation.name}`);
                this.choppingAction = this.animationMixer.clipAction(choppingAnimation);
                this.choppingAction.loop = THREE.LoopRepeat;
            } else {
                console.warn('Chopping animation not found, will use walk animation as fallback');
                console.log('Available animations:', manGLTF.animations.map(a => a.name));
                // Use walk animation as fallback for chopping
                if (walkAnimation) {
                    this.choppingAction = this.animationMixer.clipAction(walkAnimation);
                    this.choppingAction.loop = THREE.LoopRepeat;
                }
            }
        }

        // Set player object reference in NetworkManager for P2P state sync
        this.networkManager.setPlayerObject(this.playerObject);
    }

    // --- Server Message Handlers ---

    handleServerMessage(type, payload) {
        switch (type) {
            case 'server_connected':
                this.handleServerConnected();
                break;
            case 'webrtc_offer':
                this.handleWebRTCOffer(payload);
                break;
            case 'webrtc_answer':
                this.handleWebRTCAnswer(payload);
                break;
            case 'webrtc_ice_candidate':
                this.handleWebRTCIceCandidate(payload);
                break;
            case 'proximity_update':
                this.handleProximityUpdate(payload);
                break;
            case 'object_removed':
                this.handleObjectRemoved(payload);
                break;
            case 'object_added':
                this.handleObjectAdded(payload);
                break;
            case 'resource_harvested':
                this.handleResourceHarvested(payload);
                break;
            case 'harvest_lock_failed':
                this.handleHarvestLockFailed(payload);
                break;
            case 'chunk_objects_state':
                this.handleChunkObjectsState(payload);
                break;
            case 'crate_inventory_response':
                this.handleCrateInventoryResponse(payload);
                break;
            case 'crate_inventory_updated':
                this.handleCrateInventoryUpdated(payload);
                break;
        }
    }

    handleServerConnected() {
    const { chunkSize } = TERRAIN_CONFIG.TERRAIN;
    const initialChunkX = Math.floor(this.playerObject.position.x / chunkSize);
    const initialChunkZ = Math.floor(this.playerObject.position.z / chunkSize);
    const chunkId = `chunk_${initialChunkX},${initialChunkZ}`;

    const success = this.networkManager.sendMessage('join_chunk', {
        chunkId,
        clientId: this.gameState.clientId
    });

    if (success) {
        this.gameState.isInChunk = true;
        this.gameState.updateChunkPosition(initialChunkX, initialChunkZ);
        ui.updateButtonStates(true, null, false, false, false, null, this.gameState.isMoving);
    }

    // Don't create chunks yet - wait for server state
}

    handleChunkObjectsState(payload) {
    const { objectChanges } = payload;
    if (!objectChanges || !Array.isArray(objectChanges)) return;

    // Group changes by chunk
    const changesByChunk = new Map();

    objectChanges.forEach(change => {
        if (change.action === 'remove') {
            // Handle missing chunkId (old format or corrupted data)
            if (!change.chunkId) {
                console.warn(`Remove action missing chunkId for object ${change.id}, skipping`);
                return;
            }

            const chunkKey = change.chunkId.replace('chunk_', '');

            // Add to cache
            if (!this.gameState.removedObjectsCache.has(chunkKey)) {
                this.gameState.removedObjectsCache.set(chunkKey, new Set());
            }
            this.gameState.removedObjectsCache.get(chunkKey).add(change.id);

            // Track which chunks need removal applied
            changesByChunk.set(chunkKey, true);
        } else if (change.action === 'add') {
            // Handle added objects (logs, etc.)
            const chunkKey = change.chunkId.replace('chunk_', '');

            // Check if object was recently deleted - prevent re-adding depleted resources from stale chunk state
            const removedSet = this.gameState.removedObjectsCache.get(chunkKey);
            if (removedSet && removedSet.has(change.id)) {
                console.log(`[DEPLETION FIX] Blocking re-add of deleted object ${change.id} (${change.name}) - was removed and still in cache`);
                return; // Skip this object - it was deleted
            }

            // Check if object already exists in scene (prevent duplicates on chunk crossing)
            let existingObject = null;
            this.scene.traverse((object) => {
                if (object.userData && object.userData.objectId === change.id) {
                    existingObject = object;
                }
            });

            if (existingObject) {
                // Object already exists - update its properties instead of creating duplicate
                existingObject.userData.remainingResources = change.remainingResources || null;
                existingObject.userData.totalResources = change.totalResources || null;
                console.log(`Object ${change.id} already exists, updated resources to ${change.remainingResources}/${change.totalResources}`);
            } else {
                console.log(`[RE-ADD CHECK] Attempting to add object ${change.id} (${change.name}) with ${change.remainingResources}/${change.totalResources} resources`);

                // Object doesn't exist - create it
                const objectPosition = new THREE.Vector3(change.position[0], change.position[1], change.position[2]);
                // Use stored rotation if available (for structures), otherwise random
                const objectRotation = change.rotation !== undefined ? (change.rotation * Math.PI / 180) : (Math.random() * Math.PI * 2);
                const objectInstance = objectPlacer.createInstance(
                    change.name,
                    objectPosition,
                    change.scale,
                    objectRotation,
                    this.scene
                );

                if (objectInstance) {
                    objectInstance.userData.objectId = change.id;
                    objectInstance.userData.chunkKey = chunkKey;
                    objectInstance.userData.quality = change.quality;
                    objectInstance.userData.modelType = change.name;
                    objectInstance.userData.totalResources = change.totalResources || null;
                    objectInstance.userData.remainingResources = change.remainingResources || null;

                    // Preserve construction site metadata if applicable
                    if (change.isConstructionSite) {
                        objectInstance.userData.isConstructionSite = true;
                        objectInstance.userData.targetStructure = change.targetStructure;
                        objectInstance.userData.requiredMaterials = change.requiredMaterials || {};
                        objectInstance.userData.materials = change.materials || {};
                        objectInstance.userData.rotation = change.rotation;
                        objectInstance.userData.finalFoundationY = change.finalFoundationY;
                    }

                    this.scene.add(objectInstance);

                    // Add to chunkTrees
                    const chunkObjects = this.terrainRenderer.chunkTrees.get(chunkKey) || [];
                    chunkObjects.push(objectInstance);
                    this.terrainRenderer.chunkTrees.set(chunkKey, chunkObjects);

                    console.log(`Added ${change.name} from server state to chunk ${chunkKey} (resources: ${change.remainingResources}/${change.totalResources})`);

                    // Update blob shadow
                    if (objectInstance.userData.blobShadow) {
                        const fakeLight = new THREE.Vector3(change.position[0] + 100, 20, change.position[2]);
                        objectInstance.userData.blobShadow.update(
                            (x, z) => this.terrainRenderer.heightCalculator.calculateHeight(x, z),
                            fakeLight,
                            (x, z) => {
                                const normal = this.terrainRenderer.heightCalculator.calculateNormal(x, z);
                                return new THREE.Vector3(normal.x, normal.y, normal.z);
                            }
                        );
                    }
                }
            }
        }
    });

    // Apply removals to existing chunks
    changesByChunk.forEach((_, chunkKey) => {
        this.chunkManager.applyChunkRemovals(chunkKey);
    });

    // If this is the first chunk state after connecting, create the initial chunks
if (this.terrainRenderer.chunkMap.size === 0) {
    this.chunkManager.updateChunksAroundPlayer(
        this.gameState.currentPlayerChunkX,
        this.gameState.currentPlayerChunkZ
    );
}
}

    handleObjectRemoved(payload) {
        if (this.chunkManager.removeObject(payload.objectId)) {
            ui.updateStatus(`Removed object ${payload.objectId} from scene`);
        } else {
            console.warn(`Object ${payload.objectId} not found in current chunks.`);
        }

        // Update proximity after server confirms removal
        this.checkProximityToObjects();
    }

    handleObjectAdded(payload) {
        const { objectId, objectType, position, quality, scale, chunkId, totalResources, remainingResources, rotation, isConstructionSite, targetStructure, requiredMaterials, materials, finalFoundationY, inventory } = payload;

        // Extract chunk coordinates from chunkId (format: "chunk_x,z")
        const chunkKey = chunkId.replace('chunk_', '');

        // Check if object already exists in scene (prevent duplicates)
        let existingObject = null;
        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId === objectId) {
                existingObject = object;
            }
        });

        if (existingObject) {
            // Object already exists - update its properties instead of creating duplicate
            existingObject.userData.remainingResources = remainingResources || null;
            existingObject.userData.totalResources = totalResources || null;
            console.log(`Object ${objectId} already exists, updated from broadcast`);
            return; // Don't create duplicate
        }

        // Create the object instance
        const objectPosition = new THREE.Vector3(position[0], position[1], position[2]);

        // Use provided rotation if available (for construction sites), otherwise random
        const objectRotation = rotation !== undefined ? (rotation * Math.PI / 180) : (Math.random() * Math.PI * 2);

        const objectInstance = objectPlacer.createInstance(
            objectType,
            objectPosition,
            scale,
            objectRotation,
            this.scene
        );

        if (objectInstance) {
            objectInstance.userData.objectId = objectId;
            objectInstance.userData.chunkKey = chunkKey;
            objectInstance.userData.quality = quality;
            objectInstance.userData.modelType = objectType;
            objectInstance.userData.totalResources = totalResources || null;
            objectInstance.userData.remainingResources = remainingResources || null;

            // Store construction site metadata if applicable
            if (isConstructionSite) {
                objectInstance.userData.isConstructionSite = true;
                objectInstance.userData.targetStructure = targetStructure;
                objectInstance.userData.requiredMaterials = requiredMaterials || {};
                objectInstance.userData.materials = materials || {};
                objectInstance.userData.rotation = rotation;
                objectInstance.userData.finalFoundationY = finalFoundationY;
            }

            // Store crate inventory if applicable
            if (objectType === 'crate' && inventory) {
                objectInstance.userData.inventory = inventory;
            }

            this.scene.add(objectInstance);

            // Add to chunkTrees for proximity detection
            const chunkObjects = this.terrainRenderer.chunkTrees.get(chunkKey) || [];
            chunkObjects.push(objectInstance);
            this.terrainRenderer.chunkTrees.set(chunkKey, chunkObjects);

            // Update blob shadow
            if (objectInstance.userData.blobShadow) {
                const fakeLight = new THREE.Vector3(position[0] + 100, 20, position[2]);
                objectInstance.userData.blobShadow.update(
                    (x, z) => this.terrainRenderer.heightCalculator.calculateHeight(x, z),
                    fakeLight,
                    (x, z) => {
                        const normal = this.terrainRenderer.heightCalculator.calculateNormal(x, z);
                        return new THREE.Vector3(normal.x, normal.y, normal.z);
                    }
                );
            }

            ui.updateStatus(`${objectType} spawned in world`);
        } else {
            console.error(`Failed to create ${objectType} instance`);
        }

        // Update proximity after server confirms addition (e.g., log from chopped tree)
        this.checkProximityToObjects();
    }

    handleResourceHarvested(payload) {
        const { objectId, harvestType, remainingResources, depleted, harvestedBy } = payload;

        // Find the resource object in chunkTrees (this is the authoritative reference used by proximity checks)
        let resourceObject = null;
        let foundInChunk = null;

        this.terrainRenderer.chunkTrees.forEach((chunkObjects, chunkKey) => {
            const obj = chunkObjects.find(o => o.userData.objectId === objectId);
            if (obj) {
                resourceObject = obj;
                foundInChunk = chunkKey;
            }
        });

        if (resourceObject) {
            // Update remaining resources in the chunkTrees object
            resourceObject.userData.remainingResources = remainingResources;

            // Update nearestObject display if this is the currently selected object
            if (this.gameState.nearestObject && this.gameState.nearestObject.id === objectId) {
                this.gameState.nearestObject.remainingResources = remainingResources;
                // Trigger UI update
                const hasAxe = this.hasToolWithDurability('axe');
                const hasSaw = this.hasToolWithDurability('saw');
                const isOnCooldown = this.gameState.harvestCooldown && this.gameState.harvestCooldown.endTime > Date.now();
                ui.updateNearestObject(
                    this.gameState.nearestObject.name,
                    this.gameState.nearestObject.toolCheck,
                    this.gameState.nearestObject.quality,
                    this.gameState.nearestObject.remainingResources,
                    this.gameState.nearestObject.totalResources
                );
                ui.updateButtonStates(this.gameState.isInChunk, this.gameState.nearestObject, hasAxe, hasSaw, isOnCooldown, this.gameState.nearestConstructionSite, this.gameState.isMoving, this.gameState.nearestCrate);
            }

            // If this client harvested it, handle durability and inventory
            if (harvestedBy === this.gameState.clientId) {
                // Determine which tool was used
                let toolType;
                if (harvestType === 'firewood') {
                    toolType = 'axe';
                } else if (harvestType === 'planks') {
                    toolType = 'saw';
                } else if (harvestType === 'stone') {
                    toolType = 'pickaxe';
                }

                // Find the tool in inventory
                const tool = this.gameState.inventory.items.find(item =>
                    item.type === toolType && item.durability > 0
                );

                if (tool) {
                    // Calculate durability loss based on material quality: ceil(100 / materialQuality)
                    // Higher quality materials cause more durability loss
                    const materialQuality = resourceObject.userData.quality;
                    const durabilityLoss = Math.ceil(100 / materialQuality);
                    tool.durability = Math.max(0, tool.durability - durabilityLoss);

                    console.log(`Tool ${toolType} (quality ${tool.quality}) lost ${durabilityLoss} durability from quality ${materialQuality} material, now at ${tool.durability}`);

                    // Check if tool broke
                    if (tool.durability === 0) {
                        // Delete tool from inventory
                        const toolIndex = this.gameState.inventory.items.indexOf(tool);
                        if (toolIndex > -1) {
                            this.gameState.inventory.items.splice(toolIndex, 1);
                            console.log(`Tool ${toolType} broke and was removed from inventory`);
                        }
                        ui.updateStatus(`⚠️ Your ${toolType} broke!`);
                        ui.updateStatusLine2(`⚠️ Your ${toolType} broke!`, 5000);
                    }

                    // Re-render inventory if it's open
                    if (this.gameState.inventoryOpen) {
                        this.renderInventory();
                    }
                }

                // Create inventory item (firewood, plank, or stone)
                let materialType, itemWidth, itemHeight;
                const resourceName = resourceObject.userData.modelType;

                if (harvestType === 'stone') {
                    // Rock items are just the rock name (limestone or sandstone)
                    materialType = resourceName; // "limestone" or "sandstone"
                    itemWidth = 1;
                    itemHeight = 1;
                } else {
                    // Extract tree type from resource name (e.g., "oak_log" -> "oak")
                    const treeType = resourceName.replace('_log', ''); // e.g., "oak_log" -> "oak"
                    // Convert "planks" to "plank" (singular) to match image filenames
                    const materialSuffix = harvestType === 'planks' ? 'plank' : harvestType;
                    materialType = `${treeType}${materialSuffix}`; // e.g., "oakfirewood", "pineplank"
                    itemWidth = 2;
                    itemHeight = 4;
                }

                const newItem = {
                    id: `${materialType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: materialType,
                    x: -1, // Will be set when we find space
                    y: -1,
                    width: itemWidth,
                    height: itemHeight,
                    rotation: 0,
                    quality: resourceObject.userData.quality, // Inherit resource quality
                    durability: 100 // Harvested items start at full durability
                };

                // Try to add item to inventory
                if (this.tryAddItemToInventory(newItem)) {
                    ui.updateStatusLine1(`✅ Harvested ${materialType}`, 2000);
                    console.log(`Added ${materialType} to inventory`);

                    // Re-render inventory if it's open
                    if (this.gameState.inventoryOpen) {
                        this.renderInventory();
                    }
                } else {
                    ui.updateStatusLine2(`⚠️ Inventory full! ${materialType} dropped`, 4000);
                    console.warn(`Inventory full, could not add ${materialType}`);
                }

                // Start 3-second cooldown
                this.gameState.harvestCooldown = {
                    endTime: Date.now() + 3000
                };
                console.log('Started 3-second harvest cooldown');

                // Show countdown message on statusLine2
                let secondsRemaining = 3;
                ui.updateStatusLine2(`⏳ Resting (${secondsRemaining}s)`, 0); // 0 = don't auto-hide

                // Update countdown every second
                const countdownInterval = setInterval(() => {
                    secondsRemaining--;
                    if (secondsRemaining > 0) {
                        ui.updateStatusLine2(`⏳ Resting (${secondsRemaining}s)`, 0);
                    } else {
                        clearInterval(countdownInterval);
                        ui.updateStatusLine2(null); // Clear the message
                    }
                }, 1000);

                // Schedule proximity check after cooldown expires to re-show buttons
                setTimeout(() => {
                    this.checkProximityToObjects();
                    console.log('Cooldown expired, buttons refreshed');
                }, 3000);
            }

            // If depleted, remove from scene
            if (depleted) {
                console.log(`[DEPLETION] Resource ${objectId} marked as depleted by server`);

                // Find and remove the visual object from scene (might be different reference than chunkTrees)
                let sceneObject = null;
                this.scene.traverse((object) => {
                    if (object.userData && object.userData.objectId === objectId) {
                        sceneObject = object;
                    }
                });

                if (sceneObject) {
                    this.scene.remove(sceneObject);
                    // Dispose blob shadow from scene object
                    if (sceneObject.userData.blobShadow) {
                        sceneObject.userData.blobShadow.dispose();
                    }
                    console.log(`[DEPLETION] Removed visual object from scene`);
                } else {
                    console.error(`[DEPLETION] Visual object not found in scene!`);
                }

                // Remove from chunkTrees (data reference)
                const chunkKey = resourceObject.userData.chunkKey;
                const chunkObjects = this.terrainRenderer.chunkTrees.get(chunkKey);
                if (chunkObjects) {
                    const index = chunkObjects.indexOf(resourceObject);
                    if (index > -1) {
                        chunkObjects.splice(index, 1);
                        console.log(`[DEPLETION] Removed from chunkTrees (${chunkObjects.length} objects remaining)`);
                    }
                }

                console.log(`[DEPLETION] Resource ${objectId} fully removed from client`);
            } else {
                console.log(`Resource ${objectId} harvested for ${harvestType}, ${remainingResources} resources remaining`);
            }

            // Trigger proximity check to update UI
            this.checkProximityToObjects();
        } else {
            console.warn(`Resource ${objectId} not found in scene`);
        }
    }

    handleHarvestLockFailed(payload) {
        const { objectId, reason } = payload;

        // Check if we're currently harvesting this log
        if (this.gameState.activeChoppingAction &&
            this.gameState.activeChoppingAction.object.id === objectId) {

            // Stop sound
            if (this.gameState.activeChoppingAction.sound) {
                this.gameState.activeChoppingAction.sound.stop();
            }

            // Stop animation
            if (this.animationMixer && this.choppingAction) {
                this.choppingAction.stop();
            }

            // Clear active action
            this.gameState.activeChoppingAction = null;
            ui.updateChoppingProgress(0);

            // Show message to user
            ui.updateStatus(`⚠️ ${reason}`);
            ui.updateStatusLine2(`⚠️ ${reason}`, 4000);
            console.warn(`Harvest lock failed: ${reason}`);

            // Update proximity to refresh UI button states after lock failure
            this.checkProximityToObjects();
        }
    }

    handleProximityUpdate(payload) {
        const { players } = payload;
        ui.updateStatus(`📍 Proximity update: ${players.length} players`);

        const currentPeerIds = new Set(players.map(p => p.id));
        this.networkManager.peers.forEach((_, peerId) => {
            if (!currentPeerIds.has(peerId) && peerId !== this.gameState.clientId) {
                this.networkManager.cleanupPeer(peerId, this.scene);
            }
        });

        const newPlayers = players.filter(
            p => p.id !== this.gameState.clientId && !this.networkManager.peers.has(p.id)
        );

        if (newPlayers.length > 0) {
            this.staggerP2PInitiations(newPlayers);
        }
        ui.updatePeerInfo(this.networkManager.peers, this.networkManager.avatars);
    }

    handleCrateInventoryResponse(payload) {
        const { crateId, inventory } = payload;
        console.log(`Received crate inventory for ${crateId}: ${inventory.items.length} items`);

        // Find the crate object
        let crateObject = null;
        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId === crateId) {
                crateObject = object;
            }
        });

        if (crateObject) {
            // Store inventory in crate userData
            crateObject.userData.inventory = inventory;

            // If this is the nearest crate, update the display
            if (this.gameState.nearestCrate && this.gameState.nearestCrate.userData.objectId === crateId) {
                this.crateInventory = inventory;
                this.renderCrateInventory();
            }
        }
    }

    handleCrateInventoryUpdated(payload) {
        const { crateId, inventory } = payload;
        console.log(`Crate inventory updated for ${crateId}: ${inventory.items.length} items`);

        // Find the crate object
        let crateObject = null;
        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId === crateId) {
                crateObject = object;
            }
        });

        if (crateObject) {
            // Update inventory in crate userData
            crateObject.userData.inventory = inventory;

            // If this is the nearest crate and it's open, update the display
            if (this.gameState.nearestCrate &&
                this.gameState.nearestCrate.userData.objectId === crateId &&
                this.gameState.inventoryOpen) {
                this.crateInventory = inventory;
                this.renderCrateInventory();
            }
        }
    }

    startChoppingAction(object) {
        const treeTypes = ['oak', 'fir', 'pine', 'cypress'];
        const structureTypes = ['construction', 'foundation', 'foundationcorner', 'foundationroundcorner'];
        const isTree = treeTypes.includes(object.name);
        const isStructure = structureTypes.includes(object.name);

        // Start chopping action
        this.gameState.activeChoppingAction = {
            object: object,
            startTime: Date.now(),
            duration: isStructure ? CONFIG.ACTIONS.CHOP_STRUCTURE_DURATION : CONFIG.ACTIONS.CHOP_TREE_DURATION // From config.js
        };

        // Play appropriate sound
        if (isTree && this.audioManager) {
            const sound = this.audioManager.playAxeSound();
            this.gameState.activeChoppingAction.sound = sound;
        } else if (isStructure && this.audioManager) {
            const sound = this.audioManager.playHammerSound();
            this.gameState.activeChoppingAction.sound = sound;
        }

        // Start chopping animation
        if (this.animationMixer && this.choppingAction) {
            this.choppingAction.reset();
            this.choppingAction.play();
        }

        // Broadcast sound to peers
        if (isTree) {
            this.networkManager.broadcastP2P({
                type: 'player_sound',
                payload: {
                    soundType: 'axe',
                    startTime: Date.now()
                }
            });
        } else if (isStructure) {
            this.networkManager.broadcastP2P({
                type: 'player_sound',
                payload: {
                    soundType: 'hammer',
                    startTime: Date.now()
                }
            });
        }
    }

    startHarvestAction(object, harvestType) {
        // harvestType is 'firewood', 'planks', or 'stone'

        // Check if cooldown is active
        if (this.gameState.harvestCooldown) {
            const remaining = this.gameState.harvestCooldown.endTime - Date.now();
            if (remaining > 0) {
                ui.updateStatus(`⏳ Harvest cooldown: ${Math.ceil(remaining / 1000)}s`);
                return;
            } else {
                // Cooldown expired, clear it
                this.gameState.harvestCooldown = null;
            }
        }

        // Validate tool requirements
        let requiredTool;
        if (harvestType === 'firewood') {
            requiredTool = 'axe';
        } else if (harvestType === 'planks') {
            requiredTool = 'saw';
        } else if (harvestType === 'stone') {
            requiredTool = 'pickaxe';
        }

        if (!this.hasToolWithDurability(requiredTool)) {
            console.warn(`Cannot harvest ${harvestType}: missing ${requiredTool} with durability`);
            return;
        }

        // Start harvesting action
        this.gameState.activeChoppingAction = {
            object: object,
            startTime: Date.now(),
            duration: CONFIG.ACTIONS.HARVEST_LOG_DURATION, // 10 seconds from config.js
            harvestType: harvestType // Store harvest type for server request
        };

        // Play appropriate sound
        if (this.audioManager) {
            let sound;
            if (harvestType === 'firewood') {
                sound = this.audioManager.playAxeSound();
            } else if (harvestType === 'planks') {
                sound = this.audioManager.playSawSound();
            } else if (harvestType === 'stone') {
                sound = this.audioManager.playPickaxeSound();
            }
            this.gameState.activeChoppingAction.sound = sound;
        }

        // Start chopping animation
        if (this.animationMixer && this.choppingAction) {
            this.choppingAction.reset();
            this.choppingAction.play();
        }

        // Broadcast harvest action to peers
        this.networkManager.broadcastP2P({
            type: 'player_harvest',
            payload: {
                harvestType: harvestType,
                startTime: Date.now(),
                duration: 10000
            }
        });

        // Broadcast sound to peers
        let soundType;
        if (harvestType === 'firewood') {
            soundType = 'axe';
        } else if (harvestType === 'planks') {
            soundType = 'saw';
        } else if (harvestType === 'stone') {
            soundType = 'pickaxe';
        }

        this.networkManager.broadcastP2P({
            type: 'player_sound',
            payload: {
                soundType: soundType,
                startTime: Date.now()
            }
        });
    }

    startBuildAction() {
        // Check if we have a construction site nearby
        if (!this.gameState.nearestConstructionSite) {
            ui.updateStatus('⚠️ No construction site nearby');
            return;
        }

        // Check if already performing an action
        if (this.gameState.activeChoppingAction) {
            ui.updateStatus('⚠️ Already performing an action');
            return;
        }

        // Check if player has hammer in inventory
        if (!this.hasToolWithDurability('hammer')) {
            ui.updateStatus('⚠️ Need hammer to build');
            return;
        }

        // Check if all materials are satisfied
        const constructionSite = this.gameState.nearestConstructionSite;
        const requiredMaterials = constructionSite.userData.requiredMaterials || {};
        const currentMaterials = constructionSite.userData.materials || {};

        const allMaterialsSatisfied = Object.entries(requiredMaterials).every(
            ([material, quantity]) => (currentMaterials[material] || 0) >= quantity
        );

        if (!allMaterialsSatisfied) {
            ui.updateStatus('⚠️ Missing materials');
            return;
        }

        // Start building action
        this.gameState.activeChoppingAction = {
            object: constructionSite,
            startTime: Date.now(),
            duration: CONFIG.ACTIONS.BUILD_DURATION, // 6 seconds from config.js
            actionType: 'build'
        };

        // Play hammer sound
        if (this.audioManager) {
            const sound = this.audioManager.playHammerSound();
            this.gameState.activeChoppingAction.sound = sound;
        }

        // Start chopping animation (hammer animation)
        if (this.animationMixer && this.choppingAction) {
            this.choppingAction.reset();
            this.choppingAction.play();
        }

        // Broadcast sound to peers
        this.networkManager.broadcastP2P({
            type: 'player_sound',
            payload: {
                soundType: 'hammer',
                startTime: Date.now()
            }
        });

        ui.updateStatus('🔨 Building...');
    }

    startChiselingAction(chisel, stone) {
        // Check if already performing an action
        if (this.gameState.activeChoppingAction) {
            console.warn('Already performing an action');
            return;
        }

        // Check chisel durability
        if (chisel.durability <= 0) {
            ui.updateStatusLine2('⚠️ Chisel is broken!', 3000);
            return;
        }

        console.log(`Starting chiseling action on ${stone.type} (quality: ${stone.quality})`);

        // Start chiseling action (locks movement)
        this.gameState.activeChoppingAction = {
            object: null, // No world object for chiseling
            startTime: Date.now(),
            duration: CONFIG.ACTIONS.CHISELING_DURATION, // 6 seconds from config.js
            actionType: 'chiseling',
            chisel: chisel,
            stone: stone
        };

        // Play chisel sound
        if (this.audioManager) {
            const sound = this.audioManager.playChiselSound();
            this.gameState.activeChoppingAction.sound = sound;
        }

        // Start chopping animation
        if (this.animationMixer && this.choppingAction) {
            this.choppingAction.reset();
            this.choppingAction.play();
        }

        // Broadcast chisel sound to peers
        this.networkManager.broadcastP2P({
            type: 'player_sound',
            payload: {
                soundType: 'chisel',
                startTime: Date.now()
            }
        });

        // Close inventory
        if (this.gameState.inventoryOpen) {
            this.toggleInventory();
        }

        ui.updateStatusLine1('🔨 Chiseling...', 0);
    }

    updateChoppingAction() {
        if (!this.gameState.activeChoppingAction) return;

        const elapsed = Date.now() - this.gameState.activeChoppingAction.startTime;
        const progress = Math.min(elapsed / this.gameState.activeChoppingAction.duration, 1);

        // Update progress UI
        ui.updateChoppingProgress(progress);

        // Check if chopping is complete
        if (progress >= 1) {
            this.completeChoppingAction();
        }
    }

    completeChoppingAction() {
        if (!this.gameState.activeChoppingAction) return;

        const object = this.gameState.activeChoppingAction.object;
        const harvestType = this.gameState.activeChoppingAction.harvestType;
        const actionType = this.gameState.activeChoppingAction.actionType;

        // Stop sound
        if (this.gameState.activeChoppingAction.sound) {
            this.gameState.activeChoppingAction.sound.stop();
        }

        // Stop chopping animation
        if (this.animationMixer && this.choppingAction) {
            this.choppingAction.stop();
        }

        // Handle build completion
        if (actionType === 'build') {
            const constructionSite = object;

            // Find hammer in inventory
            const hammer = this.gameState.inventory.items.find(item => item.type === 'hammer' && item.durability > 0);

            if (hammer) {
                // Consume hammer durability (from config.js)
                hammer.durability = Math.max(0, hammer.durability - CONFIG.TOOLS.HAMMER_DURABILITY_LOSS);
                console.log(`Hammer durability reduced to ${hammer.durability}`);

                // Check if hammer broke
                if (hammer.durability === 0) {
                    // Delete hammer from inventory
                    const hammerIndex = this.gameState.inventory.items.indexOf(hammer);
                    if (hammerIndex > -1) {
                        this.gameState.inventory.items.splice(hammerIndex, 1);
                    }
                    ui.updateStatusLine1('⚠️ Hammer broke!', 3000);
                    console.log('Hammer broke during building');
                }

                // Send build completion to server
                this.networkManager.sendMessage('build_construction', {
                    constructionId: constructionSite.userData.objectId,
                    chunkKey: constructionSite.userData.chunkKey
                });

                ui.updateStatusLine1('✅ Construction complete!', 3000);
                console.log('Building complete');

                // Re-render inventory (includes construction section and crate section)
                if (this.gameState.inventoryOpen) {
                    this.renderInventory();
                    this.updateConstructionSection(); // Construction section will hide since site is gone
                    this.updateCrateSection(); // Crate section will show/hide based on proximity
                }
            }

            // Clear active chopping action
            this.gameState.activeChoppingAction = null;
            ui.updateChoppingProgress(0);
            return;
        }

        // Handle chiseling completion
        if (actionType === 'chiseling') {
            const chisel = this.gameState.activeChoppingAction.chisel;
            const stone = this.gameState.activeChoppingAction.stone;

            // Calculate durability loss based on stone quality
            const durabilityLoss = Math.ceil(100 / stone.quality);
            chisel.durability = Math.max(0, chisel.durability - durabilityLoss);

            console.log(`Chisel lost ${durabilityLoss} durability from quality ${stone.quality} stone, now at ${chisel.durability}`);

            // Check if chisel broke
            if (chisel.durability === 0) {
                // Delete chisel from inventory
                const chiselIndex = this.gameState.inventory.items.indexOf(chisel);
                if (chiselIndex > -1) {
                    this.gameState.inventory.items.splice(chiselIndex, 1);
                }
                ui.updateStatusLine1('⚠️ Chisel broke!', 4000);
                ui.updateStatusLine2(`Chiseling failed!`, 4000);
                console.log('Chisel broke during chiseling');
            } else {
                // Chiseling succeeded - convert stone to chiseled version
                const chiseledType = stone.type.replace('limestone', 'chiseledlimestone')
                                                .replace('sandstone', 'chiseledsandstone')
                                                .replace('Rlimestone', 'Rchiseledlimestone')
                                                .replace('Rsandstone', 'Rchiseledsandstone');

                // Update stone type in place (keeps position, quality, rotation)
                stone.type = chiseledType;

                ui.updateStatusLine1(`✅ Created ${chiseledType.replace('R', '')}`, 3000);
                console.log(`Chiseling complete: ${stone.type} created`);
            }

            // Re-render inventory
            if (this.gameState.inventoryOpen) {
                this.renderInventory();
            }

            // Clear active chopping action
            this.gameState.activeChoppingAction = null;
            ui.updateChoppingProgress(0);
            return;
        }

        // Check if this is a harvest action (log harvesting)
        if (harvestType) {
            // Send harvest_resource_request to server with complete object data
            // This allows the server to handle natural resources on first interaction
            this.networkManager.sendMessage('harvest_resource_request', {
                chunkId: `chunk_${object.chunkKey}`,
                objectId: object.id,
                harvestType: harvestType, // 'firewood' or 'planks'
                clientId: this.gameState.clientId,
                objectData: {
                    name: object.name,
                    position: object.position.toArray(),
                    quality: object.quality,
                    scale: object.scale,
                    totalResources: object.totalResources,
                    remainingResources: object.remainingResources
                }
            });
        } else {
            // Standard tree/rock removal
            this.networkManager.sendMessage('remove_object_request', {
                chunkId: `chunk_${object.chunkKey}`,
                objectId: object.id,
                name: object.name,
                position: object.position.toArray(),
                quality: object.quality,
                scale: object.scale
            });

            // Spawn log for trees - send request to server
            const treeTypes = ['oak', 'fir', 'pine', 'cypress'];
            if (treeTypes.includes(object.name)) {
                // Calculate log scale (1/3 of tree scale)
                const logScale = object.scale / 3;
                const logType = `${object.name}_log`; // e.g., "oak_log", "pine_log"
                const logId = `${logType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                // Calculate total resources based on original tree scale
                const totalResources = Math.floor(object.scale * 100);

                // Send add_object_request to server
                this.networkManager.sendMessage('add_object_request', {
                    chunkId: `chunk_${object.chunkKey}`,
                    objectId: logId,
                    objectType: logType, // e.g., "oak_log" instead of just "log"
                    objectPosition: object.position.toArray(),
                    objectQuality: object.quality,
                    objectScale: logScale,
                    totalResources: totalResources,
                    remainingResources: totalResources
                });
            }
        }

        // Clear active chopping action
        this.gameState.activeChoppingAction = null;
        ui.updateChoppingProgress(0);
    }

    async handleWebRTCOffer(payload) {
        if (payload.recipientId !== this.gameState.clientId) return;
        const peerId = payload.senderId;
        const connection = this.networkManager.createPeerConnection(peerId, false);
        try {
            await connection.setRemoteDescription(new RTCSessionDescription(payload.offer));
            const answer = await connection.createAnswer();
            await connection.setLocalDescription(answer);
            this.networkManager.sendMessage('webrtc_answer', {
                recipientId: peerId,
                senderId: this.gameState.clientId,
                answer
            });
        } catch (error) {
            ui.updateStatus(`❌ Failed to handle offer from ${peerId}: ${error}`);
        }
    }

    async handleWebRTCAnswer(payload) {
        if (payload.recipientId !== this.gameState.clientId) return;
        const peer = this.networkManager.peers.get(payload.senderId);
        if (peer?.connection) {
            try {
                await peer.connection.setRemoteDescription(new RTCSessionDescription(payload.answer));
            } catch (error) {
                ui.updateStatus(`❌ Failed to handle answer from ${payload.senderId}: ${error}`);
            }
        }
    }

    async handleWebRTCIceCandidate(payload) {
        if (payload.recipientId !== this.gameState.clientId) return;
        const peer = this.networkManager.peers.get(payload.senderId);
        if (peer?.connection) {
            try {
                await peer.connection.addIceCandidate(new RTCIceCandidate(payload.candidate));
            } catch (error) {
                ui.updateStatus(`❌ Failed to add ICE candidate from ${payload.senderId}: ${error}`);
            }
        }
    }

    staggerP2PInitiations(newPlayers) {
        newPlayers.forEach((player, index) => {
            setTimeout(() => {
                if (this.gameState.clientId < player.id) {
                    this.initiateP2PConnection(player.id);
                }

                // Create avatar from man model
                const avatar = this.createAvatar();
                if (avatar) {
                    this.scene.add(avatar);
                    this.networkManager.avatars.set(player.id, avatar);
                }
            }, index * 750);
        });
    }

    createAvatar() {
        const manGLTF = modelManager.getGLTF('man');
        if (!manGLTF) {
            console.error('Man model not loaded for avatar');
            return null;
        }

        // AVATAR CLONING FIX: Use SkeletonUtils.clone() instead of .clone(true)
        // Regular .clone() breaks skeleton binding for SkinnedMesh (animated characters)
        // SkeletonUtils preserves the bone-mesh binding needed for animations
        // If avatars are still invisible, revert to loading separate model instances
        const avatarMesh = SkeletonUtils.clone(manGLTF.scene);
        avatarMesh.scale.set(this.playerScale, this.playerScale, this.playerScale);

        // Setup materials (same as main player)
        avatarMesh.traverse((child) => {
            if (child.isMesh || child.isSkinnedMesh) {
                child.visible = true;
                child.frustumCulled = false;
                child.renderOrder = 1;

                if (child.material) {
                    child.material.depthWrite = true;
                    child.material.depthTest = true;
                    if (child.material.type === 'MeshStandardMaterial') {
                        child.material.needsUpdate = true;
                    }
                }
            }
        });

        // Create animation mixer for this avatar
        if (manGLTF.animations && manGLTF.animations.length > 0) {
            const mixer = new THREE.AnimationMixer(avatarMesh);
            const walkAnimation = manGLTF.animations.find(anim =>
                anim.name.toLowerCase().includes('walk')
            );

            if (walkAnimation) {
                const action = mixer.clipAction(walkAnimation);
                action.play();
                // Store mixer and action in userData
                avatarMesh.userData.mixer = mixer;
                avatarMesh.userData.action = action;
            }
        }

        // Store last position for rotation calculation
        avatarMesh.userData.lastPosition = new THREE.Vector3();
        avatarMesh.userData.isMoving = false;

        return avatarMesh;
    }

    // ==========================================
    // INVENTORY SYSTEM
    // ==========================================

    initializeInventory() {
        // Generate grid slots
        const grid = document.getElementById('inventoryGrid');
        for (let row = 0; row < this.gameState.inventory.rows; row++) {
            for (let col = 0; col < this.gameState.inventory.cols; col++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.row = row;
                slot.dataset.col = col;
                grid.appendChild(slot);
            }
        }

        // Add event listeners
        document.getElementById('inventoryCloseBtn').addEventListener('click', () => {
            this.toggleInventory();
        });

        // Clicking overlay background closes inventory
        const overlay = document.getElementById('inventoryOverlay');
        overlay.addEventListener('click', (event) => {
            // Only close if clicking the overlay itself, not its children
            if (event.target === overlay) {
                this.toggleInventory();
            }
        });

        // Prevent clicks on the panel from closing inventory
        const panel = document.querySelector('.inventory-panel');
        panel.addEventListener('click', (event) => {
            event.stopPropagation();
        });

        // Discard modal event listeners
        document.getElementById('discardCancel').addEventListener('click', () => {
            const modal = document.getElementById('discardModal');
            modal.style.display = 'none';
        });

        document.getElementById('discardConfirm').addEventListener('click', () => {
            const modal = document.getElementById('discardModal');
            const itemId = modal.dataset.itemId;

            // Find and remove the item from inventory
            const itemIndex = this.gameState.inventory.items.findIndex(item => item.id === itemId);
            if (itemIndex !== -1) {
                this.gameState.inventory.items.splice(itemIndex, 1);
            }

            // Hide modal and re-render inventory
            modal.style.display = 'none';
            this.renderInventory();

            // Re-check proximity to update button states (in case they discarded a required tool)
            this.checkProximityToObjects();
        });

        // Render initial items
        this.renderInventory();
    }

    calculateInventorySize() {
        // Calculate slot size to fit 60-70% of screen height for 10 rows
        const targetHeight = window.innerHeight * 0.65;
        const slotSize = Math.floor(targetHeight / this.gameState.inventory.rows);
        const gap = Math.max(1, Math.floor(slotSize / 30)); // Gap scales with slot size

        this.gameState.inventory.slotSize = slotSize;
        this.gameState.inventory.gap = gap;
    }

    toggleInventory() {
        // Close build menu if open
        if (this.gameState.buildMenuOpen) {
            this.toggleBuildMenu();
        }

        this.gameState.inventoryOpen = !this.gameState.inventoryOpen;
        const overlay = document.getElementById('inventoryOverlay');

        if (this.gameState.inventoryOpen) {
            this.calculateInventorySize(); // Recalculate on open
            overlay.style.display = 'flex';
            this.renderInventory();
            this.updateConstructionSection(); // Show/hide construction section based on proximity
            this.updateCrateSection(); // Show/hide crate section based on proximity
        } else {
            overlay.style.display = 'none';

            // Save crate inventory if dirty (modified)
            if (this.gameState.nearestCrate && this.crateInventory) {
                const crate = this.gameState.nearestCrate;
                if (crate.userData.inventoryDirty) {
                    // Save inventory to server
                    this.networkManager.sendMessage('save_crate_inventory', {
                        crateId: crate.userData.objectId,
                        chunkId: `chunk_${crate.userData.chunkKey}`,
                        inventory: this.crateInventory
                    });
                    console.log(`Saving crate inventory for ${crate.userData.objectId}`);
                    crate.userData.inventoryDirty = false;
                }
            }

            // Cancel any picked up item
            if (this.inventoryPickedItem) {
                this.cancelPickup();
            }
            // Re-check proximity when closing inventory (in case items changed)
            this.checkProximityToObjects();
        }
    }

    tryAddItemToInventory(item) {
        // Try to find empty space in the inventory grid (10 rows x 5 cols)
        const { rows, cols, items } = this.gameState.inventory;

        // Try each position in the grid
        for (let y = 0; y <= rows - item.height; y++) {
            for (let x = 0; x <= cols - item.width; x++) {
                // Check if this position is free
                if (this.isPositionFree(x, y, item.width, item.height, items)) {
                    // Found a free position!
                    item.x = x;
                    item.y = y;
                    items.push(item);
                    return true;
                }
            }
        }

        // No space found
        return false;
    }

    isPositionFree(x, y, width, height, existingItems) {
        // Check if the rectangle from (x,y) to (x+width-1, y+height-1) overlaps with any existing items
        for (const item of existingItems) {
            // Get item dimensions (account for rotation)
            const itemWidth = item.rotation === 90 ? item.height : item.width;
            const itemHeight = item.rotation === 90 ? item.width : item.height;

            // Check if rectangles overlap
            const xOverlap = x < item.x + itemWidth && x + width > item.x;
            const yOverlap = y < item.y + itemHeight && y + height > item.y;

            if (xOverlap && yOverlap) {
                return false; // Overlaps with this item
            }
        }

        return true; // No overlaps
    }

    renderInventory() {
        const itemsContainer = document.getElementById('inventoryItems');
        const inventoryGrid = document.getElementById('inventoryGrid');
        itemsContainer.innerHTML = ''; // Clear existing

        // Update grid styling dynamically
        const { slotSize, gap, rows, cols } = this.gameState.inventory;
        inventoryGrid.style.gridTemplateColumns = `repeat(${cols}, ${slotSize}px)`;
        inventoryGrid.style.gridTemplateRows = `repeat(${rows}, ${slotSize}px)`;
        inventoryGrid.style.gap = `${gap}px`;

        // Update slot styling
        const slots = inventoryGrid.querySelectorAll('.inventory-slot');
        slots.forEach(slot => {
            slot.style.width = `${slotSize}px`;
            slot.style.height = `${slotSize}px`;
        });

        this.gameState.inventory.items.forEach(item => {
            // Skip rendering picked item in its grid position - will render as ghost
            if (this.inventoryPickedItem && item.id === this.inventoryPickedItem.id) {
                return;
            }

            // Create container wrapper for image + discard button
            const itemWrapper = document.createElement('div');
            itemWrapper.className = 'inventory-item-wrapper';

            // Add chisel-target class if this is the target stone
            if (this.chiselTarget && item.id === this.chiselTarget.id) {
                itemWrapper.classList.add('chisel-target');
            }

            itemWrapper.dataset.itemId = item.id;
            itemWrapper.style.position = 'absolute';

            // Calculate pixel position (upper-left anchor)
            const pixelPos = this.gridToPixel(item.x, item.y);
            itemWrapper.style.left = pixelPos.x + 'px';
            itemWrapper.style.top = pixelPos.y + 'px';

            // Create image element
            const itemEl = document.createElement('img');

            // Use rotated image file when rotation is 90
            if (item.rotation === 90) {
                itemEl.src = `./items/R${item.type}.png`;
            } else {
                itemEl.src = `./items/${item.type}.png`;
            }

            itemEl.className = 'inventory-item';
            itemEl.style.position = 'relative';

            // Calculate size based on slots (swap dimensions when rotated)
            const slotSize = this.gameState.inventory.slotSize;
            const gap = this.gameState.inventory.gap;

            const displayWidth = item.rotation === 90 ? item.height : item.width;
            const displayHeight = item.rotation === 90 ? item.width : item.height;

            const widthPx = displayWidth * slotSize + (displayWidth - 1) * gap;
            const heightPx = displayHeight * slotSize + (displayHeight - 1) * gap;

            itemEl.style.width = widthPx + 'px';
            itemEl.style.height = heightPx + 'px';
            itemWrapper.style.width = widthPx + 'px';
            itemWrapper.style.height = heightPx + 'px';

            // No transform needed - using pre-rotated image

            // Create discard button (X in upper right)
            const discardBtn = document.createElement('div');
            discardBtn.className = 'item-discard-btn';
            discardBtn.textContent = '✕';
            discardBtn.dataset.itemId = item.id;

            // Scale discard button with slot size
            const btnSize = Math.max(16, Math.floor(slotSize / 3)); // Min 16px, scales with slot
            const btnOffset = Math.max(2, Math.floor(slotSize / 30)); // Offset from corner
            discardBtn.style.width = btnSize + 'px';
            discardBtn.style.height = btnSize + 'px';
            discardBtn.style.fontSize = Math.max(12, Math.floor(btnSize * 0.7)) + 'px';
            discardBtn.style.top = btnOffset + 'px';
            discardBtn.style.right = btnOffset + 'px';

            // Add discard button event listeners
            discardBtn.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                this.showDiscardTooltip(e);
            });
            discardBtn.addEventListener('mousemove', (e) => {
                e.stopPropagation();
                this.updateTooltipPosition(e);
            });
            discardBtn.addEventListener('mouseleave', (e) => {
                e.stopPropagation();
                this.hideDiscardTooltip();
            });
            discardBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                this.showDiscardConfirmation(item);
            });

            // Prevent dragging when clicking discard button
            discardBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });

            // Add drag event listener to wrapper
            itemWrapper.addEventListener('mousedown', (e) => this.onItemMouseDown(e, item, itemWrapper));

            // Add hover event listeners for tooltip to wrapper
            itemWrapper.addEventListener('mouseenter', (e) => this.showTooltip(e, item));
            itemWrapper.addEventListener('mousemove', (e) => this.updateTooltipPosition(e));
            itemWrapper.addEventListener('mouseleave', () => this.hideTooltip());

            // Assemble: image and discard button into wrapper
            itemWrapper.appendChild(itemEl);
            itemWrapper.appendChild(discardBtn);

            itemsContainer.appendChild(itemWrapper);
        });

        // Render picked item as ghost following cursor (only if targeting backpack)
        if (this.inventoryPickedItem && this.inventoryPickedTarget === 'backpack') {
            const item = this.inventoryPickedItem;

            // Calculate grid position that item would snap to
            const gridPos = this.pixelToGrid(this.inventoryMouseX, this.inventoryMouseY);
            const snappedPixelPos = this.gridToPixel(gridPos.x, gridPos.y);

            // Create ghost wrapper
            const ghostWrapper = document.createElement('div');
            ghostWrapper.className = 'inventory-item-wrapper dragging';
            ghostWrapper.dataset.itemId = item.id;
            ghostWrapper.style.position = 'absolute';
            // Use snapped position instead of raw mouse position
            ghostWrapper.style.left = snappedPixelPos.x + 'px';
            ghostWrapper.style.top = snappedPixelPos.y + 'px';
            ghostWrapper.style.opacity = '0.7';
            ghostWrapper.style.pointerEvents = 'none'; // Don't intercept mouse events
            ghostWrapper.style.zIndex = '2000'; // Above all panels

            // Create ghost image
            const ghostImg = document.createElement('img');
            ghostImg.src = item.rotation === 90 ? `./items/R${item.type}.png` : `./items/${item.type}.png`;
            ghostImg.className = 'inventory-item';
            ghostImg.style.position = 'relative';

            // Calculate size
            const displayWidth = item.rotation === 90 ? item.height : item.width;
            const displayHeight = item.rotation === 90 ? item.width : item.height;
            const widthPx = displayWidth * slotSize + (displayWidth - 1) * gap;
            const heightPx = displayHeight * slotSize + (displayHeight - 1) * gap;

            ghostImg.style.width = widthPx + 'px';
            ghostImg.style.height = heightPx + 'px';
            ghostWrapper.style.width = widthPx + 'px';
            ghostWrapper.style.height = heightPx + 'px';

            // Check placement validity and add visual feedback
            const isValid = this.isValidPlacement(item, gridPos.x, gridPos.y, item.rotation);
            if (!isValid) {
                ghostWrapper.classList.add('invalid-placement');
            }

            ghostWrapper.appendChild(ghostImg);
            itemsContainer.appendChild(ghostWrapper);
        }
    }

    getStatColor(value) {
        if (value >= 80) return 'stat-good';
        if (value >= 40) return 'stat-worn';
        return 'stat-poor';
    }

    showTooltip(event, item) {
        // Don't show tooltip while holding an item
        if (this.inventoryPickedItem) return;

        const tooltip = document.getElementById('inventoryTooltip');
        const titleEl = tooltip.querySelector('.tooltip-title');
        const qualityEl = tooltip.querySelector('.tooltip-quality');
        const durabilityEl = tooltip.querySelector('.tooltip-durability');
        const durabilityRow = durabilityEl.closest('.tooltip-stat');

        // Set content
        titleEl.textContent = item.type;
        qualityEl.textContent = `${item.quality}/100`;

        // Apply color coding for quality
        qualityEl.className = `tooltip-quality ${this.getStatColor(item.quality)}`;

        // Only show durability for items that have it (tools)
        if (item.durability !== undefined) {
            durabilityEl.textContent = `${item.durability}/100`;
            durabilityEl.className = `tooltip-durability ${this.getStatColor(item.durability)}`;
            durabilityRow.style.display = '';
        } else {
            // Hide durability row for materials
            durabilityRow.style.display = 'none';
        }

        // Position and show tooltip
        this.updateTooltipPosition(event);
        tooltip.style.display = 'block';
    }

    updateTooltipPosition(event) {
        const tooltip = document.getElementById('inventoryTooltip');
        // Position tooltip slightly offset from cursor
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 15) + 'px';
    }

    hideTooltip() {
        const tooltip = document.getElementById('inventoryTooltip');
        tooltip.style.display = 'none';
    }

    showDiscardTooltip(event) {
        // Don't show tooltip while holding an item
        if (this.inventoryPickedItem) return;

        const tooltip = document.getElementById('inventoryTooltip');
        const titleEl = tooltip.querySelector('.tooltip-title');

        // Hide stat rows, only show "Discard"
        tooltip.querySelectorAll('.tooltip-stat').forEach(stat => {
            stat.style.display = 'none';
        });

        // Set content
        titleEl.textContent = 'Discard';
        titleEl.style.color = '#ff6b6b'; // Red color for discard action

        // Position and show tooltip
        this.updateTooltipPosition(event);
        tooltip.style.display = 'block';
    }

    hideDiscardTooltip() {
        const tooltip = document.getElementById('inventoryTooltip');
        tooltip.style.display = 'none';

        // Reset tooltip styles
        tooltip.querySelectorAll('.tooltip-stat').forEach(stat => {
            stat.style.display = '';
        });
        const titleEl = tooltip.querySelector('.tooltip-title');
        titleEl.style.color = '';
    }

    showDiscardConfirmation(item) {
        const modal = document.getElementById('discardModal');
        const message = document.getElementById('discardMessage');

        // Set message with item name
        message.textContent = `Are you sure you want to trash ${item.type}?`;

        // Store item reference for confirmation
        modal.dataset.itemId = item.id;

        // Show modal
        modal.style.display = 'flex';
    }

    gridToPixel(gridX, gridY) {
        const slotSize = this.gameState.inventory.slotSize;
        const gap = this.gameState.inventory.gap;
        return {
            x: gridX * (slotSize + gap),
            y: gridY * (slotSize + gap)
        };
    }

    pixelToGrid(pixelX, pixelY) {
        const slotSize = this.gameState.inventory.slotSize;
        const gap = this.gameState.inventory.gap;

        // Calculate grid position - floor to snap to the slot the cursor is in
        const x = Math.floor(pixelX / (slotSize + gap));
        const y = Math.floor(pixelY / (slotSize + gap));

        return { x, y };
    }

    getOccupiedSlots(item, x, y, rotation) {
        const slots = [];
        const width = rotation === 90 ? item.height : item.width;
        const height = rotation === 90 ? item.width : item.height;

        for (let row = y; row < y + height; row++) {
            for (let col = x; col < x + width; col++) {
                slots.push({ x: col, y: row });
            }
        }
        return slots;
    }

    isValidPlacement(item, x, y, rotation) {
        const width = rotation === 90 ? item.height : item.width;
        const height = rotation === 90 ? item.width : item.height;

        // Bounds check
        if (x < 0 || y < 0) return false;
        if (x + width > this.gameState.inventory.cols) return false;
        if (y + height > this.gameState.inventory.rows) return false;

        // Collision check with other items
        const occupiedSlots = this.getOccupiedSlots(item, x, y, rotation);

        for (const otherItem of this.gameState.inventory.items) {
            // Skip checking against itself
            if (otherItem.id === item.id) continue;

            const otherSlots = this.getOccupiedSlots(
                otherItem,
                otherItem.x,
                otherItem.y,
                otherItem.rotation
            );

            // Check for overlap
            for (const slot of occupiedSlots) {
                for (const otherSlot of otherSlots) {
                    if (slot.x === otherSlot.x && slot.y === otherSlot.y) {
                        return false; // Overlap detected
                    }
                }
            }
        }

        return true;
    }

    getItemUnderCursor(cursorX, cursorY, draggingItem) {
        // Check if cursor is over a chiseable stone item
        const chiseableStones = ['limestone', 'sandstone', 'Rlimestone', 'Rsandstone'];

        for (const invItem of this.gameState.inventory.items) {
            if (invItem.id === draggingItem.id) continue; // Skip the item being dragged
            if (!chiseableStones.includes(invItem.type)) continue; // Only check stone items

            // Calculate item's pixel position and size using dynamic values
            const slotSize = this.gameState.inventory.slotSize;
            const gap = this.gameState.inventory.gap;
            const displayWidth = invItem.rotation === 90 ? invItem.height : invItem.width;
            const displayHeight = invItem.rotation === 90 ? invItem.width : invItem.height;
            const itemPixelX = invItem.x * (slotSize + gap);
            const itemPixelY = invItem.y * (slotSize + gap);
            const itemPixelWidth = displayWidth * slotSize + (displayWidth - 1) * gap;
            const itemPixelHeight = displayHeight * slotSize + (displayHeight - 1) * gap;

            // Check if cursor is over this item
            if (cursorX >= itemPixelX && cursorX <= itemPixelX + itemPixelWidth &&
                cursorY >= itemPixelY && cursorY <= itemPixelY + itemPixelHeight) {
                return invItem;
            }
        }
        return null;
    }

    onItemMouseDown(event, item, itemWrapper) {
        event.preventDefault();
        event.stopPropagation();

        // Ignore clicks on items when already holding an item
        // (this prevents picking up a new item when trying to place on an invalid location)
        if (this.inventoryPickedItem) {
            return;
        }

        // Hide tooltip when clicking item
        this.hideTooltip();

        // Pick up the item (click-to-pickup)
        this.inventoryPickedItem = item;
        this.inventoryPickedSource = 'backpack'; // Track source
        this.inventoryPickedTarget = 'backpack'; // Default target is backpack
        this.inventoryPickedOriginalX = item.x;
        this.inventoryPickedOriginalY = item.y;
        this.inventoryPickedOriginalRotation = item.rotation;

        // Store mouse position
        const itemsContainer = document.getElementById('inventoryItems');
        const containerRect = itemsContainer.getBoundingClientRect();
        this.inventoryMouseX = event.clientX - containerRect.left;
        this.inventoryMouseY = event.clientY - containerRect.top;

        // Set flag to ignore the mouseup from this click
        this.inventoryIgnoreNextMouseUp = true;

        // Add global event listeners
        // Use unified handlers if crate is nearby, otherwise use backpack-only handlers
        if (this.gameState.nearestCrate) {
            this.mouseMoveHandler = (e) => this.onCrateMouseMove(e);
            this.mouseUpHandler = (e) => this.onCrateMouseUp(e);
        } else {
            this.mouseMoveHandler = (e) => this.onMouseMove(e);
            this.mouseUpHandler = (e) => this.onMouseUp(e);
        }
        this.keyDownHandler = (e) => this.onInventoryKeyDown(e);

        window.addEventListener('mousemove', this.mouseMoveHandler);
        window.addEventListener('mouseup', this.mouseUpHandler);
        window.addEventListener('keydown', this.keyDownHandler);

        // Re-render to show item following cursor
        this.renderInventory();
        if (this.gameState.nearestCrate) {
            this.renderCrateInventory();
        }
    }

    onMouseMove(event) {
        if (!this.inventoryPickedItem) return;

        const item = this.inventoryPickedItem;
        const itemsContainer = document.getElementById('inventoryItems');
        const containerRect = itemsContainer.getBoundingClientRect();

        // Update mouse position
        this.inventoryMouseX = event.clientX - containerRect.left;
        this.inventoryMouseY = event.clientY - containerRect.top;

        // Check if holding a chisel over a stone item
        if (item.type === 'chisel') {
            try {
                const targetStone = this.getItemUnderCursor(this.inventoryMouseX, this.inventoryMouseY, item);

                // Update chisel target if changed
                if (this.chiselTarget !== targetStone) {
                    this.chiselTarget = targetStone;
                }
            } catch (error) {
                console.error('Error checking chisel target:', error);
                this.chiselTarget = null;
            }
        } else {
            // Clear chisel target for non-chisel items
            this.chiselTarget = null;
        }

        // Re-render to update ghost position and visual feedback
        this.renderInventory();
    }

    onMouseUp(event) {
        if (!this.inventoryPickedItem) return;

        // Ignore the mouseup from the pickup click
        if (this.inventoryIgnoreNextMouseUp) {
            this.inventoryIgnoreNextMouseUp = false;
            return;
        }

        const item = this.inventoryPickedItem;

        try {
            // Check if chisel was released over a stone
            if (item.type === 'chisel' && this.chiselTarget) {
                const targetStone = this.chiselTarget;

                // Clear chisel target
                this.chiselTarget = null;

                // Start chiseling action
                this.startChiselingAction(item, targetStone);

                // Clear picked item state and reset flag
                this.inventoryPickedItem = null;
                this.inventoryIgnoreNextMouseUp = false;

                // Remove global event listeners
                window.removeEventListener('mousemove', this.mouseMoveHandler);
                window.removeEventListener('mouseup', this.mouseUpHandler);
                window.removeEventListener('keydown', this.keyDownHandler);

                // Re-render to snap chisel back to original position
                this.renderInventory();
                return;
            }

            // Clear any chisel target
            this.chiselTarget = null;

            // Check if dropping onto construction section (now integrated into backpack)
            if (this.gameState.nearestConstructionSite && !this.gameState.isMoving) {
                const constructionSection = document.getElementById('constructionSection');
                if (constructionSection && constructionSection.style.display !== 'none') {
                    const rect = constructionSection.getBoundingClientRect();

                    // Check if mouse is over construction section
                    if (event.clientX >= rect.left && event.clientX <= rect.right &&
                        event.clientY >= rect.top && event.clientY <= rect.bottom) {

                        const requiredMaterials = this.gameState.nearestConstructionSite.userData.requiredMaterials || {};
                        const currentMaterials = this.gameState.nearestConstructionSite.userData.materials || {};

                        // Check if this item type is needed (item.type should match directly, e.g., 'chiseledlimestone')
                        const itemType = item.type;

                        if (requiredMaterials[itemType]) {
                            const required = requiredMaterials[itemType];
                            const current = currentMaterials[itemType] || 0;

                            if (current < required) {
                                // Add material to construction
                                currentMaterials[itemType] = current + 1;
                                this.gameState.nearestConstructionSite.userData.materials = currentMaterials;

                                // Remove item from inventory
                                const itemIndex = this.gameState.inventory.items.indexOf(item);
                                if (itemIndex > -1) {
                                    this.gameState.inventory.items.splice(itemIndex, 1);
                                }

                                console.log(`Added ${itemType} to construction (${current + 1}/${required})`);

                                // Clear picked item state
                                this.inventoryPickedItem = null;
                                this.inventoryIgnoreNextMouseUp = false;

                                // Remove global event listeners
                                window.removeEventListener('mousemove', this.mouseMoveHandler);
                                window.removeEventListener('mouseup', this.mouseUpHandler);
                                window.removeEventListener('keydown', this.keyDownHandler);

                                // Re-render inventory (includes construction section and crate section)
                                this.renderInventory();
                                this.updateConstructionSection();
                                this.updateCrateSection();
                                return;
                            }
                        }
                    }
                }
            }

            // Normal item placement
            // Calculate final grid position
            const gridPos = this.pixelToGrid(this.inventoryMouseX, this.inventoryMouseY);

            // Check if placement is valid
            if (this.isValidPlacement(item, gridPos.x, gridPos.y, item.rotation)) {
                // Valid placement - update item position
                item.x = gridPos.x;
                item.y = gridPos.y;
            } else {
                // Invalid placement - restore original position
                item.x = this.inventoryPickedOriginalX;
                item.y = this.inventoryPickedOriginalY;
                item.rotation = this.inventoryPickedOriginalRotation;
            }

            // Clear picked item state and reset flag
            this.inventoryPickedItem = null;
            this.inventoryIgnoreNextMouseUp = false;

            // Remove global event listeners
            window.removeEventListener('mousemove', this.mouseMoveHandler);
            window.removeEventListener('mouseup', this.mouseUpHandler);
            window.removeEventListener('keydown', this.keyDownHandler);

            // Re-render to place item
            this.renderInventory();
        } catch (error) {
            console.error('Error placing item:', error);
            // On error, restore original position and clean up state
            if (this.inventoryPickedItem) {
                this.inventoryPickedItem.x = this.inventoryPickedOriginalX;
                this.inventoryPickedItem.y = this.inventoryPickedOriginalY;
                this.inventoryPickedItem.rotation = this.inventoryPickedOriginalRotation;
            }
            this.inventoryPickedItem = null;
            this.inventoryIgnoreNextMouseUp = false;
            this.chiselTarget = null;
            window.removeEventListener('mousemove', this.mouseMoveHandler);
            window.removeEventListener('mouseup', this.mouseUpHandler);
            window.removeEventListener('keydown', this.keyDownHandler);
            this.renderInventory();
        }
    }

    onInventoryKeyDown(event) {
        if (!this.inventoryPickedItem) return;

        if (event.key === 'r' || event.key === 'R') {
            event.preventDefault();

            const item = this.inventoryPickedItem;

            // Toggle rotation
            item.rotation = item.rotation === 0 ? 90 : 0;

            // Re-render to update ghost with new rotation
            this.renderInventory();
            // Also re-render crate if nearby (for crate mode)
            if (this.gameState.nearestCrate) {
                this.renderCrateInventory();
            }
        }
    }

    // ==========================================
    // BUILD MENU SYSTEM
    // ==========================================

    initializeBuildMenu() {
        // Generate grid slots
        const grid = document.getElementById('buildMenuGrid');
        for (let row = 0; row < this.gameState.buildMenu.rows; row++) {
            for (let col = 0; col < this.gameState.buildMenu.cols; col++) {
                const slot = document.createElement('div');
                slot.className = 'build-menu-slot';
                slot.dataset.row = row;
                slot.dataset.col = col;
                grid.appendChild(slot);
            }
        }

        // Add close button event listener
        document.getElementById('buildMenuCloseBtn').addEventListener('click', () => {
            this.toggleBuildMenu();
        });

        // Render initial structures
        this.renderBuildMenu();
    }

    calculateBuildMenuSize() {
        // Calculate slot size to fit 60-70% of screen height for 10 rows
        const targetHeight = window.innerHeight * 0.65;
        const slotSize = Math.floor(targetHeight / this.gameState.buildMenu.rows);
        const gap = Math.max(1, Math.floor(slotSize / 30)); // Gap scales with slot size

        this.gameState.buildMenu.slotSize = slotSize;
        this.gameState.buildMenu.gap = gap;
    }

    toggleBuildMenu() {
        // Close inventory if open (only one menu at a time)
        if (this.gameState.inventoryOpen) {
            this.toggleInventory();
        }

        this.gameState.buildMenuOpen = !this.gameState.buildMenuOpen;
        const overlay = document.getElementById('buildMenuOverlay');

        if (this.gameState.buildMenuOpen) {
            this.calculateBuildMenuSize(); // Recalculate on open
            overlay.style.display = 'flex';
            this.renderBuildMenu();
        } else {
            overlay.style.display = 'none';
        }
    }

    toggleConstructionInventory() {
        // Deprecated: Now just opens backpack which contains construction section
        this.toggleInventory();
    }

    updateConstructionSection() {
        // Show/hide construction section based on proximity to construction site AND not moving
        const constructionSection = document.getElementById('constructionSection');
        if (!constructionSection) return;

        const shouldShow = this.gameState.nearestConstructionSite && !this.gameState.isMoving && this.gameState.inventoryOpen;

        if (shouldShow) {
            constructionSection.style.display = 'block';
            this.renderConstructionInventory();
        } else {
            constructionSection.style.display = 'none';
        }
    }

    renderConstructionInventory() {
        if (!this.gameState.nearestConstructionSite) return;

        const constructionSite = this.gameState.nearestConstructionSite;
        const requiredMaterials = constructionSite.userData.requiredMaterials || {};
        const currentMaterials = constructionSite.userData.materials || {};

        // Update building type display
        const buildingTypeEl = document.getElementById('constructionBuildingType');
        if (buildingTypeEl) {
            const targetStructure = constructionSite.userData.targetStructure || 'Unknown';
            buildingTypeEl.textContent = targetStructure.charAt(0).toUpperCase() + targetStructure.slice(1);
        }

        // Update requirements display
        const requirementsEl = document.getElementById('constructionRequirements');
        requirementsEl.innerHTML = '';
        for (const [material, quantity] of Object.entries(requiredMaterials)) {
            const current = currentMaterials[material] || 0;
            const materialName = material.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            const div = document.createElement('div');
            div.textContent = `${materialName}: ${current}/${quantity}`;
            div.style.color = current >= quantity ? '#4CAF50' : '#ff9800';
            requirementsEl.appendChild(div);
        }

        // Render material slots
        const slotsContainer = document.getElementById('constructionSlots');
        slotsContainer.innerHTML = '';
        for (const [material, quantity] of Object.entries(requiredMaterials)) {
            const current = currentMaterials[material] || 0;
            const materialName = material.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());

            for (let i = 0; i < quantity; i++) {
                const slot = document.createElement('div');
                slot.className = 'construction-slot';
                slot.dataset.material = material;
                slot.dataset.slotIndex = i;

                if (i < current) {
                    slot.classList.add('filled');
                    slot.textContent = '✓';
                    slot.style.fontSize = '24px';
                    slot.style.color = '#4CAF50';
                }

                const label = document.createElement('div');
                label.className = 'construction-slot-label';
                label.textContent = materialName;
                slot.appendChild(label);

                slotsContainer.appendChild(slot);
            }
        }

        // Check if all materials are satisfied
        const allMaterialsSatisfied = Object.entries(requiredMaterials).every(
            ([material, quantity]) => (currentMaterials[material] || 0) >= quantity
        );

        // Enable/disable build button
        const buildBtn = document.getElementById('constructionBuildBtn');
        buildBtn.disabled = !allMaterialsSatisfied;
    }

    updateCrateSection() {
        // Show/hide crate section based on proximity to crate AND not moving
        const crateSection = document.getElementById('crateSection');
        if (!crateSection) return;

        const shouldShow = this.gameState.nearestCrate && !this.gameState.isMoving && this.gameState.inventoryOpen;

        if (shouldShow) {
            crateSection.style.display = 'block';

            // Request crate inventory from server if not already loaded
            const crate = this.gameState.nearestCrate;
            if (!crate.userData.inventory) {
                // Request inventory from server
                this.networkManager.sendMessage('get_crate_inventory', {
                    crateId: crate.userData.objectId,
                    chunkId: `chunk_${crate.userData.chunkKey}`
                });
                console.log(`Requesting inventory for crate ${crate.userData.objectId}`);
            } else {
                // Inventory already loaded, just render it
                this.renderCrateInventory();
            }
        } else {
            crateSection.style.display = 'none';
        }
    }

    renderCrateInventory() {
        if (!this.gameState.nearestCrate) return;

        const crate = this.gameState.nearestCrate;
        const crateInventory = crate.userData.inventory || { items: [] };

        // Render grid slots
        const crateGrid = document.getElementById('crateGrid');
        if (!crateGrid) return;

        // Use same slot size and gap as backpack inventory
        const { slotSize, gap } = this.gameState.inventory;

        // Update grid styling dynamically (same as backpack)
        crateGrid.style.gridTemplateColumns = `repeat(10, ${slotSize}px)`;
        crateGrid.style.gridTemplateRows = `repeat(10, ${slotSize}px)`;
        crateGrid.style.gap = `${gap}px`;
        crateGrid.style.maxHeight = `${slotSize * 10 + gap * 9 + 4}px`; // 10 rows + gaps + padding

        // Clear existing slots
        crateGrid.innerHTML = '';

        // Create 10x10 grid slots (100 total)
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                const slot = document.createElement('div');
                slot.className = 'crate-slot';
                slot.dataset.row = row;
                slot.dataset.col = col;
                slot.style.width = `${slotSize}px`;
                slot.style.height = `${slotSize}px`;
                crateGrid.appendChild(slot);
            }
        }

        // Render items
        const crateItems = document.getElementById('crateItems');
        if (!crateItems) return;

        crateItems.innerHTML = '';

        // Store reference to crate inventory for later use
        this.crateInventory = crateInventory;

        // Render each item
        for (const item of crateInventory.items) {
            this.renderCrateItem(item, crateItems);
        }

        // Render picked item as ghost following cursor (if target is crate)
        if (this.inventoryPickedItem && this.inventoryPickedTarget === 'crate') {
            const item = this.inventoryPickedItem;

            // Calculate grid position that item would snap to
            const gridPos = this.pixelToCrateGrid(this.inventoryMouseX, this.inventoryMouseY);
            const snappedX = gridPos.x * (slotSize + gap);
            const snappedY = gridPos.y * (slotSize + gap);

            // Create ghost wrapper
            const ghostWrapper = document.createElement('div');
            ghostWrapper.className = 'crate-item-wrapper dragging';
            ghostWrapper.dataset.itemId = item.id;
            ghostWrapper.style.position = 'absolute';
            ghostWrapper.style.left = snappedX + 'px';
            ghostWrapper.style.top = snappedY + 'px';
            ghostWrapper.style.opacity = '0.7';
            ghostWrapper.style.pointerEvents = 'none';
            ghostWrapper.style.zIndex = '2000';

            // Create ghost image
            const ghostImg = document.createElement('img');
            ghostImg.src = item.rotation === 90 ? `./items/R${item.type}.png` : `./items/${item.type}.png`;
            ghostImg.className = 'crate-item';
            ghostImg.style.position = 'relative';

            // Calculate size
            const displayWidth = item.rotation === 90 ? item.height : item.width;
            const displayHeight = item.rotation === 90 ? item.width : item.height;
            const widthPx = displayWidth * slotSize + (displayWidth - 1) * gap;
            const heightPx = displayHeight * slotSize + (displayHeight - 1) * gap;

            ghostImg.style.width = widthPx + 'px';
            ghostImg.style.height = heightPx + 'px';
            ghostWrapper.style.width = widthPx + 'px';
            ghostWrapper.style.height = heightPx + 'px';

            // Check placement validity and add visual feedback
            const isValid = this.isValidCratePlacement(item, gridPos.x, gridPos.y, item.rotation);
            if (!isValid) {
                ghostWrapper.style.outline = '3px solid #ff0000';
                ghostWrapper.style.outlineOffset = '-3px';
            }

            ghostWrapper.appendChild(ghostImg);
            crateItems.appendChild(ghostWrapper);
        }
    }

    renderCrateItem(item, container) {
        // Skip rendering picked item in its grid position - will render as ghost
        if (this.inventoryPickedItem && item.id === this.inventoryPickedItem.id) {
            return;
        }

        const itemWrapper = document.createElement('div');
        itemWrapper.className = 'crate-item-wrapper';
        itemWrapper.dataset.itemId = item.id || `${item.type}_${Math.random()}`;
        itemWrapper.style.position = 'absolute';

        // Use same slot size and gap as backpack inventory
        const slotSize = this.gameState.inventory.slotSize;
        const gap = this.gameState.inventory.gap;

        // Set position and size based on item grid position (same calculation as backpack)
        itemWrapper.style.left = `${item.x * (slotSize + gap)}px`;
        itemWrapper.style.top = `${item.y * (slotSize + gap)}px`;

        // Create image element
        const itemEl = document.createElement('img');
        if (item.rotation === 90) {
            itemEl.src = `./items/R${item.type}.png`;
        } else {
            itemEl.src = `./items/${item.type}.png`;
        }
        itemEl.className = 'crate-item';
        itemEl.style.position = 'relative';

        // Calculate size based on slots (swap dimensions when rotated)
        const displayWidth = item.rotation === 90 ? item.height : item.width;
        const displayHeight = item.rotation === 90 ? item.width : item.height;
        const widthPx = displayWidth * slotSize + (displayWidth - 1) * gap;
        const heightPx = displayHeight * slotSize + (displayHeight - 1) * gap;

        itemEl.style.width = widthPx + 'px';
        itemEl.style.height = heightPx + 'px';
        itemWrapper.style.width = widthPx + 'px';
        itemWrapper.style.height = heightPx + 'px';

        // Add drag event listener to wrapper
        itemWrapper.addEventListener('mousedown', (e) => this.onCrateItemMouseDown(e, item, itemWrapper));

        // Add hover event listeners for tooltip
        itemWrapper.addEventListener('mouseenter', (e) => this.showTooltip(e, item));
        itemWrapper.addEventListener('mousemove', (e) => this.updateTooltipPosition(e));
        itemWrapper.addEventListener('mouseleave', () => this.hideTooltip());

        itemWrapper.appendChild(itemEl);
        container.appendChild(itemWrapper);
    }

    onCrateItemMouseDown(event, item, itemWrapper) {
        // Same logic as onItemMouseDown but mark as coming from crate
        event.stopPropagation();
        event.preventDefault();

        // Store picked item info
        this.inventoryPickedItem = item;
        this.inventoryPickedSource = 'crate'; // Track source
        this.inventoryPickedTarget = 'crate'; // Default target is crate
        this.inventoryPickedOriginalX = item.x;
        this.inventoryPickedOriginalY = item.y;
        this.inventoryPickedOriginalRotation = item.rotation;
        this.inventoryIgnoreNextMouseUp = true; // Ignore mouseup from this click

        // Calculate relative mouse offset within the item (for visual purposes)
        const rect = itemWrapper.getBoundingClientRect();
        const crateItems = document.getElementById('crateItems');
        const crateRect = crateItems.getBoundingClientRect();

        // Store mouse position relative to crate grid
        this.inventoryMouseX = event.clientX - crateRect.left;
        this.inventoryMouseY = event.clientY - crateRect.top;

        // Add event listeners
        this.mouseMoveHandler = (e) => this.onCrateMouseMove(e);
        this.mouseUpHandler = (e) => this.onCrateMouseUp(e);
        this.keyDownHandler = (e) => this.onInventoryKeyDown(e);

        window.addEventListener('mousemove', this.mouseMoveHandler);
        window.addEventListener('mouseup', this.mouseUpHandler);
        window.addEventListener('keydown', this.keyDownHandler);

        // Re-render both inventories to show item following cursor
        this.renderInventory();
        this.renderCrateInventory();
    }

    onCrateMouseMove(event) {
        if (!this.inventoryPickedItem) return;

        const item = this.inventoryPickedItem;

        // Get grid containers (not items layers) for proper bounds checking
        const backpackGrid = document.getElementById('inventoryGrid');
        const backpackRect = backpackGrid.getBoundingClientRect();

        const crateSection = document.getElementById('crateSection');
        const crateVisible = crateSection && crateSection.style.display !== 'none';
        let crateRect = null;
        let crateGrid = null;
        if (crateVisible) {
            crateGrid = document.getElementById('crateGrid');
            crateRect = crateGrid.getBoundingClientRect();
        }

        // Determine which container we're targeting based on mouse position
        let overBackpack = (event.clientX >= backpackRect.left && event.clientX <= backpackRect.right &&
                            event.clientY >= backpackRect.top && event.clientY <= backpackRect.bottom);

        let overCrate = false;
        if (crateVisible && crateRect) {
            overCrate = (event.clientX >= crateRect.left && event.clientX <= crateRect.right &&
                        event.clientY >= crateRect.top && event.clientY <= crateRect.bottom);
        }

        // Get items layers for position calculation
        const backpackItems = document.getElementById('inventoryItems');
        const backpackItemsRect = backpackItems.getBoundingClientRect();

        let crateItems = null;
        let crateItemsRect = null;
        if (crateVisible) {
            crateItems = document.getElementById('crateItems');
            crateItemsRect = crateItems.getBoundingClientRect();
        }

        // Update target and position based on which area mouse is over
        if (overBackpack) {
            // Mouse over backpack - calculate position relative to items layer
            this.inventoryMouseX = event.clientX - backpackItemsRect.left;
            this.inventoryMouseY = event.clientY - backpackItemsRect.top;
            this.inventoryPickedTarget = 'backpack';
        } else if (overCrate) {
            // Mouse over crate - calculate position relative to items layer
            this.inventoryMouseX = event.clientX - crateItemsRect.left;
            this.inventoryMouseY = event.clientY - crateItemsRect.top;
            this.inventoryPickedTarget = 'crate';
        } else {
            // Mouse is outside both areas - keep updating position relative to current target
            // This ensures the ghost follows the mouse everywhere, not just over the grids
            if (this.inventoryPickedTarget === 'crate' && crateVisible && crateItemsRect) {
                // Currently targeting crate, keep updating relative to crate items layer
                this.inventoryMouseX = event.clientX - crateItemsRect.left;
                this.inventoryMouseY = event.clientY - crateItemsRect.top;
                // Don't change target - stay as 'crate'
            } else {
                // Currently targeting backpack (or no crate visible), update relative to backpack items layer
                this.inventoryMouseX = event.clientX - backpackItemsRect.left;
                this.inventoryMouseY = event.clientY - backpackItemsRect.top;
                // Don't force target change - let it stay as is unless explicitly over a grid
            }
        }

        // Check if holding a chisel over a stone item (only in backpack)
        if (item.type === 'chisel' && this.inventoryPickedTarget === 'backpack') {
            try {
                const targetStone = this.getItemUnderCursor(this.inventoryMouseX, this.inventoryMouseY, item);
                if (this.chiselTarget !== targetStone) {
                    this.chiselTarget = targetStone;
                }
            } catch (error) {
                console.error('Error checking chisel target:', error);
                this.chiselTarget = null;
            }
        } else {
            this.chiselTarget = null;
        }

        // Re-render both inventories to update ghost position
        this.renderInventory();
        if (this.gameState.nearestCrate) {
            this.renderCrateInventory();
        }
    }

    onCrateMouseUp(event) {
        if (!this.inventoryPickedItem) return;

        // Ignore the mouseup from the pickup click
        if (this.inventoryIgnoreNextMouseUp) {
            this.inventoryIgnoreNextMouseUp = false;
            return;
        }

        const item = this.inventoryPickedItem;
        const source = this.inventoryPickedSource || 'backpack';
        const target = this.inventoryPickedTarget || source;

        // Check if chisel was released over a stone (only if coming from backpack)
        if (source === 'backpack' && item.type === 'chisel' && this.chiselTarget) {
            const targetStone = this.chiselTarget;

            // Clear chisel target
            this.chiselTarget = null;

            // Start chiseling action
            this.startChiselingAction(item, targetStone);

            // Clear picked item state
            this.inventoryPickedItem = null;
            this.inventoryPickedSource = null;
            this.inventoryPickedTarget = null;
            this.inventoryIgnoreNextMouseUp = false;

            // Remove global event listeners
            window.removeEventListener('mousemove', this.mouseMoveHandler);
            window.removeEventListener('mouseup', this.mouseUpHandler);
            window.removeEventListener('keydown', this.keyDownHandler);

            // Re-render inventory
            this.renderInventory();
            if (this.gameState.nearestCrate) {
                this.renderCrateInventory();
            }
            return;
        }

        // Clear any chisel target
        this.chiselTarget = null;

        // Check if dropping onto construction section (only if coming from backpack)
        if (source === 'backpack' && this.gameState.nearestConstructionSite && !this.gameState.isMoving) {
            const constructionSection = document.getElementById('constructionSection');
            if (constructionSection && constructionSection.style.display !== 'none') {
                const rect = constructionSection.getBoundingClientRect();

                // Check if mouse is over construction section
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {

                    const requiredMaterials = this.gameState.nearestConstructionSite.userData.requiredMaterials || {};
                    const currentMaterials = this.gameState.nearestConstructionSite.userData.materials || {};

                    // Check if this item type is needed
                    const itemType = item.type;

                    if (requiredMaterials[itemType]) {
                        const required = requiredMaterials[itemType];
                        const current = currentMaterials[itemType] || 0;

                        if (current < required) {
                            // Add material to construction
                            currentMaterials[itemType] = current + 1;
                            this.gameState.nearestConstructionSite.userData.materials = currentMaterials;

                            // Remove item from inventory
                            const itemIndex = this.gameState.inventory.items.indexOf(item);
                            if (itemIndex > -1) {
                                this.gameState.inventory.items.splice(itemIndex, 1);
                            }

                            console.log(`Added ${itemType} to construction (${current + 1}/${required})`);

                            // Clear picked item state
                            this.inventoryPickedItem = null;
                            this.inventoryPickedSource = null;
                            this.inventoryPickedTarget = null;
                            this.inventoryIgnoreNextMouseUp = false;

                            // Remove global event listeners
                            window.removeEventListener('mousemove', this.mouseMoveHandler);
                            window.removeEventListener('mouseup', this.mouseUpHandler);
                            window.removeEventListener('keydown', this.keyDownHandler);

                            // Re-render inventory (includes construction section and crate section)
                            this.renderInventory();
                            this.updateConstructionSection();
                            this.updateCrateSection();
                            return;
                        }
                    }
                }
            }
        }

        // Remove event listeners
        window.removeEventListener('mousemove', this.mouseMoveHandler);
        window.removeEventListener('mouseup', this.mouseUpHandler);
        window.removeEventListener('keydown', this.keyDownHandler);

        // Determine target inventory and validate placement
        if (target === 'backpack') {
            // Moving to backpack
            const gridPos = this.pixelToGrid(this.inventoryMouseX, this.inventoryMouseY);

            if (this.isValidPlacement(item, gridPos.x, gridPos.y, item.rotation)) {
                // Valid placement in backpack
                if (source === 'crate') {
                    // Remove from crate, add to backpack
                    const crateInventory = this.crateInventory;
                    const itemIndex = crateInventory.items.indexOf(item);
                    if (itemIndex > -1) {
                        crateInventory.items.splice(itemIndex, 1);
                    }
                    this.gameState.inventory.items.push(item);
                }
                // Update position
                item.x = gridPos.x;
                item.y = gridPos.y;
            } else {
                // Invalid placement - restore original position
                item.x = this.inventoryPickedOriginalX;
                item.y = this.inventoryPickedOriginalY;
                item.rotation = this.inventoryPickedOriginalRotation;
            }
        } else if (target === 'crate') {
            // Moving to crate
            const crateGridPos = this.pixelToCrateGrid(this.inventoryMouseX, this.inventoryMouseY);

            if (this.isValidCratePlacement(item, crateGridPos.x, crateGridPos.y, item.rotation)) {
                // Valid placement in crate
                if (source === 'backpack') {
                    // Remove from backpack, add to crate
                    const itemIndex = this.gameState.inventory.items.indexOf(item);
                    if (itemIndex > -1) {
                        this.gameState.inventory.items.splice(itemIndex, 1);
                    }
                    this.crateInventory.items.push(item);
                }
                // Update position
                item.x = crateGridPos.x;
                item.y = crateGridPos.y;
            } else {
                // Invalid placement - restore original position
                item.x = this.inventoryPickedOriginalX;
                item.y = this.inventoryPickedOriginalY;
                item.rotation = this.inventoryPickedOriginalRotation;
            }
        } else {
            // Dropped outside - restore original position
            item.x = this.inventoryPickedOriginalX;
            item.y = this.inventoryPickedOriginalY;
            item.rotation = this.inventoryPickedOriginalRotation;
        }

        // Clear picked item state
        this.inventoryPickedItem = null;
        this.inventoryPickedSource = null;
        this.inventoryPickedTarget = null;
        this.inventoryIgnoreNextMouseUp = false;

        // Re-render both inventories
        this.renderInventory();
        this.renderCrateInventory();

        // Mark crate inventory as dirty (needs saving)
        if (this.gameState.nearestCrate) {
            this.gameState.nearestCrate.userData.inventoryDirty = true;
        }
    }

    pixelToCrateGrid(pixelX, pixelY) {
        // Use same slot size and gap as backpack inventory
        const slotSize = this.gameState.inventory.slotSize;
        const gap = this.gameState.inventory.gap;
        const gridX = Math.floor(pixelX / (slotSize + gap));
        const gridY = Math.floor(pixelY / (slotSize + gap));
        return { x: gridX, y: gridY };
    }

    isValidCratePlacement(item, x, y, rotation) {
        // Check bounds (10x10 grid)
        const displayWidth = rotation === 90 ? item.height : item.width;
        const displayHeight = rotation === 90 ? item.width : item.height;

        if (x < 0 || y < 0 || x + displayWidth > 10 || y + displayHeight > 10) {
            return false;
        }

        // Check for overlaps with other items in crate
        const crateInventory = this.crateInventory;
        if (!crateInventory || !crateInventory.items) {
            return false;
        }

        for (const other of crateInventory.items) {
            if (other.id === item.id) continue; // Skip self

            const otherWidth = other.rotation === 90 ? other.height : other.width;
            const otherHeight = other.rotation === 90 ? other.width : other.height;

            // Check if rectangles overlap
            if (!(x >= other.x + otherWidth ||
                  x + displayWidth <= other.x ||
                  y >= other.y + otherHeight ||
                  y + displayHeight <= other.y)) {
                return false; // Overlap detected
            }
        }

        return true; // Valid placement
    }

    renderBuildMenu() {
        const structuresContainer = document.getElementById('buildMenuStructures');
        const buildMenuGrid = document.getElementById('buildMenuGrid');
        structuresContainer.innerHTML = ''; // Clear existing

        // Update grid styling dynamically
        const { slotSize, gap, rows, cols } = this.gameState.buildMenu;
        buildMenuGrid.style.gridTemplateColumns = `repeat(${cols}, ${slotSize}px)`;
        buildMenuGrid.style.gridTemplateRows = `repeat(${rows}, ${slotSize}px)`;
        buildMenuGrid.style.gap = `${gap}px`;

        // Update slot styling
        const slots = buildMenuGrid.querySelectorAll('.build-menu-slot');
        slots.forEach(slot => {
            slot.style.width = `${slotSize}px`;
            slot.style.height = `${slotSize}px`;
        });

        // Render structures at fixed positions
        this.gameState.buildMenu.structures.forEach((structure, index) => {
            // Create wrapper
            const structureWrapper = document.createElement('div');
            structureWrapper.className = 'build-menu-structure-wrapper';
            structureWrapper.dataset.structureId = structure.id;
            structureWrapper.style.position = 'absolute';

            // Place structures in a grid pattern (row by row)
            const x = index % cols;
            const y = Math.floor(index / cols);

            // Calculate pixel position
            const pixelPos = { x: x * (slotSize + gap), y: y * (slotSize + gap) };
            structureWrapper.style.left = pixelPos.x + 'px';
            structureWrapper.style.top = pixelPos.y + 'px';

            // Create image element
            const structureEl = document.createElement('img');
            structureEl.src = structure.imagePath;
            structureEl.className = 'build-menu-structure';
            structureEl.style.position = 'relative';

            // Calculate size based on slots
            const displayWidth = structure.width;
            const displayHeight = structure.height;
            const widthPx = displayWidth * slotSize + (displayWidth - 1) * gap;
            const heightPx = displayHeight * slotSize + (displayHeight - 1) * gap;

            structureEl.style.width = widthPx + 'px';
            structureEl.style.height = heightPx + 'px';
            structureWrapper.style.width = widthPx + 'px';
            structureWrapper.style.height = heightPx + 'px';

            // Add click event listener
            structureWrapper.addEventListener('click', (e) => this.onStructureClick(e, structure));

            // Add hover event listeners for tooltip
            structureWrapper.addEventListener('mouseenter', (e) => this.showBuildMenuTooltip(e, structure));
            structureWrapper.addEventListener('mousemove', (e) => this.updateBuildMenuTooltipPosition(e));
            structureWrapper.addEventListener('mouseleave', () => this.hideBuildMenuTooltip());

            // Assemble
            structureWrapper.appendChild(structureEl);
            structuresContainer.appendChild(structureWrapper);
        });
    }

    onStructureClick(event, structure) {
        event.preventDefault();
        event.stopPropagation();

        // Pick up the structure for placement
        this.buildMenuPickedStructure = structure;

        // Close build menu
        this.toggleBuildMenu();

        // Start foundation placement flow
        this.startFoundationPlacement(structure);
    }

    showBuildMenuTooltip(event, structure) {
        const tooltip = document.getElementById('buildMenuTooltip');
        const titleEl = tooltip.querySelector('.tooltip-title');

        // Set content
        titleEl.textContent = structure.name;

        // Position and show tooltip
        this.updateBuildMenuTooltipPosition(event);
        tooltip.style.display = 'block';
    }

    updateBuildMenuTooltipPosition(event) {
        const tooltip = document.getElementById('buildMenuTooltip');
        // Position tooltip slightly offset from cursor
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 15) + 'px';
    }

    hideBuildMenuTooltip() {
        const tooltip = document.getElementById('buildMenuTooltip');
        tooltip.style.display = 'none';
    }

    // ==========================================
    // FOUNDATION PLACEMENT SYSTEM
    // ==========================================

    startFoundationPlacement(structure) {
        this.gameState.foundationPlacement.active = true;
        this.gameState.foundationPlacement.phase = 'position';
        this.gameState.foundationPlacement.structure = structure;
        this.gameState.foundationPlacement.rotation = 0;
        this.gameState.foundationPlacement.height = 0;

        // Load actual structure model for preview (foundation, foundationcorner, or foundationroundcorner)
        const structureModel = modelManager.getModel(structure.type);
        if (!structureModel) {
            console.error(`${structure.type} model not loaded for preview`);
            return;
        }

        const previewGroup = new THREE.Group();

        // Determine scale based on structure type (outpost is smaller - 40% reduction from 0.05)
        const previewScale = (structure.type === 'outpost') ? 0.03 : 0.5;
        const glowScale = (structure.type === 'outpost') ? 0.032 : 0.52;

        // Clone the structure model (semi-transparent)
        const foundationPreview = structureModel.clone();
        foundationPreview.scale.setScalar(previewScale); // Match actual structure scale

        // Make model semi-transparent
        foundationPreview.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                // Clone material to avoid affecting the original
                child.material = child.material.clone();
                child.material.transparent = true;
                child.material.opacity = 0.6;
                child.material.depthWrite = false;
            }
        });

        // Create glow outline (slightly larger duplicate with emissive material)
        const glowOutline = structureModel.clone();
        glowOutline.scale.setScalar(glowScale); // Slightly larger for outline effect
        glowOutline.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.material = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide, // Render backfaces for outline effect
                    depthWrite: false
                });
            }
        });

        previewGroup.add(glowOutline);
        previewGroup.add(foundationPreview);

        this.gameState.foundationPlacement.previewBox = previewGroup;
        this.gameState.foundationPlacement.previewBox.userData.foundationPreview = foundationPreview;
        this.gameState.foundationPlacement.previewBox.userData.glowOutline = glowOutline;
        this.gameState.foundationPlacement.previewBox.visible = true;
        this.scene.add(this.gameState.foundationPlacement.previewBox);

        console.log('Foundation placement started - model preview created');
        ui.updateStatusLine1('Move mouse to position foundation, click to confirm', 0);
    }

    updateFoundationPreview(mouseX, mouseZ, mouseY) {
        if (!this.gameState.foundationPlacement.active) return;

        const placement = this.gameState.foundationPlacement;
        const previewBox = placement.previewBox;

        // Safety check: if previewBox doesn't exist (model failed to load), abort
        if (!previewBox) {
            console.warn('Preview box not available, cannot update preview');
            return;
        }

        if (placement.phase === 'position') {
            // Position phase - follow mouse on terrain with 0.5 grid snapping
            placement.position.x = Math.round(mouseX / 0.5) * 0.5;
            placement.position.z = Math.round(mouseZ / 0.5) * 0.5;

            const structure = placement.structure;
            let previewY;

            // Crates snap to foundation height, foundations use terrain height
            if (structure && structure.requiresFoundation) {
                // For crates: find foundation and snap to its position
                const foundationBelow = this.findFoundationAtPosition(placement.position.x, placement.position.z);

                if (foundationBelow) {
                    // Snap to foundation position
                    placement.position.x = foundationBelow.position.x;
                    placement.position.z = foundationBelow.position.z;

                    // ADDING NEW STRUCTURES - STEP 4: Y POSITION CALCULATION
                    // For structures on foundations, calculate proper Y position.
                    // Formula: foundation.y + (foundationHeight/2) + (structureHeight/2) + gap
                    // This positions the structure's center above the foundation's top surface.
                    // Adjust heights based on your actual model dimensions at scale 0.5
                    const foundationHeight = 2.5; // Foundation height at scale 0.5
                    const crateHeight = 0.5; // Approximate crate height at scale 0.5
                    // Position crate center above foundation: foundation_center + foundation_half_height + crate_half_height
                    // Add small extra offset to ensure visibility
                    const extraOffset = 0.1; // Small gap between foundation and crate
                    previewY = foundationBelow.position.y + (foundationHeight / 2) + (crateHeight / 2) + extraOffset;
                } else {
                    // No foundation - show at mouse position but will be marked invalid
                    const terrainHeight = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x, placement.position.z);
                    previewY = terrainHeight;
                }

                placement.position.y = previewY;
            } else {
                // Regular foundations: calculate average height from 4 corners
                const halfSize = 0.25;
                const corner1 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x - halfSize, placement.position.z - halfSize);
                const corner2 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x + halfSize, placement.position.z - halfSize);
                const corner3 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x - halfSize, placement.position.z + halfSize);
                const corner4 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x + halfSize, placement.position.z + halfSize);
                const averageHeight = (corner1 + corner2 + corner3 + corner4) / 4;

                // Snap to 0.5 grid - round UP to nearest 0.5 increment
                const snappedHeight = Math.ceil(averageHeight / 0.5) * 0.5;
                previewY = snappedHeight;
                placement.position.y = snappedHeight;
            }

            previewBox.position.set(placement.position.x, previewY, placement.position.z);
            previewBox.visible = true;

            // Validate placement (throttled to reduce lag)
            this.validateFoundationPlacementThrottled();

        } else if (placement.phase === 'rotation') {
            // Rotation phase - one face follows the cursor position
            const angle = Math.atan2(mouseZ - placement.position.z, mouseX - placement.position.x);
            const degrees = -(angle * (180 / Math.PI)); // Negate for opposite rotation

            // Snap to 15° increments
            placement.rotation = Math.round(degrees / 15) * 15;

            previewBox.rotation.y = placement.rotation * (Math.PI / 180);

        } else if (placement.phase === 'height') {
            // Height phase - adjust Y based on mouse vertical movement
            // Mouse up (smaller Y) = increase height, mouse down (larger Y) = decrease height
            const mouseDelta = placement.initialMouseY - mouseY;
            // Scale factor: 100 pixels of mouse movement = 1 unit of height
            const heightAdjustment = mouseDelta / 100;

            // Snap to 0.5 increments and clamp to range (down: -2, up: +0.75 relative to base)
            const snappedHeight = Math.round(heightAdjustment / 0.5) * 0.5;
            placement.height = Math.max(-2, Math.min(0.75, snappedHeight));

            // Apply height offset to snapped base (base is already on 0.5 grid from position phase)
            const baseHeight = placement.position.y; // Already snapped to 0.5 grid
            previewBox.position.y = baseHeight + placement.height; // Final Y always on 0.5 grid

            // Update status line to show current offset and final absolute Y
            const finalY = baseHeight + placement.height;
            ui.updateStatusLine2(`Height: ${placement.height.toFixed(2)} (Final Y: ${finalY.toFixed(2)})`, 0);
        }

        // Update glow outline color based on validity
        const glowOutline = previewBox.userData.glowOutline;

        if (placement.isValid) {
            // Green glow for valid placement
            glowOutline.traverse((child) => {
                if (child instanceof THREE.Mesh && child.material) {
                    child.material.color.setHex(0x00ff00);
                }
            });
            if (placement.phase === 'position') {
                ui.updateStatusLine2('Valid location', 0);
            }
        } else {
            // Red glow for invalid placement
            glowOutline.traverse((child) => {
                if (child instanceof THREE.Mesh && child.material) {
                    child.material.color.setHex(0xff0000);
                }
            });
            // Show tooltip with reason
            ui.updateStatusLine2(placement.invalidReason, 0);
        }
    }

    // ADDING NEW STRUCTURES - STEP 3: PLACEMENT VALIDATION
    // This function validates if a structure can be placed at the current position.
    // For structures with requiresFoundation=true:
    //   - Checks for foundation at position
    //   - Skips terrain validation (slope, water, etc.)
    // For regular structures:
    //   - Validates terrain slope
    //   - Checks distance from other objects
    //   - Can add custom validation rules
    validateFoundationPlacement() {
        const placement = this.gameState.foundationPlacement;
        const pos = placement.position;
        const structure = placement.structure;

        // Special validation for structures requiring foundation (like crates)
        if (structure && structure.requiresFoundation) {
            // Check if there's a foundation at this exact position
            const foundationBelow = this.findFoundationAtPosition(pos.x, pos.z);

            if (!foundationBelow) {
                placement.isValid = false;
                placement.invalidReason = 'Requires foundation';
                return;
            }

            // Check if foundation already has a crate
            const existingCrate = this.findCrateOnFoundation(foundationBelow);
            if (existingCrate) {
                placement.isValid = false;
                placement.invalidReason = 'Foundation already has crate';
                return;
            }

            // Store foundation reference for later use
            placement.foundationBelow = foundationBelow;

            // All checks passed for crate
            placement.isValid = true;
            placement.invalidReason = '';
            return;
        }

        // Regular foundation validation
        // Check 1: Terrain slope
        const normal = this.terrainRenderer.heightCalculator.calculateNormal(pos.x, pos.z);
        const slope = Math.acos(normal.y) * (180 / Math.PI); // Convert to degrees

        if (slope > 50) {
            placement.isValid = false;
            placement.invalidReason = 'Slope too steep';
            return;
        }

        // Check 2: Distance from objects (1 unit minimum)
        const nearbyObjects = this.findObjectsNearPoint(pos.x, pos.z, 1);
        if (nearbyObjects.length > 0) {
            placement.isValid = false;
            placement.invalidReason = 'Too close to objects';
            return;
        }

        // All checks passed
        placement.isValid = true;
        placement.invalidReason = '';
    }

    findObjectsNearPoint(x, z, radius) {
        const nearbyObjects = [];
        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId) {
                const dx = object.position.x - x;
                const dz = object.position.z - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < radius) {
                    nearbyObjects.push(object);
                }
            }
        });
        return nearbyObjects;
    }

    findFoundationAtPosition(x, z) {
        // Find foundation at exact grid position (within 0.1 unit tolerance)
        let foundFoundation = null;
        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId) {
                const modelType = object.userData.modelType;
                if (modelType === 'foundation' ||
                    modelType === 'foundationcorner' ||
                    modelType === 'foundationroundcorner') {
                    const dx = Math.abs(object.position.x - x);
                    const dz = Math.abs(object.position.z - z);
                    if (dx < 0.1 && dz < 0.1) {
                        foundFoundation = object;
                    }
                }
            }
        });
        return foundFoundation;
    }

    findCrateOnFoundation(foundation) {
        // Check if there's already a crate at this foundation's position
        const fx = foundation.position.x;
        const fz = foundation.position.z;
        let existingCrate = null;

        this.scene.traverse((object) => {
            if (object.userData && object.userData.objectId) {
                if (object.userData.modelType === 'crate') {
                    const dx = Math.abs(object.position.x - fx);
                    const dz = Math.abs(object.position.z - fz);
                    if (dx < 0.1 && dz < 0.1) {
                        existingCrate = object;
                    }
                }
            }
        });
        return existingCrate;
    }

    // ADDING NEW STRUCTURES - PLACEMENT FLOW
    // Placement phases for structures:
    // 1. Position phase - Player moves mouse to position structure
    // 2. Rotation phase - Player rotates structure
    // 3. Height phase - Player adjusts height (SKIPPED for requiresFoundation structures)
    // Structures with requiresFoundation=true go directly from rotation to confirm
    advanceFoundationPlacementPhase(mouseY) {
        const placement = this.gameState.foundationPlacement;
        const structure = placement.structure;

        if (placement.phase === 'position') {
            if (!placement.isValid) {
                // Cancel placement on invalid location click
                ui.updateStatusLine1(`Placement cancelled: ${placement.invalidReason}`, 3000);
                this.cancelFoundationPlacement();
                return;
            }
            placement.phase = 'rotation';
            ui.updateStatusLine1('Move mouse to rotate, click to confirm', 0);

        } else if (placement.phase === 'rotation') {
            // Crates and outposts skip height phase - they snap to terrain automatically
            if (structure && (structure.requiresFoundation || structure.type === 'outpost')) {
                this.confirmFoundationPlacement();
            } else {
                // Foundations go to height adjustment phase
                placement.phase = 'height';
                // Capture initial mouse Y for height adjustment
                placement.initialMouseY = mouseY || 0;
                placement.height = 0;  // Reset height to 0 when entering this phase
                ui.updateStatusLine1('Move mouse up/down to adjust height, click to confirm', 0);
            }

        } else if (placement.phase === 'height') {
            // Final placement (only for foundations)
            this.confirmFoundationPlacement();
        }
    }

    confirmFoundationPlacement() {
        const placement = this.gameState.foundationPlacement;
        const structure = placement.structure;

        if (!placement.isValid) {
            ui.updateStatusLine1(`Cannot place: ${placement.invalidReason}`, 3000);
            return;
        }

        // Special handling for crate placement
        if (structure && structure.requiresFoundation) {
            const foundation = placement.foundationBelow;

            // Calculate crate Y position (on top of foundation)
            // Use same calculation as preview for consistency
            const foundationHeight = 2.5; // Foundation height at scale 0.5
            const crateHeight = 0.5; // Approximate crate height at scale 0.5
            // Position crate center above foundation: foundation_center + foundation_half_height + crate_half_height
            // Add small extra offset to ensure visibility
            const extraOffset = 0.1; // Small gap between foundation and crate
            const crateY = foundation.position.y + (foundationHeight / 2) + (crateHeight / 2) + extraOffset;

            // Send to server to spawn crate construction site
            console.log(`Placing crate construction at Y=${crateY} (foundation Y=${foundation.position.y})`);
            this.networkManager.sendMessage('place_construction_site', {
                position: [foundation.position.x, crateY, foundation.position.z],
                rotation: placement.rotation,
                scale: 0.017,
                targetStructure: structure.type,  // 'crate'
                finalCrateY: crateY,  // Store final crate Y
                foundationId: foundation.userData.objectId  // Link to foundation
            });

            console.log('Crate construction site placement request sent to server:', {
                position: [foundation.position.x, crateY, foundation.position.z],
                rotation: placement.rotation,
                targetStructure: structure.type,
                foundationId: foundation.userData.objectId
            });

            ui.updateStatusLine1('Crate construction site placed!', 3000);
            this.cancelFoundationPlacement();
            return;
        }

        // Regular foundation placement
        // Calculate average height of 4 corners for construction site
        const halfSize = 0.25;
        const corner1 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x - halfSize, placement.position.z - halfSize);
        const corner2 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x + halfSize, placement.position.z - halfSize);
        const corner3 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x - halfSize, placement.position.z + halfSize);
        const corner4 = this.terrainRenderer.heightCalculator.calculateHeight(placement.position.x + halfSize, placement.position.z + halfSize);
        const averageHeight = (corner1 + corner2 + corner3 + corner4) / 4;

        // Preview model's final Y position (what player saw and adjusted)
        const previewFinalY = placement.position.y + placement.height;

        // Send to server to spawn construction site (server will broadcast to all clients)
        this.networkManager.sendMessage('place_construction_site', {
            position: [placement.position.x, averageHeight, placement.position.z],
            rotation: placement.rotation,
            scale: 0.017,
            targetStructure: structure.type,  // Use actual structure type (foundation, foundationcorner, foundationroundcorner)
            finalFoundationY: previewFinalY  // Store preview Y for final structure
        });

        console.log('Construction site placement request sent to server:', {
            position: [placement.position.x, averageHeight, placement.position.z],
            rotation: placement.rotation,
            scale: 0.017,
            targetStructure: structure.type,
            finalFoundationY: previewFinalY
        });

        ui.updateStatusLine1('Construction site placed!', 3000);

        // Clean up placement state
        this.cancelFoundationPlacement();
    }

    cancelFoundationPlacement() {
        const placement = this.gameState.foundationPlacement;

        if (placement.previewBox) {
            this.scene.remove(placement.previewBox);

            // Dispose of group children (solidBox and wireframe)
            placement.previewBox.traverse((child) => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    child.material.dispose();
                }
            });

            placement.previewBox = null;
        }

        placement.active = false;
        placement.phase = null;
        placement.structure = null;
        this.buildMenuPickedStructure = null;

        ui.updateStatusLine1('', 0);
        ui.updateStatusLine2('', 0);
    }

    cancelPickup() {
        // Restore item to original position
        if (this.inventoryPickedItem) {
            this.inventoryPickedItem.x = this.inventoryPickedOriginalX;
            this.inventoryPickedItem.y = this.inventoryPickedOriginalY;
            this.inventoryPickedItem.rotation = this.inventoryPickedOriginalRotation;
        }

        // Clear picked item state
        this.inventoryPickedItem = null;
        this.inventoryIgnoreNextMouseUp = false;

        // Clear chisel target
        this.chiselTarget = null;

        // Remove event listeners
        if (this.mouseMoveHandler) {
            window.removeEventListener('mousemove', this.mouseMoveHandler);
            window.removeEventListener('mouseup', this.mouseUpHandler);
            window.removeEventListener('keydown', this.keyDownHandler);
        }

        // Re-render to snap back
        this.renderInventory();
    }

    async initiateP2PConnection(peerId) {
        const connection = this.networkManager.createPeerConnection(peerId, true);
        try {
            const offer = await connection.createOffer();
            await connection.setLocalDescription(offer);
            this.networkManager.sendMessage('webrtc_offer', {
                recipientId: peerId,
                senderId: this.gameState.clientId,
                offer
            });
        } catch (error) {
            ui.updateStatus(`❌ Failed to create offer for ${peerId}: ${error}`);
        }
    }

    // --- Input and Resizing ---

    onPointerMove(event) {
        if (event.target.tagName !== 'CANVAS') return;

        // Only update if foundation placement is active
        if (!this.gameState.foundationPlacement.active) return;

        // Calculate normalized device coordinates
        this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Raycast to find terrain intersection
        this.raycaster.setFromCamera(this.pointer, this.camera);
        const terrainObjects = Array.from(this.terrainRenderer.chunkMap.values()).map(c => c.mesh);
        const waterObjects = this.waterRenderer.getWaterChunks();
        const allObjects = [...terrainObjects, ...waterObjects];
        const intersects = this.raycaster.intersectObjects(allObjects, true);

        if (intersects.length > 0) {
            const { point } = intersects[0];
            // Pass both terrain coordinates and screen Y for height adjustment
            this.updateFoundationPreview(point.x, point.z, event.clientY);
        }
    }

    onPointerDown(event) {
        if (event.target.tagName !== 'CANVAS') return;

        // Resume AudioContext on first user interaction (browser requirement)
        if (this.audioManager) {
            this.audioManager.resumeContext();
        }

        // Handle foundation placement if active
        if (this.gameState.foundationPlacement.active) {
            this.advanceFoundationPlacementPhase(event.clientY);
            return;
        }

        // Prevent movement during chopping/harvesting
        if (this.gameState.activeChoppingAction) {
            console.log('Cannot move while chopping/harvesting');
            return;
        }

        // Prevent movement when inventory is open (forces player to close menu first)
        if (this.gameState.inventoryOpen) {
            console.log('Cannot move while inventory is open');
            return;
        }

        this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.pointer, this.camera);
        const terrainObjects = Array.from(this.terrainRenderer.chunkMap.values()).map(c => c.mesh);
        const waterObjects = this.waterRenderer.getWaterChunks();

        // Collect walkable foundation objects for raycast (allows clicking on foundations)
        const foundationObjects = [];
        for (const objects of this.terrainRenderer.chunkTrees.values()) {
            for (const obj of objects) {
                // Only include walkable foundations (not construction sites)
                if (obj.userData.modelType === 'foundation' ||
                    obj.userData.modelType === 'foundationcorner' ||
                    obj.userData.modelType === 'foundationroundcorner') {
                    foundationObjects.push(obj);
                }
            }
        }

        const allObjects = [...terrainObjects, ...waterObjects, ...foundationObjects];
        const intersects = this.raycaster.intersectObjects(allObjects, true);

        if (intersects.length > 0) {
            const { point } = intersects[0];
            // Use clicked position (X, Y, Z) - if clicking on foundation, Y will be foundation surface
            this.gameState.playerTargetPosition.set(point.x, point.y, point.z);
            this.gameState.isMoving = true;
            ui.updateStatus(`🚀 Moving to clicked position...`);

            // Hide construction/crate sections when player starts moving
            if (this.gameState.inventoryOpen) {
                this.updateConstructionSection();
                this.updateCrateSection();
            }

            // Update button states immediately when starting movement
            const hasAxe = this.hasToolWithDurability('axe');
            const hasSaw = this.hasToolWithDurability('saw');
            const isOnCooldown = this.gameState.harvestCooldown && this.gameState.harvestCooldown.endTime > Date.now();
            ui.updateButtonStates(this.gameState.isInChunk, this.gameState.nearestObject, hasAxe, hasSaw, isOnCooldown, this.gameState.nearestConstructionSite, this.gameState.isMoving, this.gameState.nearestCrate);

            this.networkManager.broadcastP2P({
                type: 'player_move',
                payload: {
                    start: this.playerObject.position.toArray(),
                    target: this.gameState.playerTargetPosition.toArray()
                }
            });
        }
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        // Recalculate inventory sizes if inventory is open
        if (this.gameState.inventoryOpen) {
            this.calculateInventorySize();
            this.renderInventory();
            // Also update crate inventory if it's showing
            if (this.gameState.nearestCrate) {
                this.renderCrateInventory();
            }
        }

        // Recalculate build menu sizes if build menu is open
        if (this.gameState.buildMenuOpen) {
            this.calculateBuildMenuSize();
            this.renderBuildMenu();
        }
    }

    zoomIn() {
        this.gameState.cameraZoom = Math.max(
            this.gameState.cameraZoomMin,
            this.gameState.cameraZoom - 0.05
        );
    }

    zoomOut() {
        this.gameState.cameraZoom = Math.min(
            this.gameState.cameraZoomMax,
            this.gameState.cameraZoom + 0.05
        );
    }


    // --- Animation Loop and Updates ---

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        const frameStartTime = performance.now();
        const now = frameStartTime;
        const deltaTime = now - this.gameState.lastFrameTime;

        // Increment frame counter
        this.frameCount++;

        this.updatePlayerMovement(deltaTime);
        this.updateAvatarMovement(deltaTime);
        this.updateChoppingAction();

        // Update player animation
        if (this.animationMixer) {
            if (this.gameState.activeChoppingAction) {
                // Play chopping animation at 1.5x speed
                this.animationMixer.update((deltaTime / 1000) * 1.5);
            } else if (this.gameState.isMoving) {
                // Play walk animation when moving (2.5x faster)
                this.animationMixer.update((deltaTime / 1000) * 2.5);
            } else {
                // Idle: freeze on first frame of walk animation
                this.animationMixer.setTime(0);
            }
        }

        this.updateCameraAndLighting();
        this.runPeriodicChecks(now);

        // Process chunk creation queue (1 chunk per frame)
        const chunkStartTime = performance.now();
        this.chunkManager.processChunkQueue();
        const chunkTime = performance.now() - chunkStartTime;

        // Process vertex updates (batched for smoothness - highest priority after chunk creation)
        const vertexStartTime = performance.now();
        // Pass player position for distance checks
        const playerPos = this.player ? this.player.position : null;
        this.terrainRenderer.processVertexUpdateQueue(playerPos);
        const vertexTime = performance.now() - vertexStartTime;

        // Process object generation queue (1 chunk's objects per frame)
        const objectStartTime = performance.now();
        this.terrainRenderer.processObjectGenerationQueue();
        const objectTime = performance.now() - objectStartTime;

        // Emergency disposal if queue gets too large (prevents accumulation)
        // Increased threshold since we now have regular 500ms cleanup
        if (this.chunkManager.pendingChunkDisposals.length > 20) {
            console.log('🚨 Emergency disposal triggered - queue size:', this.chunkManager.pendingChunkDisposals.length);
            this.chunkManager.processDisposalQueue();
        }

        this.waterRenderer.update(now);

        const renderStartTime = performance.now();
        this.renderer.render(this.scene, this.camera);
        const renderTime = performance.now() - renderStartTime;

        this.gameState.lastFrameTime = now;

        // Update FPS counter
        this.fpsFrames++;
        if (now - this.fpsLastTime >= this.fpsUpdateInterval) {
            const fps = Math.round((this.fpsFrames * 1000) / (now - this.fpsLastTime));
            ui.updateFPS(fps);
            this.fpsFrames = 0;
            this.fpsLastTime = now;
        }
    }

    updatePlayerMovement(deltaTime) {
        const { position } = this.playerObject;

        // Always update Y position based on terrain/foundation, even when not moving
        if (!this.gameState.isMoving) {
            const collision = this.checkStructureCollision(position);
            if (collision.hasCollision && collision.objectHeight) {
                const targetY = collision.objectHeight + 0.03;
                position.y = THREE.MathUtils.lerp(position.y, targetY, 0.2);
            } else if (this.terrainRenderer) {
                const terrainHeight = this.terrainRenderer.getHeightFast(position.x, position.z);
                const targetY = terrainHeight + 0.03;
                position.y = THREE.MathUtils.lerp(position.y, targetY, 0.2);
            }
            return;
        }

        const { playerTargetPosition } = this.gameState;

        // Calculate 2D distance (X, Z only) since Y follows terrain
        const dx = position.x - playerTargetPosition.x;
        const dz = position.z - playerTargetPosition.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= this.stopThreshold) {
    // Arrived at target - only update X and Z, keep Y from movement
    position.x = playerTargetPosition.x;
    position.z = playerTargetPosition.z;
    this.gameState.isMoving = false;
    ui.updateStatus("🛑 Arrived at destination.");

    // Show construction/crate sections if near site/crate and inventory is open
    if (this.gameState.inventoryOpen) {
        this.updateConstructionSection();
        this.updateCrateSection();
    }

    // Compare JavaScript vs Shader terrain height calculation
    if (this.terrainRenderer?.heightCalculator) {
        const playerX = position.x;
        const playerZ = position.z;
        const jsHeight = this.terrainRenderer.heightCalculator.calculateHeight(playerX, playerZ);

        console.log(`📍 Player at (${playerX.toFixed(2)}, ${playerZ.toFixed(2)})`);
        console.log(`   JavaScript terrain height: ${jsHeight.toFixed(3)}`);
        console.log(`   Water level: 1.02`);
        console.log(`   Expected water depth: ${(1.02 - jsHeight).toFixed(3)}`);
        console.log(`   (Shader calculates height in real-time - visual mismatch = shader error)`);
    }

    this.checkProximityToObjects(); // Check proximity when arriving

    // Update button states immediately when stopping (checkProximityToObjects already calls this, but for immediate feedback)
} else {
            const moveStep = this.playerSpeed * deltaTime;
            const alpha = Math.min(1, moveStep / distance);

            // Calculate next position
            const nextPosition = position.clone();
            nextPosition.lerp(playerTargetPosition, alpha);

            // Check for collision with structures
            const collision = this.checkStructureCollision(nextPosition);
            if (collision.hasCollision) {
                if (collision.objectHeight) {
                    // Foundation - allow step-up
                    const stepHeight = collision.objectHeight - position.y;
                    const MAX_STEP_HEIGHT = 0.3;

                    if (stepHeight > 0 && stepHeight <= MAX_STEP_HEIGHT) {
                        // Step up onto foundation
                        position.copy(nextPosition);
                        // Smooth lerp to foundation height
                        const targetY = collision.objectHeight + 0.03;
                        position.y = THREE.MathUtils.lerp(position.y, targetY, 0.2);
                    } else if (stepHeight <= 0) {
                        // Already on or above foundation
                        position.copy(nextPosition);
                        const targetY = collision.objectHeight + 0.03;
                        position.y = THREE.MathUtils.lerp(position.y, targetY, 0.2);
                    } else {
                        // Too high to step up
                        this.gameState.isMoving = false;
                        ui.updateStatusLine2('⚠️ Blocked by structure', 2000);

                        // Show construction/crate sections if near site/crate and inventory is open
                        if (this.gameState.inventoryOpen) {
                            this.updateConstructionSection();
                            this.updateCrateSection();
                        }

                        // Update button states immediately when blocked
                        const hasAxe = this.hasToolWithDurability('axe');
                        const hasSaw = this.hasToolWithDurability('saw');
                        const isOnCooldown = this.gameState.harvestCooldown && this.gameState.harvestCooldown.endTime > Date.now();
                        ui.updateButtonStates(this.gameState.isInChunk, this.gameState.nearestObject, hasAxe, hasSaw, isOnCooldown, this.gameState.nearestConstructionSite, this.gameState.isMoving, this.gameState.nearestCrate);
                    }
                } else {
                    // Construction site - block movement
                    this.gameState.isMoving = false;
                    ui.updateStatusLine2('⚠️ Blocked by structure', 2000);

                    // Show construction/crate sections if near site/crate and inventory is open
                    if (this.gameState.inventoryOpen) {
                        this.updateConstructionSection();
                        this.updateCrateSection();
                    }

                    // Update button states immediately when blocked
                    const hasAxe = this.hasToolWithDurability('axe');
                    const hasSaw = this.hasToolWithDurability('saw');
                    const isOnCooldown = this.gameState.harvestCooldown && this.gameState.harvestCooldown.endTime > Date.now();
                    ui.updateButtonStates(this.gameState.isInChunk, this.gameState.nearestObject, hasAxe, hasSaw, isOnCooldown, this.gameState.nearestConstructionSite, this.gameState.isMoving, this.gameState.nearestCrate);
                }
            } else {
                // No collision, apply movement
                position.copy(nextPosition);

                // Update Y position to follow terrain (prevents clipping through ground)
                if (this.terrainRenderer) {
                    const terrainHeight = this.terrainRenderer.getHeightFast(position.x, position.z);
                    // Smooth lerp to terrain height
                    const targetY = terrainHeight + 0.03;
                    position.y = THREE.MathUtils.lerp(position.y, targetY, 0.2);
                }
            }

            // Rotate player to face movement direction (smooth turn)
            const direction = new THREE.Vector3();
            direction.subVectors(playerTargetPosition, position).normalize();
            if (direction.length() > 0) {
                const targetRotation = Math.atan2(direction.x, direction.z);
                const currentRotation = this.playerObject.rotation.y;

                // Smoothly interpolate rotation (fast but not instant)
                let rotationDiff = targetRotation - currentRotation;
                // Normalize to -PI to PI range
                while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;

                const rotationSpeed = 0.15; // Adjust for faster/slower turning
                this.playerObject.rotation.y += rotationDiff * rotationSpeed;
            }
        }
    }

    updateAvatarMovement(deltaTime) {
        this.networkManager.avatars.forEach((avatar, peerId) => {
            const peer = this.networkManager.peers.get(peerId);
            if (peer?.targetPosition) {
                // Store last position before moving
                avatar.userData.lastPosition.copy(avatar.position);

                const distance = avatar.position.distanceTo(peer.targetPosition);
                if (distance <= this.stopThreshold) {
                    avatar.position.copy(peer.targetPosition);
                    peer.targetPosition = null;
                    avatar.userData.isMoving = false;
                } else {
                    const moveStep = this.playerSpeed * deltaTime;
                    const alpha = Math.min(1, moveStep / distance);
                    avatar.position.lerp(peer.targetPosition, alpha);
                    avatar.userData.isMoving = true;

                    // Calculate rotation from movement direction
                    const direction = new THREE.Vector3();
                    direction.subVectors(peer.targetPosition, avatar.position).normalize();
                    if (direction.length() > 0) {
                        const targetRotation = Math.atan2(direction.x, direction.z);
                        const currentRotation = avatar.rotation.y;

                        // Smoothly interpolate rotation
                        let rotationDiff = targetRotation - currentRotation;
                        // Normalize to -PI to PI range
                        while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                        while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;

                        const rotationSpeed = 0.15;
                        avatar.rotation.y += rotationDiff * rotationSpeed;
                    }
                }

                // Update Y position to follow terrain or foundations
                if (this.terrainRenderer) {
                    // Check if avatar is on/near a foundation
                    const collision = this.checkStructureCollision(avatar.position);

                    if (collision.hasCollision && collision.objectHeight) {
                        // Avatar should be on foundation - smooth lerp
                        const targetY = collision.objectHeight + 0.03;
                        avatar.position.y = THREE.MathUtils.lerp(avatar.position.y, targetY, 0.2);
                    } else {
                        // Avatar on terrain - smooth lerp
                        const terrainHeight = this.terrainRenderer.getHeightFast(avatar.position.x, avatar.position.z);
                        const targetY = terrainHeight + 0.03;
                        avatar.position.y = THREE.MathUtils.lerp(avatar.position.y, targetY, 0.2);
                    }
                }
            }

            // Check if peer is harvesting and update harvest animation
            if (peer?.harvestState) {
                const now = Date.now();
                if (now >= peer.harvestState.endTime) {
                    // Harvest complete, stop chopping animation
                    if (peer.choppingAction) {
                        peer.choppingAction.stop();
                    }
                    peer.harvestState = null;
                    console.log(`Peer ${peerId} finished harvesting`);
                }
            }

            // Update animation mixer
            if (avatar.userData.mixer) {
                if (avatar.userData.isMoving) {
                    // Play walk animation when moving (2.5x speed like main player)
                    avatar.userData.mixer.update((deltaTime / 1000) * 2.5);
                } else {
                    // Idle: freeze on first frame
                    avatar.userData.mixer.setTime(0);
                }
            }
        });
    }

    updateCameraAndLighting() {
        // Update camera to follow player with zoom
        const baseCameraOffset = new THREE.Vector3(0, 12, 8);
        const zoomedOffset = baseCameraOffset.multiplyScalar(this.gameState.cameraZoom);
        this.gameState.cameraTargetPosition.copy(this.playerObject.position).add(zoomedOffset);
        this.camera.position.lerp(this.gameState.cameraTargetPosition, 0.8);
        this.camera.lookAt(this.playerObject.position);
    }

    runPeriodicChecks(now) {
        if (now - this.gameState.lastChunkUpdateTime > this.chunkUpdateInterval) {
            if (this.chunkManager.updatePlayerChunk(this.playerObject.position.x, this.playerObject.position.z)) {
                // If chunk changed, notify server
                const { clientId, currentPlayerChunkX, currentPlayerChunkZ, lastChunkX, lastChunkZ } = this.gameState;
                this.networkManager.sendMessage('chunk_update', {
                    clientId,
                    newChunkId: `chunk_${currentPlayerChunkX},${currentPlayerChunkZ}`,
                    lastChunkId: `chunk_${lastChunkX},${lastChunkZ}`
                });
                ui.updateStatus(`Player moved to chunk (${currentPlayerChunkX}, ${currentPlayerChunkZ})`);
                this.checkProximityToObjects(); // Check proximity when entering new chunk
            }
            this.gameState.lastChunkUpdateTime = now;
        }

        

        if (now - this.gameState.lastPeerCheckTime > this.peerCheckInterval) {
            this.checkAndReconnectPeers();
            this.gameState.lastPeerCheckTime = now;
        }
    }

    // Check if player has required tool in inventory
    hasRequiredTool(objectType) {
        // Check if it's a log type (ends with _log or is just "log")
        const isLog = objectType.endsWith('_log') || objectType === 'log';

        // Define tool requirements for each object type
        const toolRequirements = {
            // Trees require axe
            'oak': 'axe',
            'fir': 'axe',
            'pine': 'axe',
            'cypress': 'axe',
            // Rocks require pickaxe
            'limestone': 'pickaxe',
            'sandstone': 'pickaxe',
            // Structures require hammer
            'construction': 'hammer',
            'foundation': 'hammer',
            'foundationcorner': 'hammer',
            'foundationroundcorner': 'hammer'
        };

        // All logs require saw (for proximity display, but buttons will check separately)
        let requiredTool = toolRequirements[objectType];
        if (!requiredTool && isLog) {
            requiredTool = 'saw';
        }

        if (!requiredTool) {
            // No tool required for this object type
            return { hasRequiredTool: true, requiredTool: null, reason: null };
        }

        // Check inventory for the required tool with durability > 0
        const tool = this.gameState.inventory.items.find(item =>
            item.type === requiredTool && item.durability > 0
        );

        if (tool) {
            return { hasRequiredTool: true, requiredTool, reason: null };
        } else {
            // Check if they have the tool but it's broken
            const brokenTool = this.gameState.inventory.items.find(item => item.type === requiredTool);
            if (brokenTool) {
                return {
                    hasRequiredTool: false,
                    requiredTool,
                    reason: `${requiredTool} is broken (0 durability)`
                };
            } else {
                return {
                    hasRequiredTool: false,
                    requiredTool: null,
                    reason: `Requires ${requiredTool}`
                };
            }
        }
    }

    hasToolWithDurability(toolType) {
        // Check if player has the specified tool with durability > 0
        const tool = this.gameState.inventory.items.find(item =>
            item.type === toolType && item.durability > 0
        );
        return !!tool; // Return true if tool exists, false otherwise
    }

    getFoundationBounds(foundationObject) {
        const box = new THREE.Box3().setFromObject(foundationObject);
        const size = new THREE.Vector3();
        box.getSize(size);

        return {
            width: size.x,
            height: size.y,
            depth: size.z,
            topY: foundationObject.position.y + (size.y / 2),
            bottomY: foundationObject.position.y - (size.y / 2)
        };
    }

    checkStructureCollision(position) {
        // Check collision with construction sites and foundations
        const { chunkSize } = TERRAIN_CONFIG.TERRAIN;
        const playerChunkX = Math.floor(position.x / chunkSize);
        const playerChunkZ = Math.floor(position.z / chunkSize);

        // Check 3x3 grid around player
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                const chunkKey = `${playerChunkX + dx},${playerChunkZ + dz}`;
                const objects = this.terrainRenderer.chunkTrees.get(chunkKey);

                if (objects) {
                    for (const obj of objects) {
                        // Check if it's a construction site or foundation
                        const isConstructionSite = obj.userData.isConstructionSite || obj.userData.modelType === 'construction';
                        const isFoundation = obj.userData.modelType === 'foundation' ||
                                           obj.userData.modelType === 'foundationcorner' ||
                                           obj.userData.modelType === 'foundationroundcorner';

                        if (isConstructionSite) {
                            // Construction sites block movement
                            const dx = position.x - obj.position.x;
                            const dz = position.z - obj.position.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);

                            if (distance < 0.6) {
                                return { hasCollision: true };
                            }
                        } else if (isFoundation) {
                            // Foundations allow step-up
                            const bounds = this.getFoundationBounds(obj);
                            const dx = position.x - obj.position.x;
                            const dz = position.z - obj.position.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            const collisionRadius = Math.max(bounds.width, bounds.depth) / 2;

                            if (distance < collisionRadius) {
                                return {
                                    hasCollision: true,
                                    objectHeight: bounds.topY,
                                    object: obj,
                                    bounds: bounds
                                };
                            }
                        }
                    }
                }
            }
        }

        return { hasCollision: false };
    }

    getGroundHeightAt(x, z) {
        const testPosition = new THREE.Vector3(x, 0, z);
        const collision = this.checkStructureCollision(testPosition);

        if (collision.hasCollision && collision.objectHeight) {
            return collision.objectHeight;
        }

        return this.terrainRenderer.getHeightFast(x, z);
    }

    checkProximityToObjects() {
        const { chunkSize } = TERRAIN_CONFIG.TERRAIN;
        const playerChunkX = Math.floor(this.playerObject.position.x / chunkSize);
        const playerChunkZ = Math.floor(this.playerObject.position.z / chunkSize);
        let closestObject = null;
        let closestDistance = Infinity;

        // Check a 3x3 grid of chunks around the player
        for (let x = playerChunkX - 1; x <= playerChunkX + 1; x++) {
            for (let z = playerChunkZ - 1; z <= playerChunkZ + 1; z++) {
                const chunkKey = `${x},${z}`;
                const objectsInChunk = this.terrainRenderer.chunkTrees.get(chunkKey) || [];

                for (const object of objectsInChunk) {
                    if (object.visible) {
                        // Calculate horizontal distance only (ignore Y-axis)
                        const dx = this.playerObject.position.x - object.position.x;
                        const dz = this.playerObject.position.z - object.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        // Structures (construction sites and foundations) need larger radius
                        const isStructure = object.userData.isConstructionSite ||
                                          object.userData.modelType === 'construction' ||
                                          object.userData.modelType === 'foundation' ||
                                          object.userData.modelType === 'foundationcorner' ||
                                          object.userData.modelType === 'foundationroundcorner';
                        const maxDistance = isStructure ? 1.2 : 0.6;

                        if (distance < closestDistance && distance <= maxDistance) {
                            closestDistance = distance;
                            closestObject = object;
                        }
                    }
                }
            }
        }

        if (closestObject) { // Already filtered by radius above
            this.gameState.nearestObject = {
                id: closestObject.userData.objectId,
                name: closestObject.userData.modelType,
                position: closestObject.position.clone(),
                chunkKey: closestObject.userData.chunkKey,
                quality: closestObject.userData.quality,
                scale: closestObject.userData.originalScale,
                remainingResources: closestObject.userData.remainingResources,
                totalResources: closestObject.userData.totalResources
            };
            this.gameState.nearestObjectDistance = closestDistance;

            // Check if player has required tool
            const toolCheck = this.hasRequiredTool(this.gameState.nearestObject.name);
            this.gameState.nearestObject.toolCheck = toolCheck;
        } else {
            this.gameState.nearestObject = null;
            this.gameState.nearestObjectDistance = Infinity;
        }

        // Check for nearest construction site and crate
        let closestConstructionSite = null;
        let closestConstructionDistance = Infinity;
        let closestCrate = null;
        let closestCrateDistance = Infinity;

        for (let x = playerChunkX - 1; x <= playerChunkX + 1; x++) {
            for (let z = playerChunkZ - 1; z <= playerChunkZ + 1; z++) {
                const chunkKey = `${x},${z}`;
                const objectsInChunk = this.terrainRenderer.chunkTrees.get(chunkKey) || [];

                for (const object of objectsInChunk) {
                    if (!object.visible) continue;

                    // Calculate horizontal distance only (ignore Y-axis)
                    const dx = this.playerObject.position.x - object.position.x;
                    const dz = this.playerObject.position.z - object.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (object.userData.isConstructionSite) {
                        if (distance < closestConstructionDistance) {
                            closestConstructionDistance = distance;
                            closestConstructionSite = object;
                        }
                    } else if (object.userData.modelType === 'crate') {
                        if (distance < closestCrateDistance) {
                            closestCrateDistance = distance;
                            closestCrate = object;
                        }
                    }
                }
            }
        }

        // Determine which is closest (construction site or crate) - closest wins
        const proximityThreshold = 1.2;
        if (closestConstructionSite && closestConstructionDistance <= proximityThreshold &&
            closestConstructionDistance <= closestCrateDistance) {
            // Construction site is closer (or equal)
            this.gameState.nearestConstructionSite = closestConstructionSite;
            this.gameState.nearestConstructionSiteDistance = closestConstructionDistance;
            this.gameState.nearestCrate = null;
            this.gameState.nearestCrateDistance = Infinity;
        } else if (closestCrate && closestCrateDistance <= proximityThreshold &&
                   closestCrateDistance < closestConstructionDistance) {
            // Crate is closer
            this.gameState.nearestCrate = closestCrate;
            this.gameState.nearestCrateDistance = closestCrateDistance;
            this.gameState.nearestConstructionSite = null;
            this.gameState.nearestConstructionSiteDistance = Infinity;
        } else {
            // Neither is close enough
            this.gameState.nearestConstructionSite = null;
            this.gameState.nearestConstructionSiteDistance = Infinity;
            this.gameState.nearestCrate = null;
            this.gameState.nearestCrateDistance = Infinity;
        }

        // Check if player has axe and saw
        const hasAxe = this.hasToolWithDurability('axe');
        const hasSaw = this.hasToolWithDurability('saw');

        // Check if cooldown is active
        const isOnCooldown = this.gameState.harvestCooldown && this.gameState.harvestCooldown.endTime > Date.now();

        ui.updateNearestObject(
            this.gameState.nearestObject ? this.gameState.nearestObject.name : null,
            this.gameState.nearestObject ? this.gameState.nearestObject.toolCheck : null,
            this.gameState.nearestObject ? this.gameState.nearestObject.quality : null,
            this.gameState.nearestObject ? this.gameState.nearestObject.remainingResources : null,
            this.gameState.nearestObject ? this.gameState.nearestObject.totalResources : null
        );
        ui.updateButtonStates(this.gameState.isInChunk, this.gameState.nearestObject, hasAxe, hasSaw, isOnCooldown, this.gameState.nearestConstructionSite, this.gameState.isMoving, this.gameState.nearestCrate);
    }

    checkAndReconnectPeers() {
        this.networkManager.peers.forEach((peer, peerId) => {
            if (peer.state === 'disconnected' || peer.state === 'failed') {
                if (this.gameState.clientId < peerId) { // Initiation rule
                    ui.updateStatus(`Attempting P2P reconnect to ${peerId}...`);
                    this.initiateP2PConnection(peerId);
                }
            }
        });
    }
}

// ==========================================
// INITIALIZATION
// ==========================================

// Wait for models to load before starting game
modelManager.loadAllModels().then(() => {
    console.log('Models loaded, starting game...');
    const game = new MultiplayerGame();
    game.start();
}).catch(error => {
    console.error('Failed to load models:', error);
    alert('Failed to load game models. Please refresh the page.');
});


================================================================================
FILE 5/11: public/objects.js
Location: C:\Users\colli\Desktop\test horses\horses\public\objects.js
Lines: 598
================================================================================

// File: public/objects.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\objects.js

import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { BlobShadow } from './blobshadow.js';

// ==========================================
// CONFIGURATION
// ==========================================
// ADDING NEW STRUCTURES - STEP 1: MODEL REGISTRATION
// To add a new buildable structure, add its model definition here.
// Structure models need:
// - path: Path to the .glb model file in ./models/
// - heightRange/scaleRange/density: Set to 0 for structures (not randomly placed)
// - category: 'structure' for buildable items
//
// Example for a new structure:
//   mystructure: {
//       path: './models/mystructure.glb',
//       heightRange: { min: 0, max: 0 },
//       scaleRange: { min: 0, max: 0 },
//       density: 0,
//       category: 'structure'
//   }

const MODEL_CONFIG = {
    oak: {
        path: './models/oak.glb',
        heightRange: { min: 1.3, max: 2.0 },
        scaleRange: { min: 0.05, max: 0.15 },
        density: 1.0,
        category: 'vegetation'
    },
    fir: {
        path: './models/fir.glb',
        heightRange: { min: 1.9, max: 3.0 },
        scaleRange: { min: 0.05, max: 0.15 },
        density: 1.0,
        category: 'vegetation'
    },
    pine: {
        path: './models/pine.glb',
        heightRange: { min: 2.8, max: 4.5 },
        scaleRange: { min: 0.05, max: 0.1 },
        density: 1.0,
        category: 'vegetation'
    },
    cypress: {
        path: './models/cypress.glb',
        heightRange: { min: 1.3, max: 2.0 },
        scaleRange: { min: 0.015, max: 0.055 },
        density: 0.3,
        category: 'vegetation'
    },
    log: {
        path: './models/log.glb',
        heightRange: { min: 1.2, max: 1.28 },
        scaleRange: { min: 0.02, max: 0.05 },
        density: 0,  // Not naturally spawned - use tree-specific logs instead
        category: 'vegetation'
    },
    oak_log: {
        path: './models/log.glb',
        heightRange: { min: 1.2, max: 1.28 },
        scaleRange: { min: 0.02, max: 0.05 },
        density: 0.075,  // 1/4 of original log density (0.3 / 4)
        category: 'vegetation'
    },
    pine_log: {
        path: './models/log.glb',
        heightRange: { min: 1.2, max: 1.28 },
        scaleRange: { min: 0.02, max: 0.05 },
        density: 0.075,  // 1/4 of original log density (0.3 / 4)
        category: 'vegetation'
    },
    fir_log: {
        path: './models/log.glb',
        heightRange: { min: 1.2, max: 1.28 },
        scaleRange: { min: 0.02, max: 0.05 },
        density: 0.075,  // 1/4 of original log density (0.3 / 4)
        category: 'vegetation'
    },
    cypress_log: {
        path: './models/log.glb',
        heightRange: { min: 1.2, max: 1.28 },
        scaleRange: { min: 0.02, max: 0.05 },
        density: 0.075,  // 1/4 of original log density (0.3 / 4)
        category: 'vegetation'
    },
    limestone: {
        path: './models/limestone.glb',
        heightRange: { min: 1.04, max: 5.0 },
        scaleRange: { min: 0.05, max: 0.2 },
        density: 0.3,
        category: 'prop'
    },
    sandstone: {
        path: './models/sandstone.glb',
        heightRange: { min: 4.04, max: 7.0 },
        scaleRange: { min: 0.05, max: 0.2 },
        density: 0.3,
        category: 'prop'
    },
    man: {
        path: './models/man.glb',
        heightRange: { min: 0, max: 0 },  // Not used for world generation
        scaleRange: { min: 0, max: 0 },   // Not used for world generation
        density: 0,                        // Not used for world generation
        category: 'player'
    },
    construction: {
        path: './models/construction.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    },
    foundation: {
        path: './models/foundation.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    },
    foundationcorner: {
        path: './models/foundationcorner.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    },
    foundationroundcorner: {
        path: './models/foundationroundcorner.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    },
    crate: {
        path: './models/crate.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    },
    outpost: {
        path: './models/outpost.glb',
        heightRange: { min: 0, max: 0 },
        scaleRange: { min: 0, max: 0 },
        density: 0,
        category: 'structure'
    }
};

// ==========================================
// MODEL MANAGER CLASS
// ==========================================

class ModelManager {
    constructor() {
        this.models = new Map();
        this.gltfData = new Map(); // Store full GLTF objects (for animations, etc.)
        this.loader = new GLTFLoader();
        this.loadingPromises = new Map();
        this.allModelsPromise = null; // Cache the loadAllModels promise
    }

    /**
     * Load all models defined in configuration
     * @returns {Promise} Resolves when all models are loaded
     */
    async loadAllModels() {
        // Return cached promise if already loading/loaded
        if (this.allModelsPromise) {
            return this.allModelsPromise;
        }

        this.allModelsPromise = (async () => {
            const loadPromises = Object.entries(MODEL_CONFIG).map(([name, config]) =>
                this.loadModel(name, config.path)
            );

            try {
                await Promise.all(loadPromises);
                console.log('All models loaded successfully');
            } catch (error) {
                console.error('Error loading models:', error);
                throw error;
            }
        })();

        return this.allModelsPromise;
    }

    /**
     * Load a single model
     * @param {string} name - Model identifier
     * @param {string} path - Path to model file
     * @returns {Promise} Resolves with loaded model
     */
    loadModel(name, path) {
        // Return existing promise if already loading
        if (this.loadingPromises.has(name)) {
            return this.loadingPromises.get(name);
        }

        const promise = new Promise((resolve, reject) => {
            this.loader.load(
                path,
                (gltf) => {
                    this.models.set(name, gltf.scene);
                    this.gltfData.set(name, gltf); // Store full GLTF for animations
                    console.log(`${name} model loaded successfully`);
                    resolve(gltf.scene);
                },
                undefined,
                (error) => {
                    console.error(`Error loading ${name} model:`, error);
                    reject(error);
                }
            );
        });

        this.loadingPromises.set(name, promise);
        return promise;
    }

    /**
     * Get a loaded model
     * @param {string} name - Model identifier
     * @returns {THREE.Object3D|null} Model or null if not loaded
     */
    getModel(name) {
        return this.models.get(name) || null;
    }

    /**
     * Get full GLTF data (includes animations, etc.)
     * @param {string} name - Model identifier
     * @returns {Object|null} GLTF object or null if not loaded
     */
    getGLTF(name) {
        return this.gltfData.get(name) || null;
    }

    /**
     * Check if a model is loaded
     * @param {string} name - Model identifier
     * @returns {boolean} True if model is loaded
     */
    isModelLoaded(name) {
        return this.models.has(name);
    }
}

// ==========================================
// SEEDED RANDOM GENERATOR
// ==========================================

class SeededRandom {
    constructor(seed) {
        this.seed = seed;
    }

    // Mulberry32 PRNG
    next() {
        let t = this.seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }

    // Generate float in range
    range(min, max) {
        return min + this.next() * (max - min);
    }

    // Generate integer in range
    intRange(min, max) {
        return Math.floor(this.range(min, max + 1));
    }
}

// ==========================================
// OBJECT PLACEMENT SYSTEM
// ==========================================

class ObjectPlacer {
    constructor(modelManager) {
        this.modelManager = modelManager;
    }

    /**
     * Fix transparency issues for Three.js materials
     * @param {THREE.Material} material - Material to fix
     */
    fixTransparency(material) {
        if (material.transparent) {
            material.transparent = false;
            material.alphaTest = 0.5;
            material.depthWrite = true;
            material.side = THREE.DoubleSide;
            material.needsUpdate = true;
        }
    }

    /**
     * Create an instance of a model at specified position
     * @param {string} modelType - Type of model to place
     * @param {Object} position - Position {x, y, z}
     * @param {number} scale - Scale factor
     * @param {number} rotationY - Y-axis rotation in radians
     * @param {THREE.Scene} scene - Scene for blob shadow (optional)
     * @returns {THREE.Object3D|null} Created instance or null
     */
    createInstance(modelType, position, scale, rotationY, scene = null) {
        const model = this.modelManager.getModel(modelType);
        if (!model) {
            console.warn(`Model ${modelType} not loaded`);
            return null;
        }

        const instance = model.clone();
        instance.name = modelType;
        instance.userData = {
            modelType,
            originalScale: scale

        };


            //console.log('Created instance, userData:', instance.userData); // Add this


        instance.position.copy(position);
        instance.scale.setScalar(scale);
        instance.rotation.y = rotationY;

        // Apply material fixes
        instance.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                if (child.material) {
                    this.fixTransparency(child.material);
                }
            }
        });

        // Add blob shadow based on object type (if scene is provided)
        if (scene) {
            const shadowSizes = {
                'oak': 1.0,
                'pine': 1.0,
                'cypress': 1.0,
                'fir': 1.0,
                'log': 0.75,
                'limestone': 0.5,
                'sandstone': 0.5,
                'foundation': 1.5,
                'foundationcorner': 1.5,
                'foundationroundcorner': 1.5,
                'construction': 1.0,
                'outpost': 0.09  // Smaller than foundation (40% reduction applied)
            };
            const shadowSize = shadowSizes[modelType] || 0.75;

            // Create and attach blob shadow to the instance (darker opacity: 0.5)
            const shadow = new BlobShadow(instance, scene, shadowSize, 0.5);
            instance.userData.blobShadow = shadow;
        }

        return instance;
    }

    /**
     * Generate objects for a chunk
     * @param {Object} params - Generation parameters
     * @returns {Array} Array of created objects
     */
    generateChunkObjects(params) {
        const {
            scene,
            heightCalculator,
            worldX,
            worldZ,
            seed,
            chunkSize = 50,
            objectsPerType = 500,
            removedObjectIds = null // Pass in removed objects to skip creation
        } = params;

        const objects = [];
        const halfSize = chunkSize / 2;

        // Create chunk-specific seed for deterministic generation
        const gridX = Math.floor(worldX / chunkSize);
        const gridZ = Math.floor(worldZ / chunkSize);
        const chunkSeed = seed + gridX * 73856093 + gridZ * 19349663;

        let totalGenerated = 0;
        let totalSkipped = 0;

        // Process each model type
        Object.entries(MODEL_CONFIG).forEach(([modelType, config], index) => {
            // Skip player models (they're not world objects)
            if (config.category === 'player') {
                return;
            }

            // Create unique seed for this model type within the chunk
            const typeSeed = chunkSeed + index * 31337;
            const rng = new SeededRandom(typeSeed);

            const numObjects = Math.floor(objectsPerType * config.density);

            for (let i = 0; i < numObjects; i++) {
                // Generate objectId first
                const objectId = `${gridX},${gridZ}_${modelType}_${i}`;

                // Generate position within chunk (ALWAYS call RNG to maintain sequence)
                const offsetX = rng.range(-halfSize, halfSize);
                const offsetZ = rng.range(-halfSize, halfSize);
                const posX = worldX + offsetX;
                const posZ = worldZ + offsetZ;

                // Check height constraints
                const terrainHeight = heightCalculator.calculateHeight(posX, posZ);
                if (terrainHeight >= config.heightRange.min &&
                    terrainHeight <= config.heightRange.max) {

                    // Generate scale, rotation, and quality (ALWAYS call RNG to maintain sequence)
                    const scale = rng.range(config.scaleRange.min, config.scaleRange.max);
                    const rotation = rng.next() * Math.PI * 2;
                    let quality = Math.floor(rng.range(1, 101)); // Quality between 1-100

                    // Logs should have low quality (<25) when naturally spawned
                    if (modelType === 'log' || modelType.endsWith('_log')) {
                        quality = Math.floor(rng.range(1, 25));
                    }

                    // NOW check if this object was removed by a player
                    if (removedObjectIds && removedObjectIds.has(objectId)) {
                        totalSkipped++;
                        continue;
                    }

                    // Create and place object
                    const position = new THREE.Vector3(posX, terrainHeight + 0.1, posZ);
                    const instance = this.createInstance(modelType, position, scale, rotation, scene);

if (instance) {
    instance.userData.objectId = objectId;
    instance.userData.chunkKey = `${gridX},${gridZ}`;
    instance.userData.quality = quality;

    // Add resources for logs (all log types: log, oak_log, pine_log, etc.)
    if (modelType === 'log' || modelType.endsWith('_log')) {
        const totalResources = Math.floor(scale * 100);
        instance.userData.totalResources = totalResources;
        instance.userData.remainingResources = totalResources;
    }

    // Add resources for rocks (limestone, sandstone)
    if (modelType === 'limestone' || modelType === 'sandstone') {
        const totalResources = Math.floor(scale * 100);
        instance.userData.totalResources = totalResources;
        instance.userData.remainingResources = totalResources;
    }

    scene.add(instance);
    objects.push(instance);
    totalGenerated++;

    // Update blob shadow position to terrain with normal alignment and left offset
    if (instance.userData.blobShadow) {
        // Create a fake light position to the right to cast shadow to the left
        const fakeLight = new THREE.Vector3(posX + 100, 20, posZ);
        instance.userData.blobShadow.update(
            (x, z) => heightCalculator.calculateHeight(x, z),
            fakeLight, // Light to the right = shadow to the left (0.1 units)
            (x, z) => {
                const normal = heightCalculator.calculateNormal(x, z);
                return new THREE.Vector3(normal.x, normal.y, normal.z);
            }
        );
    }
}
                }
            }
        });

        return objects;
    }

    /**
     * Remove and dispose of objects
     * @param {THREE.Scene} scene - Scene to remove from
     * @param {Array} objects - Objects to remove
     */
    removeObjects(scene, objects) {
        objects.forEach(obj => {
            // Dispose blob shadow if it exists
            if (obj.userData.blobShadow) {
                obj.userData.blobShadow.dispose();
                obj.userData.blobShadow = null;
            }

            scene.remove(obj);
            obj.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        });
        console.log(`Removed ${objects.length} objects`);
    }


findObjectById(scene, objectId) {
    let foundObject = null;
    scene.traverse((object) => {
        if (object.userData && object.userData.objectId === objectId) {
            foundObject = object;
        }
    });
    return foundObject;
}


}

// ==========================================
// SINGLETON INSTANCES & EXPORTS
// ==========================================

const modelManager = new ModelManager();
const objectPlacer = new ObjectPlacer(modelManager);

// Initialize models on module load
modelManager.loadAllModels();






// Legacy function wrappers for compatibility
function addTree(scene, heightCalculator, position, modelType = 'oak', scale = 0.2, rotationY = 0) {
    const terrainHeight = heightCalculator.calculateHeight(position.x, position.z);
    const pos = new THREE.Vector3(position.x, terrainHeight + 0.1, position.z);
    const instance = objectPlacer.createInstance(modelType, pos, scale, rotationY);
    
    if (instance) {
        scene.add(instance);
    }
    return instance;
}

function addTreesToChunk(scene, heightCalculator, worldX, worldZ, seed, chunkSize = 50, numTrees = 500, removedObjectIds = null) {
    return objectPlacer.generateChunkObjects({
        scene,
        heightCalculator,
        worldX,
        worldZ,
        seed,
        chunkSize,
        objectsPerType: numTrees,
        removedObjectIds
    });
}

function removeTrees(scene, trees) {
    objectPlacer.removeObjects(scene, trees);
}

// Export both legacy functions and new system
export {
    // Legacy compatibility
    addTree,
    addTreesToChunk,
    removeTrees,

    
    // New system
    modelManager,
    objectPlacer,
    ModelManager,
    ObjectPlacer,
    SeededRandom,
    MODEL_CONFIG
};


================================================================================
FILE 6/11: public/terrain.js
Location: C:\Users\colli\Desktop\test horses\horses\public\terrain.js
Lines: 1829
================================================================================

// File: public/terrain.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\terrain.js

import * as THREE from 'three';
import { addTreesToChunk, removeTrees } from './objects.js';



export const roundCoord = (coord) => Math.round(coord * FLOAT_PRECISION) / FLOAT_PRECISION;

// --- CONFIG ---
export const CONFIG = Object.freeze({
    TERRAIN: {
        chunkSize: 50,
        segments: 100,
        renderDistance: 1,
        seed: 12345, // Centralized seed
        // NEW: Terrain generation parameters
        noise: {
            baseOctaves: 3,
            baseAmplitude: 1,
            baseFrequency: 0.02,
            mountainOctaves: 4,
            mountainAmplitude: 1,
            mountainFrequency: 0.04,
            mountainScale: 40,
            maskFrequency: 0.006,
            jaggedFrequency1: 0.8,
            jaggedAmplitude1: 1.2,
            jaggedFrequency2: 1.6,
            jaggedAmplitude2: 0.6,
            jaggedNoiseOffset1: 900,
            jaggedNoiseOffset2: 901
        }
    },
    PERFORMANCE: {
        updateThrottle: 100,
        maxCacheSize: 20000
    },
    GRAPHICS: {
        textureSize: 256,
        textureRepeat: 0.25
    },
    CAMERA: {
        offset: { x: 0, y: 35, z: -20 }
    }
});

// --- UTILITIES ---
export const Utilities = {
    mulberry32(seed) {
        return function() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    },

    limitCacheSize(cache, maxSize) {
        if (cache.size > maxSize) {
            const entriesToRemove = Math.floor(cache.size * 0.25);
            const keysToDelete = Array.from(cache.keys()).slice(0, entriesToRemove);
            keysToDelete.forEach(key => cache.delete(key));
            //console.log(`Cache cleanup: removed ${entriesToRemove} entries, ${cache.size} remaining`);
        }
    },

    getChunkRNG(seed, chunkX, chunkZ) {
        const chunkSeed = seed + chunkX * 73856093 + chunkZ * 19349663;
        return Utilities.mulberry32(chunkSeed);
    },

    logError(message, error) {
        console.error(`${message}:`, error);
    }
};

// --- OPTIMIZED PERLIN ---
export class OptimizedPerlin {
    constructor(seed = CONFIG.TERRAIN.seed) {
        this.p = new Array(512);
        const perm = [];
        const rng = Utilities.mulberry32(seed);
        
        for (let i = 0; i < 256; i++) perm[i] = i;
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [perm[i], perm[j]] = [perm[j], perm[i]];
        }
        for (let i = 0; i < 256; i++) {
            this.p[i] = this.p[i + 256] = perm[i];
        }
    }

    fade(t) { 
        return t * t * t * (t * (t * 6 - 15) + 10); 
    }

    lerp(t, a, b) { 
        return a + t * (b - a); 
    }

    grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    noise(x, y, z) {
        let X = Math.floor(x) & 255;
        let Y = Math.floor(y) & 255;
        let Z = Math.floor(z) & 255;
        
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        
        let u = this.fade(x);
        let v = this.fade(y);
        let w = this.fade(z);
        
        let A = this.p[X] + Y;
        let AA = this.p[A] + Z;
        let AB = this.p[A + 1] + Z;
        let B = this.p[X + 1] + Y;
        let BA = this.p[B] + Z;
        let BB = this.p[B + 1] + Z;

        return this.lerp(w,
            this.lerp(v,
                this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
                this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))
            ),
            this.lerp(v,
                this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
            )
        );
    }
}

// --- HEIGHT CALCULATOR ---
// Increased precision for better edge matching
const FLOAT_PRECISION = 1000000.0;

export class HeightCalculator {
    constructor(seed = CONFIG.TERRAIN.seed) {
        this.perlin = new OptimizedPerlin(seed);
        this.heightCache = new Map();
        this.MAX_CACHE_SIZE = CONFIG.PERFORMANCE.maxCacheSize;
    }

    clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
    }

    calculateHeight(x, z) {
    // ⚠️ ============================================================================
    // ⚠️ CRITICAL SYNCHRONIZATION WARNING - TERRAIN GENERATION CODE
    // ⚠️ ============================================================================
    // ⚠️ This terrain generation algorithm is DUPLICATED in THREE locations:
    // ⚠️
    // ⚠️   1. HERE: terrain.js HeightCalculator.calculateHeight() (MAIN THREAD)
    // ⚠️   2. terrain.js worker calculateHeight() (WEB WORKER - line ~611)
    // ⚠️   3. WaterRenderer.js calculateTerrainHeight() (GPU SHADER - lines ~107 & ~348)
    // ⚠️
    // ⚠️ ANY CHANGES TO THIS ALGORITHM MUST BE MANUALLY REPLICATED TO ALL 3 LOCATIONS!
    // ⚠️
    // ⚠️ Failure to synchronize will cause:
    // ⚠️   - Water/terrain height mismatches
    // ⚠️   - Visual seams between chunks
    // ⚠️   - Incorrect collision detection
    // ⚠️   - Physics glitches
    // ⚠️
    // ⚠️ Parameters must match exactly:
    // ⚠️   - Perlin noise octaves, frequencies, amplitudes
    // ⚠️   - Terrain floor compression (lines 209-215)
    // ⚠️   - Ocean generation (lines 217-251)
    // ⚠️   - All magic numbers and constants
    // ⚠️ ============================================================================

    const rx = roundCoord(x);
    const rz = roundCoord(z);

    const key = `${rx},${rz}`;
    if (this.heightCache.has(key)) {
        return this.heightCache.get(key);
    }

    // Use CONFIG parameters
    const noiseConfig = CONFIG.TERRAIN.noise;
    
    let base = 0;
    let amplitude = noiseConfig.baseAmplitude;
    let frequency = noiseConfig.baseFrequency;
    
    for (let octave = 0; octave < noiseConfig.baseOctaves; octave++) {
        base += this.perlin.noise(rx * frequency, rz * frequency, 10 + octave * 7) * amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }

    let maskRaw = this.perlin.noise(rx * noiseConfig.maskFrequency, rz * noiseConfig.maskFrequency, 400);
    let mask = Math.pow((maskRaw + 1) * 0.5, 3);

    let mountain = 0;
    amplitude = noiseConfig.mountainAmplitude;
    frequency = noiseConfig.mountainFrequency;
    
    for (let octave = 0; octave < noiseConfig.mountainOctaves; octave++) {
        mountain += Math.abs(this.perlin.noise(rx * frequency, rz * frequency, 500 + octave * 11)) * amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }
    mountain *= noiseConfig.mountainScale * mask;
    
    let heightBeforeJagged = base + mountain;


    const elevNorm = this.clamp((heightBeforeJagged + 2) / 25, 0, 1);
    let jaggedScale = heightBeforeJagged < 1.5 ? Math.max(0.1, (heightBeforeJagged + 0.5) / 10.0) : 1.0;
    let jagged = this.perlin.noise(rx * noiseConfig.jaggedFrequency1, rz * noiseConfig.jaggedFrequency1, noiseConfig.jaggedNoiseOffset1) * noiseConfig.jaggedAmplitude1 * elevNorm * jaggedScale +
             this.perlin.noise(rx * noiseConfig.jaggedFrequency2, rz * noiseConfig.jaggedFrequency2, noiseConfig.jaggedNoiseOffset2) * noiseConfig.jaggedAmplitude2 * elevNorm * jaggedScale;


    let height = heightBeforeJagged + jagged;

    // ========== TERRAIN FLOOR START (DELETE FROM HERE TO REMOVE FLOOR) ==========
    // Exponential compression floor to prevent water puddles while preserving variation
    // Starts compressing at 1.9, asymptotically approaches 1.3 minimum
    if (height < 1.9) {
        const belowAmount = 1.9 - height;
        const maxCompression = 0.6; // (1.9 - 1.3) maximum drop
        const compressed = maxCompression * (1 - Math.exp(-belowAmount * 0.5));
        height = 1.9 - compressed; // Approaches 1.3 but never quite reaches it
    }
    // ========== TERRAIN FLOOR END (DELETE TO HERE TO REMOVE FLOOR) ==========

    // ========== OCEAN GENERATION START (DELETE FROM HERE TO REMOVE OCEAN) ==========
    // Create ocean by lowering terrain smoothly and randomly
    // Coastline position varies between x=0 and x=20 based on z position
    const coastlineThreshold = 10 + this.perlin.noise(rz * 0.01, 777, 0) * 10;
    const transitionWidth = 8; // Units over which to blend from land to ocean

    // Calculate distance from threshold (positive = ocean side, negative = land side)
    const distanceFromThreshold = rx - coastlineThreshold;

    // Create smooth transition using smoothstep function
    // t goes from 0 (before transition) to 1 (after transition)
    const t = Math.max(0, Math.min(1, (distanceFromThreshold + transitionWidth) / (transitionWidth * 2)));
    const smoothTransition = t * t * (3 - 2 * t); // Smoothstep S-curve

    if (smoothTransition > 0) {
        const oceanDistance = Math.max(0, distanceFromThreshold);

        // Reduce noise intensity as distance from coast increases (smoother deep ocean)
        const noiseIntensity = 1 / (1 + oceanDistance * 0.05);

        // Add noise for varied coastline - intensity reduces with distance
        const coastlineNoise = this.perlin.noise(rx * 0.02, rz * 0.02, 999) * 5 * noiseIntensity;
        const adjustedDistance = Math.max(0, oceanDistance + coastlineNoise);

        // Gradually deepen as distance increases - depth noise also reduces with distance
        const depthNoise = this.perlin.noise(rx * 0.05, rz * 0.05, 888) * 2 * noiseIntensity;
        const depthFactor = (adjustedDistance * 0.5) + depthNoise;

        // Apply ocean effect gradually based on transition
        height -= depthFactor * smoothTransition;

        // Cap at ocean floor
        height = Math.max(height, -3);
    }
    // ========== OCEAN GENERATION END (DELETE TO HERE TO REMOVE OCEAN) ==========

    // ========== RIVER GENERATION START (DELETE FROM HERE TO REMOVE RIVER) ==========
    // Create rivers at random intervals along the Z-axis (every 100-300 units)
    // Rivers run parallel to the coast, perpendicular to ocean

    const riverSegmentSize = 200; // Average spacing between rivers
    const riverTransitionWidth = 8; // Units over which to blend
    const riverWidth = 10; // Distance from first bank to center (and center to far bank)

    // Determine which river segment we're in
    const riverSegment = Math.floor(rz / riverSegmentSize);

    // Use segment number to generate deterministic random values for this segment
    const segmentSeed = riverSegment * 73856093; // Large prime for good distribution
    const segmentRandom = Math.abs(Math.sin(segmentSeed) * 43758.5453123);
    const hasRiver = (segmentRandom % 1) > 0.3; // 70% chance of river in this segment

    if (hasRiver) {
        // Random offset within segment (0-100 range gives 100-300 spacing variability)
        const riverOffsetInSegment = ((segmentRandom * 7919) % 1) * 100; // Use different multiplier for offset
        const riverCenterZ = riverSegment * riverSegmentSize + riverOffsetInSegment + 10;

        // River meanders based on x position
        const riverMeanderOffset = this.perlin.noise(rx * 0.01, 666 + riverSegment, 0) * 10;
        const riverThreshold = riverCenterZ + riverMeanderOffset;

        // Calculate distance from river threshold
        const riverDistanceFromThreshold = rz - riverThreshold;

        // River occupies z = threshold to threshold + 20 (two 10-unit banks)
        if (riverDistanceFromThreshold >= -riverTransitionWidth && riverDistanceFromThreshold <= riverWidth * 2 + riverTransitionWidth) {
            let riverDepthFactor = 0;

            if (riverDistanceFromThreshold <= riverWidth) {
                // First bank (z = threshold to threshold + 10)
                const t = Math.max(0, Math.min(1, (riverDistanceFromThreshold + riverTransitionWidth) / (riverTransitionWidth * 2)));
                const smoothTransition = t * t * (3 - 2 * t);

                if (smoothTransition > 0) {
                    const riverDistance = Math.max(0, riverDistanceFromThreshold);
                    const noiseIntensity = 1 / (1 + riverDistance * 0.05);
                    const riverBankNoise = this.perlin.noise(rx * 0.02, rz * 0.02, 555) * 5 * noiseIntensity;
                    const adjustedRiverDistance = Math.max(0, riverDistance + riverBankNoise);
                    const riverDepthNoise = this.perlin.noise(rx * 0.05, rz * 0.05, 444) * 2 * noiseIntensity;
                    riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                }
            } else {
                // Second bank (z = threshold + 10 to threshold + 20)
                const reversedDistance = riverWidth * 2 - riverDistanceFromThreshold;
                const t = Math.max(0, Math.min(1, (reversedDistance + riverTransitionWidth) / (riverTransitionWidth * 2)));
                const smoothTransition = t * t * (3 - 2 * t);

                if (smoothTransition > 0) {
                    const riverDistance = Math.max(0, reversedDistance);
                    const noiseIntensity = 1 / (1 + riverDistance * 0.05);
                    const riverBankNoise = this.perlin.noise(rx * 0.02, rz * 0.02, 555) * 5 * noiseIntensity;
                    const adjustedRiverDistance = Math.max(0, riverDistance + riverBankNoise);
                    const riverDepthNoise = this.perlin.noise(rx * 0.05, rz * 0.05, 444) * 2 * noiseIntensity;
                    riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                }
            }

            // Apply river effect
            height -= riverDepthFactor;
            height = Math.max(height, -3);
        }
    }
    // ========== RIVER GENERATION END (DELETE TO HERE TO REMOVE RIVER) ==========

    this.heightCache.set(key, height);

    Utilities.limitCacheSize(this.heightCache, this.MAX_CACHE_SIZE);
    return height;
}

    calculateNormal(x, z, eps = 0.1) {
        const hL = this.calculateHeight(x - eps, z);
        const hR = this.calculateHeight(x + eps, z);
        const hD = this.calculateHeight(x, z - eps);
        const hU = this.calculateHeight(x, z + eps);

        const nx = hL - hR;
        const ny = 2 * eps;
        const nz = hD - hU;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
        if (len === 0) {
            return { x: 0, y: 1, z: 0 }; // Default upward normal
        }
        return { x: nx / len, y: ny / len, z: nz / len };
    }

    clearCache() {
        // Only clear cache when explicitly needed
        console.warn('Clearing height cache');
        this.heightCache.clear();
    }
}

// --- TERRAIN MATERIAL FACTORY ---
export class TerrainMaterialFactory {
   static createTerrainMaterial(textures) {
    const vertexShader = `
        varying float vHeight;
        varying float vSlope;
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vWorldPosition;

        void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            vUv = uv;
            vHeight = position.y;
            vNormal = normal;
            vSlope = 1.0 - dot(normal, vec3(0, 1, 0));
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const fragmentShader = `
        uniform vec3 uLightDir;
        uniform sampler2D uDirt;
        uniform sampler2D uGrass;
        uniform sampler2D uGrass2;
        uniform sampler2D uRock;
        uniform sampler2D uRock1;
        uniform sampler2D uRock2;
        uniform sampler2D uSnow;
        uniform sampler2D uSand;
        uniform sampler2D uSand2;
        uniform float uTextureRepeat;

        varying float vHeight;
        varying float vSlope;
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vWorldPosition;

        // Rotate UV coordinates by angle (in radians)
        vec2 rotateUV(vec2 uv, float angle) {
            float c = cos(angle);
            float s = sin(angle);
            mat2 rotationMatrix = mat2(c, -s, s, c);
            // Center rotation around 0.5
            vec2 centered = uv - 0.5;
            vec2 rotated = rotationMatrix * centered;
            return rotated + 0.5;
        }

        // Sample texture with multiple rotations and scales to break tiling
        vec3 sampleTextureMulti(sampler2D tex, vec2 worldPos, float baseRepeat) {
            // Sample 1: Normal
            vec2 uv1 = fract(worldPos * baseRepeat);
            vec3 sample1 = texture2D(tex, uv1).rgb;

            // Sample 2: Rotated 45 degrees, slightly smaller scale
            vec2 uv2 = fract(worldPos * baseRepeat * 0.87);
            uv2 = rotateUV(uv2, 0.785398); // 45 degrees
            vec3 sample2 = texture2D(tex, uv2).rgb;

            // Sample 3: Rotated 120 degrees, different scale
            vec2 uv3 = fract(worldPos * baseRepeat * 1.13);
            uv3 = rotateUV(uv3, 2.094395); // 120 degrees
            vec3 sample3 = texture2D(tex, uv3).rgb;

            // Blend samples with varying weights for natural variation
            // Use world position to create variation in blending
            float blendNoise = fract(sin(dot(worldPos, vec2(12.9898, 78.233))) * 43758.5453);

            // Weighted blend
            vec3 blended = sample1 * 0.5 + sample2 * 0.3 + sample3 * 0.2;

            // Add subtle variation based on position
            blended = mix(blended, sample2, blendNoise * 0.1);

            return blended;
        }

        void main() {
            // Use world position for texture coordinates to eliminate seams
            float repeat = uTextureRepeat;
            vec2 worldUv = fract(vWorldPosition.xz * repeat);

            // Simple textures (no tiling fix needed for varied surfaces)
            vec3 dirt = texture2D(uDirt, worldUv).rgb;
            vec3 rock = texture2D(uRock, worldUv).rgb;
            vec3 rock1 = texture2D(uRock1, worldUv).rgb;
            vec3 rock2 = texture2D(uRock2, worldUv).rgb;
            vec3 snow = texture2D(uSnow, worldUv).rgb;
            vec3 sand = texture2D(uSand, worldUv).rgb;
            vec3 sand2 = texture2D(uSand2, worldUv).rgb;

            // Multi-sample grass textures to break tiling pattern
            vec3 grass = sampleTextureMulti(uGrass, vWorldPosition.xz, repeat);
            vec3 grass2 = sampleTextureMulti(uGrass2, vWorldPosition.xz, repeat);

            // ========== NATURAL DIRT DISTRIBUTION SYSTEM ==========
            // Calculate environmental factors for realistic terrain

            // Sand/Dirt separation based on X position (x > 0 = sand, x < 0 = dirt)
            // Transition smoothly over 10 units centered at x = 0
            float sandDirtTransition = smoothstep(-5.0, 5.0, vWorldPosition.x);

            // Moisture simulation: Higher elevations with low slope retain moisture (darker grass)
            float moisture = smoothstep(1.5, 3.5, vHeight) * (1.0 - vSlope);

            // Wear patterns: Flat areas at lower elevations show more dirt (traffic/erosion)
            float wear = smoothstep(0.0, 0.1, vSlope) * smoothstep(2.0, 1.0, vHeight);

            // Multi-frequency noise for organic dirt patches
            float patchNoise1 = sin(vWorldPosition.x * 0.15) * cos(vWorldPosition.z * 0.15);
            float patchNoise2 = sin(vWorldPosition.x * 0.4) * cos(vWorldPosition.z * 0.4) * 0.5;
            float patchNoise3 = sin(vWorldPosition.x * 0.31) * cos(vWorldPosition.z * 0.29) * 0.3;
            float dirtNoise = patchNoise1 + patchNoise2 + patchNoise3;

            // Create irregular dirt patches (not regular grid)
            float irregularPatches = smoothstep(0.3, 0.7, dirtNoise);

            // Combine wear and patches for natural dirt exposure
            float dirtPatches = irregularPatches * wear * 0.7;

            // Slope-based dirt exposure (erosion on steep areas)
            float slopeExposure = smoothstep(0.15, 0.35, vSlope) * 0.5;

            // ========== HEIGHT-BASED TEXTURE WEIGHTS ==========
            // Sand weights - only where x > 0 (modified by sandDirtTransition)
            float wSand2Base = smoothstep(0.5, 1.29, vHeight) * (1.0 - smoothstep(0.5, 1.29, vHeight));
            float wSandBase = smoothstep(1.05, 1.3, vHeight) * (1.0 - smoothstep(1.05, 1.3, vHeight));

            // Apply X-position based sand/dirt separation
            float wSand2 = wSand2Base * sandDirtTransition;
            float wSand = wSandBase * sandDirtTransition;

            // Rock weights with smoother transition at 4.5
            float wRock1 = smoothstep(4.0, 5.5, vHeight) * (1.0 - smoothstep(5.0, 7.0, vHeight));
            float wRock2 = smoothstep(5.5, 9.0, vHeight) * (1.0 - smoothstep(5.0, 9.0, vHeight));
            float wSnow = smoothstep(7.5, 12.0, vHeight);

            // ========== GRASS/DIRT NATURAL BLENDING ==========
            // Blend grass variants based on moisture (darker grass in damp areas)
            vec3 grassMix = mix(grass, grass2, moisture * 0.6);

            // Calculate base grass weight (main grass coverage) with smoother rock transition
            float baseGrassWeight = smoothstep(0.9, 3.0, vHeight) * (1.0 - smoothstep(3.5, 5.5, vHeight));

            // Add subtle dirt patches (not too aggressive)
            float subtleDirtPatches = dirtPatches * 0.3;
            float subtleSlopeExposure = slopeExposure * 0.4;

            // Grass weight slightly reduced by dirt exposure (but not eliminated)
            float finalGrassWeight = baseGrassWeight * (1.0 - subtleDirtPatches * 0.5 - subtleSlopeExposure * 0.5);

            // Base dirt weight (only at lower elevations) - reduced where sand appears (x > 0)
            float baseDirtWeight = smoothstep(-25.0, 0.6, vHeight) * (1.0 - smoothstep(0.0, 1.8, vHeight));
            baseDirtWeight *= (1.0 - sandDirtTransition); // Reduce dirt where sand should be

            // Add patches on top of base dirt, but not too much
            float finalDirtWeight = baseDirtWeight + subtleDirtPatches + subtleSlopeExposure;

            // ========== FINAL WEIGHT NORMALIZATION ==========
            float totalWeight = wSand + wSand2 + finalDirtWeight + finalGrassWeight + wRock1 + wRock2 + wSnow;
            if (totalWeight > 0.0) {
                wSand /= totalWeight;
                wSand2 /= totalWeight;
                finalDirtWeight /= totalWeight;
                finalGrassWeight /= totalWeight;
                wRock1 /= totalWeight;
                wRock2 /= totalWeight;
                wSnow /= totalWeight;
            } else {
                finalDirtWeight = 1.0; // Fallback to dirt
            }

            // ========== FINAL COLOR COMPOSITION ==========
            float slopeFactor = smoothstep(0.05, 0.3, vSlope);

            vec3 baseColor = sand * wSand + sand2 * wSand2 + dirt * finalDirtWeight +
                           grassMix * finalGrassWeight + rock1 * wRock1 + rock2 * wRock2 + snow * wSnow;

            // Smooth grass-to-rock transition blend at mid elevations (around 4.5)
            // This creates a natural gradient instead of hard edge
            float grassRockTransition = smoothstep(4.0, 5.5, vHeight);
            vec3 grassRockMix = mix(grassMix, rock1, grassRockTransition * 0.3);

            // Apply the transition blend in the 4.0-5.5 elevation range
            float transitionZone = smoothstep(3.8, 4.2, vHeight) * (1.0 - smoothstep(5.3, 5.7, vHeight));
            baseColor = mix(baseColor, grassRockMix, transitionZone);

            // Additional rock on very steep slopes
            baseColor = mix(baseColor, rock, slopeFactor * 0.8);
            
            float dp = max(0.0, dot(normalize(vNormal), normalize(uLightDir)));
            float lightFactor = vHeight < -2.0 ? 0.3 + dp * 0.3 : 0.5 + dp * 0.5;
            baseColor *= lightFactor;

            gl_FragColor = vec4(baseColor, 1.0);
        }
    `;

    const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
            uDirt: { value: textures.dirt },
            uGrass: { value: textures.grass },
            uGrass2: { value: textures.grass2 },
            uRock: { value: textures.rock },
            uRock1: { value: textures.rock1 },
            uRock2: { value: textures.rock2 },
            uSnow: { value: textures.snow },
            uSand: { value: textures.sand },
            uSand2: { value: textures.sand2 },
            uLightDir: { value: new THREE.Vector3(1, 1, 1).normalize() },
            uTextureRepeat: { value: CONFIG.GRAPHICS.textureRepeat }
        },
        side: THREE.FrontSide,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
    });

    return material;
}

    static createProceduralTextures() {
        const size = CONFIG.GRAPHICS.textureSize;
        const rng = Utilities.mulberry32(CONFIG.TERRAIN.seed);

        const createTexture = (color1, color2) => {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(size, size);
            const data = imgData.data;

            for (let i = 0; i < data.length; i += 4) {
                const noise = rng();
                const color = noise > 0.5 ? color1 : color2;
                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
                data[i + 3] = 255;
            }

            ctx.putImageData(imgData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
            return texture;
        };

        // Advanced dirt texture with multiple colors and multi-frequency noise
        const createDirtTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(size, size);
            const data = imgData.data;

            // Define dirt color palette (5 shades for natural variation)
            const dirtColors = [
                { r: 82, g: 55, b: 28 },   // Dark brown
                { r: 101, g: 67, b: 33 },  // Medium dark
                { r: 120, g: 80, b: 40 },  // Medium
                { r: 139, g: 90, b: 43 },  // Medium light
                { r: 155, g: 105, b: 55 }  // Light brown
            ];

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;

                    // Multi-frequency noise for organic look
                    const noise1 = rng();
                    const noise2 = rng();
                    const noise3 = rng();

                    // Combine noise at different frequencies
                    const combinedNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;

                    // Select color based on noise
                    const colorIndex = Math.floor(combinedNoise * dirtColors.length);
                    const clampedIndex = Math.min(colorIndex, dirtColors.length - 1);
                    const baseColor = dirtColors[clampedIndex];

                    // Add slight per-pixel variation
                    const variation = (rng() - 0.5) * 20;

                    data[i] = Math.max(0, Math.min(255, baseColor.r + variation));
                    data[i + 1] = Math.max(0, Math.min(255, baseColor.g + variation));
                    data[i + 2] = Math.max(0, Math.min(255, baseColor.b + variation));
                    data[i + 3] = 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
            return texture;
        };

        const grassTexture = new THREE.TextureLoader().load('./terrain/grass.png', (texture) => {
            console.log('Grass texture loaded successfully');
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
        }, undefined, (err) => {
            console.error('Failed to load grass texture:', err);
        });

        const rockTexture = new THREE.TextureLoader().load('./terrain/rock.png', (texture) => {
            console.log('Rock texture loaded successfully');
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
        }, undefined, (err) => {
            console.error('Failed to load rock texture:', err);
        });

                const rock1Texture = new THREE.TextureLoader().load('./terrain/rock1.png', (texture) => {
            console.log('Rock1 texture loaded successfully');
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
        }, undefined, (err) => {
            console.error('Failed to load rock1 texture:', err);
        });

        const grass2Texture = new THREE.TextureLoader().load('./terrain/grass2.png', (texture) => {
            console.log('Grass2 texture loaded successfully');
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = 16;
        }, undefined, (err) => {
            console.error('Failed to load grass2 texture:', err);
        });

        return {
            dirt: createDirtTexture(), // Advanced multi-color dirt texture
            grass: grassTexture,
            grass2: grass2Texture,
            rock: rockTexture,
            rock1: rock1Texture,
            rock2: createTexture({ r: 120, g: 120, b: 120 }, { r: 150, g: 150, b: 150 }),
            snow: createTexture({ r: 255, g: 250, b: 250 }, { r: 240, g: 248, b: 255 }),
            sand: createTexture({ r: 249, g: 218, b: 161 }, { r: 242, g: 210, b: 150 }),
            sand2: createTexture({ r: 224, g: 180, b: 131 }, { r: 247, g: 196, b: 138 })

        };
    }
}

// --- TERRAIN WORKER MANAGER ---
export class TerrainWorkerManager {
    constructor() {
        this.worker = null;
        this.workerUrl = null;
        this.pendingBatches = new Map();
        this.messageHandlers = new Map();
        this.fallbackCalculator = new HeightCalculator(CONFIG.TERRAIN.seed);
        this.initialize();
    }

    initialize() {
        if (this.worker) {
            return; // Prevent reinitialization
        }
        try {
            const workerCode = this.generateWorkerCode();
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            this.workerUrl = URL.createObjectURL(blob);
            this.worker = new Worker(this.workerUrl);
            this.worker.onmessage = this.handleMessage.bind(this);
            this.worker.onerror = (error) => console.error('Worker error:', error);
        } catch (err) {
            console.error('Failed to initialize worker:', err);
            this.worker = null;
        }
    }

    generateWorkerCode() {
        const MAX_CACHE_SIZE = CONFIG.PERFORMANCE.maxCacheSize;
        const FLOAT_PRECISION = 1000000.0; // Increased precision
        
        return `
            const FLOAT_PRECISION = ${FLOAT_PRECISION};
            const terrainConfig = ${JSON.stringify(CONFIG.TERRAIN.noise)};
            const MAX_CACHE_SIZE = ${MAX_CACHE_SIZE};
            const roundCoord = (coord) => Math.round(coord * FLOAT_PRECISION) / FLOAT_PRECISION;
            
            const limitCacheSize = (cache, maxSize) => {
                if (cache.size > maxSize) {
                    const entriesToRemove = Math.floor(cache.size * 0.25);
                    const keysToDelete = Array.from(cache.keys()).slice(0, entriesToRemove);
                    keysToDelete.forEach(key => cache.delete(key));
                }
            };

            const mulberry32 = (seed) => {
                return function() {
                    let t = seed += 0x6D2B79F5;
                    t = Math.imul(t ^ (t >>> 15), t | 1);
                    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            };

            class OptimizedPerlin {
                constructor(seed = ${CONFIG.TERRAIN.seed}) {
                    this.p = new Array(512);
                    const perm = [];
                    const rng = mulberry32(seed);
                    for (let i = 0; i < 256; i++) perm[i] = i;
                    for (let i = 255; i > 0; i--) {
                        const j = Math.floor(rng() * (i + 1));
                        [perm[i], perm[j]] = [perm[j], perm[i]];
                    }
                    for (let i = 0; i < 256; i++) {
                        this.p[i] = this.p[i + 256] = perm[i];
                    }
                }

                fade(t) { 
                    return t * t * t * (t * (t * 6 - 15) + 10);
                }

                lerp(t, a, b) { 
                    return a + t * (b - a);
                }

                grad(hash, x, y, z) {
                    const h = hash & 15;
                    const u = h < 8 ? x : y;
                    const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
                }

                noise(x, y, z) {
                    let X = Math.floor(x) & 255;
                    let Y = Math.floor(y) & 255;
                    let Z = Math.floor(z) & 255;
                    
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    z -= Math.floor(z);
                    
                    let u = this.fade(x);
                    let v = this.fade(y);
                    let w = this.fade(z);
                    
                    let A = this.p[X] + Y;
                    let AA = this.p[A] + Z;
                    let AB = this.p[A + 1] + Z;
                    let B = this.p[X + 1] + Y;
                    let BA = this.p[B] + Z;
                    let BB = this.p[B + 1] + Z;

                    return this.lerp(w,
                        this.lerp(v,
                            this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
                            this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))
                        ),
                        this.lerp(v,
                            this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                            this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
                        )
                    );
                }
            }
            
            const workerHeightCache = new Map();
            const perlin = new OptimizedPerlin(${CONFIG.TERRAIN.seed});
            
            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }
            
            const calculateHeight = (x, z) => {
    // ⚠️ ============================================================================
    // ⚠️ CRITICAL SYNCHRONIZATION WARNING - TERRAIN GENERATION CODE
    // ⚠️ ============================================================================
    // ⚠️ This terrain generation algorithm is DUPLICATED in THREE locations:
    // ⚠️
    // ⚠️   1. terrain.js HeightCalculator.calculateHeight() (MAIN THREAD)
    // ⚠️   2. HERE: terrain.js worker calculateHeight() (WEB WORKER)
    // ⚠️   3. WaterRenderer.js calculateTerrainHeight() (GPU SHADER - lines ~107 & ~348)
    // ⚠️
    // ⚠️ ANY CHANGES TO THIS ALGORITHM MUST BE MANUALLY REPLICATED TO ALL 3 LOCATIONS!
    // ⚠️
    // ⚠️ Failure to synchronize will cause:
    // ⚠️   - Water/terrain height mismatches
    // ⚠️   - Visual seams between chunks
    // ⚠️   - Incorrect collision detection
    // ⚠️   - Physics glitches
    // ⚠️
    // ⚠️ Parameters must match exactly:
    // ⚠️   - Perlin noise octaves, frequencies, amplitudes
    // ⚠️   - Terrain floor compression (lines ~673-679)
    // ⚠️   - Ocean generation (lines ~681-715)
    // ⚠️   - All magic numbers and constants
    // ⚠️ ============================================================================

    // Validate input
    if (!isFinite(x) || !isFinite(z)) {
        return 0;
    }

    const rx = roundCoord(x);
    const rz = roundCoord(z);
    const key = \`\${rx},\${rz}\`;
    if (workerHeightCache.has(key)) {
        return workerHeightCache.get(key);
    }

    let base = 0;
    let amplitude = terrainConfig.baseAmplitude;
    let frequency = terrainConfig.baseFrequency;
    
    for (let octave = 0; octave < terrainConfig.baseOctaves; octave++) {
        const noiseValue = perlin.noise(rx * frequency, rz * frequency, 10 + octave * 7);
        if (!isFinite(noiseValue)) {
            console.error('Invalid noise value at', rx, rz);
            return 0;
        }
        base += noiseValue * amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }

    let maskRaw = perlin.noise(rx * terrainConfig.maskFrequency, rz * terrainConfig.maskFrequency, 400);
    if (!isFinite(maskRaw)) maskRaw = 0;
    let mask = Math.pow((maskRaw + 1) * 0.5, 3);

    let mountain = 0;
    amplitude = terrainConfig.mountainAmplitude;
    frequency = terrainConfig.mountainFrequency;
    
    for (let octave = 0; octave < terrainConfig.mountainOctaves; octave++) {
        const noiseValue = perlin.noise(rx * frequency, rz * frequency, 500 + octave * 11);
        if (!isFinite(noiseValue)) continue;
        mountain += Math.abs(noiseValue) * amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }
    mountain *= terrainConfig.mountainScale * mask;
    
    let heightBeforeJagged = base + mountain;
    
    const elevNorm = clamp((heightBeforeJagged + 2) / 25, 0, 1);
    let jaggedScale = heightBeforeJagged < 1.5 ? Math.max(0.1, (heightBeforeJagged + 0.5) / 10.0) : 1.0;
    
    const jagged1 = perlin.noise(rx * terrainConfig.jaggedFrequency1, rz * terrainConfig.jaggedFrequency1, terrainConfig.jaggedNoiseOffset1);
    const jagged2 = perlin.noise(rx * terrainConfig.jaggedFrequency2, rz * terrainConfig.jaggedFrequency2, terrainConfig.jaggedNoiseOffset2);
    
    let jagged = 0;
    if (isFinite(jagged1)) jagged += jagged1 * terrainConfig.jaggedAmplitude1 * elevNorm * jaggedScale;
    if (isFinite(jagged2)) jagged += jagged2 * terrainConfig.jaggedAmplitude2 * elevNorm * jaggedScale;

    let height = heightBeforeJagged + jagged;

    // ========== TERRAIN FLOOR START (DELETE FROM HERE TO REMOVE FLOOR) ==========
    // Exponential compression floor to prevent water puddles while preserving variation
    // Starts compressing at 1.9, asymptotically approaches 1.3 minimum
    if (height < 1.9) {
        const belowAmount = 1.9 - height;
        const maxCompression = 0.6; // (1.9 - 1.3) maximum drop
        const compressed = maxCompression * (1 - Math.exp(-belowAmount * 0.5));
        height = 1.9 - compressed; // Approaches 1.3 but never quite reaches it
    }
    // ========== TERRAIN FLOOR END (DELETE TO HERE TO REMOVE FLOOR) ==========

    // ========== OCEAN GENERATION START (DELETE FROM HERE TO REMOVE OCEAN) ==========
    // Create ocean by lowering terrain smoothly and randomly
    // Coastline position varies between x=0 and x=20 based on z position
    const coastlineThreshold = 10 + perlin.noise(rz * 0.01, 777, 0) * 10;
    const transitionWidth = 8; // Units over which to blend from land to ocean

    // Calculate distance from threshold (positive = ocean side, negative = land side)
    const distanceFromThreshold = rx - coastlineThreshold;

    // Create smooth transition using smoothstep function
    // t goes from 0 (before transition) to 1 (after transition)
    const t = Math.max(0, Math.min(1, (distanceFromThreshold + transitionWidth) / (transitionWidth * 2)));
    const smoothTransition = t * t * (3 - 2 * t); // Smoothstep S-curve

    if (smoothTransition > 0) {
        const oceanDistance = Math.max(0, distanceFromThreshold);

        // Reduce noise intensity as distance from coast increases (smoother deep ocean)
        const noiseIntensity = 1 / (1 + oceanDistance * 0.05);

        // Add noise for varied coastline - intensity reduces with distance
        const coastlineNoise = perlin.noise(rx * 0.02, rz * 0.02, 999) * 5 * noiseIntensity;
        const adjustedDistance = Math.max(0, oceanDistance + coastlineNoise);

        // Gradually deepen as distance increases - depth noise also reduces with distance
        const depthNoise = perlin.noise(rx * 0.05, rz * 0.05, 888) * 2 * noiseIntensity;
        const depthFactor = (adjustedDistance * 0.5) + depthNoise;

        // Apply ocean effect gradually based on transition
        height -= depthFactor * smoothTransition;

        // Cap at ocean floor
        height = Math.max(height, -3);
    }
    // ========== OCEAN GENERATION END (DELETE TO HERE TO REMOVE OCEAN) ==========

    // ========== RIVER GENERATION START (DELETE FROM HERE TO REMOVE RIVER) ==========
    // Create rivers at random intervals along the Z-axis (every 100-300 units)
    // Rivers run parallel to the coast, perpendicular to ocean

    const riverSegmentSize = 200; // Average spacing between rivers
    const riverTransitionWidth = 8; // Units over which to blend
    const riverWidth = 10; // Distance from first bank to center (and center to far bank)

    // Determine which river segment we're in
    const riverSegment = Math.floor(rz / riverSegmentSize);

    // Use segment number to generate deterministic random values for this segment
    const segmentSeed = riverSegment * 73856093; // Large prime for good distribution
    const segmentRandom = Math.abs(Math.sin(segmentSeed) * 43758.5453123);
    const hasRiver = (segmentRandom % 1) > 0.3; // 70% chance of river in this segment

    if (hasRiver) {
        // Random offset within segment (0-100 range gives 100-300 spacing variability)
        const riverOffsetInSegment = ((segmentRandom * 7919) % 1) * 100; // Use different multiplier for offset
        const riverCenterZ = riverSegment * riverSegmentSize + riverOffsetInSegment + 10;

        // River meanders based on x position
        const riverMeanderOffset = perlin.noise(rx * 0.01, 666 + riverSegment, 0) * 10;
        const riverThreshold = riverCenterZ + riverMeanderOffset;

        // Calculate distance from river threshold
        const riverDistanceFromThreshold = rz - riverThreshold;

        // River occupies z = threshold to threshold + 20 (two 10-unit banks)
        if (riverDistanceFromThreshold >= -riverTransitionWidth && riverDistanceFromThreshold <= riverWidth * 2 + riverTransitionWidth) {
            let riverDepthFactor = 0;

            if (riverDistanceFromThreshold <= riverWidth) {
                // First bank (z = threshold to threshold + 10)
                const t = Math.max(0, Math.min(1, (riverDistanceFromThreshold + riverTransitionWidth) / (riverTransitionWidth * 2)));
                const smoothTransition = t * t * (3 - 2 * t);

                if (smoothTransition > 0) {
                    const riverDistance = Math.max(0, riverDistanceFromThreshold);
                    const noiseIntensity = 1 / (1 + riverDistance * 0.05);
                    const riverBankNoise = perlin.noise(rx * 0.02, rz * 0.02, 555) * 5 * noiseIntensity;
                    const adjustedRiverDistance = Math.max(0, riverDistance + riverBankNoise);
                    const riverDepthNoise = perlin.noise(rx * 0.05, rz * 0.05, 444) * 2 * noiseIntensity;
                    riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                }
            } else {
                // Second bank (z = threshold + 10 to threshold + 20)
                const reversedDistance = riverWidth * 2 - riverDistanceFromThreshold;
                const t = Math.max(0, Math.min(1, (reversedDistance + riverTransitionWidth) / (riverTransitionWidth * 2)));
                const smoothTransition = t * t * (3 - 2 * t);

                if (smoothTransition > 0) {
                    const riverDistance = Math.max(0, reversedDistance);
                    const noiseIntensity = 1 / (1 + riverDistance * 0.05);
                    const riverBankNoise = perlin.noise(rx * 0.02, rz * 0.02, 555) * 5 * noiseIntensity;
                    const adjustedRiverDistance = Math.max(0, riverDistance + riverBankNoise);
                    const riverDepthNoise = perlin.noise(rx * 0.05, rz * 0.05, 444) * 2 * noiseIntensity;
                    riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                }
            }

            // Apply river effect
            height -= riverDepthFactor;
            height = Math.max(height, -3);
        }
    }
    // ========== RIVER GENERATION END (DELETE TO HERE TO REMOVE RIVER) ==========

    // Final validation
    if (!isFinite(height)) {
        console.error('NaN height at', rx, rz);
        return 0;
    }

    workerHeightCache.set(key, height);
    limitCacheSize(workerHeightCache, MAX_CACHE_SIZE);
    return height;
};

            self.onmessage = (e) => {
                const { type, data } = e.data;

                if (type === 'calculateHeightBatch') {
                    const { points, batchId, chunkX, chunkZ, chunkSize } = data;
                    const results = [];
                    const eps = 0.1;

                    for (let i = 0; i < points.length; i++) {
                        const { x, z, index } = points[i];
                        const h = calculateHeight(x, z);

                        const hL = calculateHeight(x - eps, z);
                        const hR = calculateHeight(x + eps, z);
                        const hD = calculateHeight(x, z - eps);
                        const hU = calculateHeight(x, z + eps);

                        const nx = hL - hR;
                        const ny = 2 * eps;
                        const nz = hD - hU;
                        const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                        const normal = len === 0 ? { x: 0, y: 1, z: 0 } : { x: nx / len, y: ny / len, z: nz / len };

                        results.push({
                            x, z, height: h,
                            normal,
                            index
                        });
                    }

                    // Generate height texture for water (128x128)
                    const textureSize = 128;
                    const heightTextureData = new Float32Array(textureSize * textureSize);
                    const minHeight = -10;
                    const maxHeight = 80;
                    const heightRange = maxHeight - minHeight;

                    for (let ty = 0; ty < textureSize; ty++) {
                        for (let tx = 0; tx < textureSize; tx++) {
                            // Calculate world coordinates for this texture pixel
                            const worldX = chunkX + (tx / (textureSize - 1) - 0.5) * chunkSize;
                            const worldZ = chunkZ + (ty / (textureSize - 1) - 0.5) * chunkSize;

                            const height = calculateHeight(worldX, worldZ);
                            const normalizedHeight = Math.max(0, Math.min(1, (height - minHeight) / heightRange));

                            heightTextureData[ty * textureSize + tx] = normalizedHeight;
                        }
                    }

                    self.postMessage({
                        type: 'heightBatchResult',
                        data: {
                            results,
                            batchId,
                            heightTextureData,
                            textureSize
                        }
                    });
                }

            };
        `;
    }

    calculateHeightBatch(points, batchId, chunkX, chunkZ, chunkSize, callback) {
        if (!this.worker) {
            console.warn('Worker not available, calculating on main thread');
            setTimeout(() => {
                const results = [];
                const eps = 0.1;

                for (let i = 0; i < points.length; i++) {
                    const { x, z, index } = points[i];
                    const height = this.fallbackCalculator.calculateHeight(x, z);
                    const normal = this.fallbackCalculator.calculateNormal(x, z, eps);

                    results.push({
                        x, z, height,
                        normal,
                        index
                    });
                }

                // Generate fallback height texture
                const textureSize = 128;
                const heightTextureData = new Float32Array(textureSize * textureSize);
                const minHeight = -10;
                const maxHeight = 80;
                const heightRange = maxHeight - minHeight;

                for (let ty = 0; ty < textureSize; ty++) {
                    for (let tx = 0; tx < textureSize; tx++) {
                        const worldX = chunkX + (tx / (textureSize - 1) - 0.5) * chunkSize;
                        const worldZ = chunkZ + (ty / (textureSize - 1) - 0.5) * chunkSize;
                        const height = this.fallbackCalculator.calculateHeight(worldX, worldZ);
                        const normalizedHeight = Math.max(0, Math.min(1, (height - minHeight) / heightRange));
                        heightTextureData[ty * textureSize + tx] = normalizedHeight;
                    }
                }

                callback({ results, batchId, heightTextureData, textureSize });
            }, 0);
            return;
        }

        this.messageHandlers.set(batchId, { callback, timestamp: Date.now() });
        this.worker.postMessage({
            type: 'calculateHeightBatch',
            data: { points, batchId, chunkX, chunkZ, chunkSize }
        });

        // Cleanup handlers older than 30 seconds
        const now = Date.now();
        this.messageHandlers.forEach((value, key) => {
            if (now - value.timestamp > 30000) {
                this.messageHandlers.delete(key);
            }
        });
    }

    handleMessage(e) {
        const { type, data } = e.data;
        if (type === 'heightBatchResult') {
            const { batchId } = data;
            const handler = this.messageHandlers.get(batchId);
            if (handler) {
                handler.callback(data);
                this.messageHandlers.delete(batchId);
            }
        }
    }

    terminate() {
        if (this.worker) {
            this.worker.terminate();
            if (this.workerUrl) {
                URL.revokeObjectURL(this.workerUrl);
            }
            this.worker = null;
            this.workerUrl = null;
        }
    }
}

// --- SIMPLE TERRAIN RENDERER ---
export class SimpleTerrainRenderer {
    constructor(scene) {
        this.scene = scene;
        this.chunkMap = new Map();
        this.chunkTrees = new Map(); // To track trees per chunk for cleanup
        this.heightCalculator = new HeightCalculator(CONFIG.TERRAIN.seed);
        this.workerManager = new TerrainWorkerManager();
        this.material = null;
        this.textures = null;
        this.waterRenderer = null;
        this.geometryPool = []; // Pool for reusing chunk geometries
        this.maxPoolSize = 20; // Limit pool size to prevent memory issues
        this.pendingObjectGeneration = []; // Queue for spreading object generation
        this.edgeCache = new Map(); // Cache edge vertices to avoid recalculation at boundaries
        this.pendingVertexUpdates = []; // Queue for batched vertex application
        this.verticesPerBatch = 500; // Apply 500 vertices per frame
        this.processingChunks = new Map(); // Track chunks that are being built
        this.init();
    }

    init() {
        this.textures = TerrainMaterialFactory.createProceduralTextures();
        this.material = TerrainMaterialFactory.createTerrainMaterial(this.textures);
    }

    setWaterRenderer(waterRenderer) {
        this.waterRenderer = waterRenderer;
    }

    processVertexUpdateQueue(playerPos = null) {
        if (this.pendingVertexUpdates.length === 0) {
            return false; // Nothing to process
        }

        const startTime = performance.now();
        const task = this.pendingVertexUpdates[0]; // Peek at first task
        const { key, geometry, results, currentIndex, alignedChunkX, alignedChunkZ, removedObjectIds, timings, totalStartTime, heightTextureData, textureSize } = task;

        // Check if chunk still needed
        if (this.chunkMap.has(key)) {
            // Chunk already finalized, skip
            this.pendingVertexUpdates.shift();
            return true;
        }

        // Check if player has moved too far from this chunk
        if (playerPos) {
            const chunkSize = CONFIG.TERRAIN.chunkSize;
            const [chunkGridX, chunkGridZ] = key.split(',').map(Number);
            const chunkWorldX = chunkGridX * chunkSize;
            const chunkWorldZ = chunkGridZ * chunkSize;

            const playerChunkX = Math.floor(playerPos.x / chunkSize);
            const playerChunkZ = Math.floor(playerPos.z / chunkSize);

            const distanceX = Math.abs(chunkGridX - playerChunkX);
            const distanceZ = Math.abs(chunkGridZ - playerChunkZ);
            const distance = Math.max(distanceX, distanceZ);

            // If chunk is beyond render distance + 1, abandon it
            if (distance > CONFIG.TERRAIN.renderDistance + 1) {
                console.log(`🚫 Abandoning far chunk ${key} (distance: ${distance})`);
                // Dispose the geometry if it's not in the pool
                if (geometry && !this.geometryPool.includes(geometry)) {
                    geometry.dispose();
                }
                // Remove from processing chunks
                this.processingChunks.delete(key);
                // Remove from queue
                this.pendingVertexUpdates.shift();
                return true;
            }
        }

        const position = geometry.attributes.position;
        const normal = geometry.attributes.normal;

        // Process a batch of vertices
        const endIndex = Math.min(currentIndex + this.verticesPerBatch, results.length);
        for (let i = currentIndex; i < endIndex; i++) {
            const { height, normal: n, index } = results[i];
            position.array[index * 3 + 1] = height;
            normal.array[index * 3] = n.x;
            normal.array[index * 3 + 1] = n.y;
            normal.array[index * 3 + 2] = n.z;
        }

        const batchTime = performance.now() - startTime;
        const verticesProcessed = endIndex - currentIndex;

        // Check if we're done with all vertices
        if (endIndex >= results.length) {
            // Finalize the chunk
            this.pendingVertexUpdates.shift(); // Remove task

            const vertexUpdateStartTime = performance.now();
            position.needsUpdate = true;
            normal.needsUpdate = true;
            geometry.computeBoundingSphere();
            timings.vertexUpdate = performance.now() - vertexUpdateStartTime;

            const meshStartTime = performance.now();
            const mesh = new THREE.Mesh(geometry, this.material);
            mesh.position.set(alignedChunkX, 0, alignedChunkZ);
            mesh.material.side = THREE.FrontSide;
            mesh.frustumCulled = false;
            timings.meshCreate = performance.now() - meshStartTime;

            const sceneAddStartTime = performance.now();
            this.scene.add(mesh);
            timings.sceneAdd = performance.now() - sceneAddStartTime;

            // Remove from processing chunks since it's now finalized
            this.processingChunks.delete(key);

            // Queue tree generation (preserve existing objects like server-added logs)
            if (!this.chunkTrees.has(key)) {
                this.chunkTrees.set(key, []);
            }
            this.pendingObjectGeneration.push({
                key,
                alignedChunkX,
                alignedChunkZ,
                removedObjectIds
            });

            // Store chunk with height texture data for fast lookups
            this.chunkMap.set(key, {
                mesh,
                geometry,
                chunkX: alignedChunkX,
                chunkZ: alignedChunkZ,
                heightTextureData,  // Store for CPU-side height lookups
                textureSize         // Store texture dimensions
            });

            // Add water chunk with height texture from worker
            const waterStartTime = performance.now();
            if (this.waterRenderer && typeof this.waterRenderer.addWaterChunk === 'function') {
                // Create THREE.js texture from worker-generated height data
                let heightTexture = null;
                if (heightTextureData && textureSize) {
                    const textureData = new Uint8Array(textureSize * textureSize);
                    for (let i = 0; i < heightTextureData.length; i++) {
                        textureData[i] = Math.floor(heightTextureData[i] * 255);
                    }

                    heightTexture = new THREE.DataTexture(
                        textureData,
                        textureSize,
                        textureSize,
                        THREE.RedFormat,
                        THREE.UnsignedByteType
                    );
                    heightTexture.wrapS = heightTexture.wrapT = THREE.ClampToEdgeWrapping;
                    heightTexture.minFilter = THREE.LinearFilter;
                    heightTexture.magFilter = THREE.LinearFilter;
                    heightTexture.needsUpdate = true;
                }

                this.waterRenderer.addWaterChunk(alignedChunkX, alignedChunkZ, heightTexture);
            }
            timings.waterAdd = performance.now() - waterStartTime;

            // Log timing summary
            const totalTime = performance.now() - totalStartTime;
            console.log(`✅ Chunk ${key} finalized in ${totalTime.toFixed(2)}ms (vertex batching: ${batchTime.toFixed(2)}ms for last ${verticesProcessed} vertices)`);
            if (Object.keys(timings).length > 0) {
                console.log(`📊 Chunk ${key} creation timings:`);
                Object.entries(timings).forEach(([name, time]) => {
                    if (time > 2) {
                        console.log(`  ${time > 5 ? '⚠️' : '▪️'} ${name}: ${time.toFixed(2)}ms`);
                    }
                });
            }
        } else {
            // More vertices to process - update index and continue next frame
            task.currentIndex = endIndex;
        }

        return true;
    }

    processObjectGenerationQueue() {
        if (this.pendingObjectGeneration.length === 0) {
            return false; // Nothing to process
        }

        const startTime = performance.now();
        const task = this.pendingObjectGeneration.shift(); // Take first task
        const { key, alignedChunkX, alignedChunkZ, removedObjectIds } = task;

        // Check if chunk still exists (might have been unloaded)
        if (!this.chunkMap.has(key)) {
            return true; // Skip this chunk, continue
        }

        // Generate all objects for this chunk at once
        const trees = addTreesToChunk(
            this.scene,
            this.heightCalculator,
            alignedChunkX,
            alignedChunkZ,
            CONFIG.TERRAIN.seed,
            CONFIG.TERRAIN.chunkSize,
            500, // Generate all objects
            removedObjectIds
        );

        // Merge with existing objects (e.g., server-added logs)
        const existingObjects = this.chunkTrees.get(key) || [];
        const allObjects = [...existingObjects, ...trees];
        this.chunkTrees.set(key, allObjects);

        const elapsed = performance.now() - startTime;
        if (elapsed > 5) {
            console.log(`⚠️ Object generation for chunk ${key}: ${elapsed.toFixed(2)}ms (${trees.length} new, ${allObjects.length} total)`);
        } else {
            console.log(`Generated ${trees.length} new objects for chunk ${key} (${allObjects.length} total) in ${elapsed.toFixed(2)}ms`);
        }

        return true; // Processed a chunk
    }


    createChunk(chunkX, chunkZ, removedObjectIds = null) {  // Add parameter
    const totalStartTime = performance.now();
    const timings = {};

    const chunkSize = CONFIG.TERRAIN.chunkSize;
    const segments = CONFIG.TERRAIN.segments;

    // Ensure chunk coordinates align to grid
    const alignedChunkX = Math.floor(chunkX / chunkSize) * chunkSize;
    const alignedChunkZ = Math.floor(chunkZ / chunkSize) * chunkSize;
    const key = `${alignedChunkX / chunkSize},${alignedChunkZ / chunkSize}`;
    if (this.chunkMap.has(key)) {
        return;
    }

    // Try to reuse geometry from pool
    let geometryStartTime = performance.now();
    let geometry;
    if (this.geometryPool.length > 0) {
        geometry = this.geometryPool.pop();
        timings.geometryReuse = performance.now() - geometryStartTime;
        // Geometry is already rotated and configured, just needs new heights
    } else {
        // Create new geometry if pool is empty
        geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, segments, segments);
        geometry.rotateX(-Math.PI / 2);
        timings.geometryCreate = performance.now() - geometryStartTime;
    }

    const points = [];
    const cachedResults = []; // Store cached edge values
    const verticesPerRow = segments + 1;

    // Check adjacent chunks for cached edges
    const gridX = alignedChunkX / chunkSize;
    const gridZ = alignedChunkZ / chunkSize;
    const leftEdgeKey = `edge_${gridX - 1},${gridZ}_right`;
    const rightEdgeKey = `edge_${gridX + 1},${gridZ}_left`;
    const frontEdgeKey = `edge_${gridX},${gridZ - 1}_back`;
    const backEdgeKey = `edge_${gridX},${gridZ + 1}_front`;

    // Generate vertices with precise world coordinates
    for (let z = 0; z <= segments; z++) {
        for (let x = 0; x <= segments; x++) {
            const worldX = alignedChunkX + (x / segments - 0.5) * chunkSize;
            const worldZ = alignedChunkZ + (z / segments - 0.5) * chunkSize;
            const index = z * verticesPerRow + x;

            // Check if this vertex is on an edge that's cached
            let cached = null;
            if (x === 0 && this.edgeCache.has(leftEdgeKey)) {
                cached = this.edgeCache.get(leftEdgeKey)[z];
            } else if (x === segments && this.edgeCache.has(rightEdgeKey)) {
                cached = this.edgeCache.get(rightEdgeKey)[z];
            } else if (z === 0 && this.edgeCache.has(frontEdgeKey)) {
                cached = this.edgeCache.get(frontEdgeKey)[x];
            } else if (z === segments && this.edgeCache.has(backEdgeKey)) {
                cached = this.edgeCache.get(backEdgeKey)[x];
            }

            if (cached) {
                // Use cached value
                cachedResults.push({ height: cached.height, normal: cached.normal, index });
            } else {
                // Need to calculate this point
                points.push({
                    x: roundCoord(worldX),
                    z: roundCoord(worldZ),
                    index
                });
            }
        }
    }

    const workerStartTime = performance.now();
    timings.vertexPrep = workerStartTime - geometryStartTime - (timings.geometryReuse || timings.geometryCreate || 0);

    const batchId = `${alignedChunkX},${alignedChunkZ}_${Date.now()}`;
    this.workerManager.calculateHeightBatch(points, batchId, alignedChunkX, alignedChunkZ, chunkSize, ({ results, heightTextureData, textureSize }) => {
        const callbackStartTime = performance.now();
        timings.workerWait = callbackStartTime - workerStartTime;

        // Combine cached and calculated results
        const allResults = [...cachedResults, ...results];

        // Cache this chunk's edges for adjacent chunks (do this immediately, it's fast)
        const leftEdge = [];
        const rightEdge = [];
        const frontEdge = [];
        const backEdge = [];

        allResults.forEach(({ height, normal, index }) => {
            const x = index % verticesPerRow;
            const z = Math.floor(index / verticesPerRow);
            if (x === 0) leftEdge[z] = { height, normal };
            if (x === segments) rightEdge[z] = { height, normal };
            if (z === 0) frontEdge[x] = { height, normal };
            if (z === segments) backEdge[x] = { height, normal };
        });

        this.edgeCache.set(`edge_${gridX},${gridZ}_left`, leftEdge);
        this.edgeCache.set(`edge_${gridX},${gridZ}_right`, rightEdge);
        this.edgeCache.set(`edge_${gridX},${gridZ}_front`, frontEdge);
        this.edgeCache.set(`edge_${gridX},${gridZ}_back`, backEdge);

        // Track this chunk as being processed
        this.processingChunks.set(key, {
            geometry,
            startTime: Date.now(),
            chunkX: alignedChunkX,
            chunkZ: alignedChunkZ
        });

        // INSTEAD of applying all vertices now, queue them for batched processing
        this.pendingVertexUpdates.push({
            key,
            geometry,
            results: allResults,
            verticesPerRow,
            segments,
            gridX,
            gridZ,
            alignedChunkX,
            alignedChunkZ,
            removedObjectIds,
            timings,
            totalStartTime,
            currentIndex: 0, // Track progress through vertices
            heightTextureData, // Store height texture data from worker
            textureSize // Store texture size
        });

        console.log(`Worker returned for chunk ${key}, queued ${allResults.length} vertices for batched application`);
    });
}
    

    // Method to ensure vertex sharing at chunk boundaries
    ensureVertexContinuity(chunkX, chunkZ) {
        const chunkSize = CONFIG.TERRAIN.chunkSize;
        const segments = CONFIG.TERRAIN.segments;
        const key = `${chunkX / chunkSize},${chunkZ / chunkSize}`;
        
        const chunk = this.chunkMap.get(key);
        if (!chunk) return;

        // Check adjacent chunks and ensure edge vertices match
        const adjacentKeys = [
            `${(chunkX - chunkSize) / chunkSize},${chunkZ / chunkSize}`, // Left
            `${(chunkX + chunkSize) / chunkSize},${chunkZ / chunkSize}`, // Right
            `${chunkX / chunkSize},${(chunkZ - chunkSize) / chunkSize}`, // Front
            `${chunkX / chunkSize},${(chunkZ + chunkSize) / chunkSize}`  // Back
        ];

        adjacentKeys.forEach(adjKey => {
            const adjChunk = this.chunkMap.get(adjKey);
            if (adjChunk) {
                this.matchEdgeVertices(chunk, adjChunk);
            }
        });
    }

    matchEdgeVertices(chunk1, chunk2) {
        // Ensure vertices at chunk boundaries have identical heights
        const pos1 = chunk1.geometry.attributes.position;
        const pos2 = chunk2.geometry.attributes.position;
        const segments = CONFIG.TERRAIN.segments;
        const chunkSize = CONFIG.TERRAIN.chunkSize;
        
        // Determine which edge to match based on chunk positions
        const dx = chunk2.chunkX - chunk1.chunkX;
        const dz = chunk2.chunkZ - chunk1.chunkZ;
        
        if (Math.abs(dx) === chunkSize && dz === 0) {
            // Horizontal neighbors - match vertical edges
            this.matchVerticalEdge(pos1, pos2, dx > 0, segments);
        } else if (dx === 0 && Math.abs(dz) === chunkSize) {
            // Vertical neighbors - match horizontal edges
            this.matchHorizontalEdge(pos1, pos2, dz > 0, segments);
        }
    }

    matchVerticalEdge(pos1, pos2, isRightEdge, segments) {
        const verticesPerRow = segments + 1;
        
        for (let z = 0; z <= segments; z++) {
            const edge1Index = isRightEdge ? z * verticesPerRow + segments : z * verticesPerRow;
            const edge2Index = isRightEdge ? z * verticesPerRow : z * verticesPerRow + segments;
            
            // Average the heights to ensure continuity
            const height1 = pos1.array[edge1Index * 3 + 1];
            const height2 = pos2.array[edge2Index * 3 + 1];
            const avgHeight = (height1 + height2) / 2;
            
            pos1.array[edge1Index * 3 + 1] = avgHeight;
            pos2.array[edge2Index * 3 + 1] = avgHeight;
        }
        
        pos1.needsUpdate = true;
        pos2.needsUpdate = true;
    }

    matchHorizontalEdge(pos1, pos2, isBackEdge, segments) {
        const verticesPerRow = segments + 1;
        
        for (let x = 0; x <= segments; x++) {
            const edge1Index = isBackEdge ? segments * verticesPerRow + x : x;
            const edge2Index = isBackEdge ? x : segments * verticesPerRow + x;
            
            // Average the heights to ensure continuity
            const height1 = pos1.array[edge1Index * 3 + 1];
            const height2 = pos2.array[edge2Index * 3 + 1];
            const avgHeight = (height1 + height2) / 2;
            
            pos1.array[edge1Index * 3 + 1] = avgHeight;
            pos2.array[edge2Index * 3 + 1] = avgHeight;
        }
        
        pos1.needsUpdate = true;
        pos2.needsUpdate = true;
    }

    disposeChunk(key) {
        console.log(`🔧 disposeChunk called for ${key}`);
        const chunk = this.chunkMap.get(key);

        // First, clean up any in-progress chunk that hasn't been finalized yet
        const processingChunk = this.processingChunks.get(key);
        if (processingChunk) {
            console.log(`🧹 Cleaning up in-progress chunk ${key}`);
            if (processingChunk.geometry && !this.geometryPool.includes(processingChunk.geometry)) {
                processingChunk.geometry.dispose();
            }
            this.processingChunks.delete(key);
            console.log(`  ✅ Removed ${key} from processingChunks. Remaining: ${this.processingChunks.size}`);
        } else {
            console.log(`  ❌ Chunk ${key} not in processingChunks`);
        }

        // ALWAYS remove from pending queues, regardless of chunk state
        // This prevents orphaned chunks from processing forever
        const vertexBefore = this.pendingVertexUpdates.length;
        this.pendingVertexUpdates = this.pendingVertexUpdates.filter(task => task.key !== key);
        const vertexAfter = this.pendingVertexUpdates.length;
        if (vertexBefore > vertexAfter) {
            console.log(`  ✅ Removed ${vertexBefore - vertexAfter} vertex tasks for ${key}`);
        }

        this.pendingObjectGeneration = this.pendingObjectGeneration.filter(task => task.key !== key);

        if (chunk) {
            // Count trees before disposal
            const trees = this.chunkTrees.get(key);
            const treeCount = trees ? trees.length : 0;
            console.log(`🗑️ Disposing chunk ${key} (${treeCount} objects)`);

            this.scene.remove(chunk.mesh);

            // Remove procedural trees
            if (trees) {
                removeTrees(this.scene, trees);
                this.chunkTrees.delete(key);
            }

            // Remove edge cache entries for this chunk
            const chunkGridX = chunk.chunkX / CONFIG.TERRAIN.chunkSize;
            const chunkGridZ = chunk.chunkZ / CONFIG.TERRAIN.chunkSize;
            this.edgeCache.delete(`edge_${chunkGridX},${chunkGridZ}_left`);
            this.edgeCache.delete(`edge_${chunkGridX},${chunkGridZ}_right`);
            this.edgeCache.delete(`edge_${chunkGridX},${chunkGridZ}_front`);
            this.edgeCache.delete(`edge_${chunkGridX},${chunkGridZ}_back`);

            // Return geometry to pool instead of disposing (if pool not full)
            if (this.geometryPool.length < this.maxPoolSize) {
                this.geometryPool.push(chunk.geometry);
            } else {
                // Pool is full, dispose this geometry
                chunk.geometry.dispose();
            }

            this.chunkMap.delete(key);
            if (this.waterRenderer && typeof this.waterRenderer.removeWaterChunk === 'function') {
                this.waterRenderer.removeWaterChunk(chunk.chunkX, chunk.chunkZ);
            }
        }
    }

    getTerrainHeightAt(x, z) {
        return this.heightCalculator.calculateHeight(x, z);
    }

    getTerrainNormalAt(x, z) {
        const normal = this.heightCalculator.calculateNormal(x, z);
        return new THREE.Vector3(normal.x, normal.y, normal.z);
    }

    /**
     * Get terrain height using cached texture data (fast) with bilinear interpolation
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {number} Height at position
     */
    getHeightFast(x, z) {
        const chunkSize = CONFIG.TERRAIN.chunkSize;

        // Find which chunk contains this position (chunks are centered at their coordinates)
        const chunkX = Math.round(x / chunkSize) * chunkSize;
        const chunkZ = Math.round(z / chunkSize) * chunkSize;
        const chunkKey = `${chunkX / chunkSize},${chunkZ / chunkSize}`;

        // Try to get cached height texture data
        const chunk = this.chunkMap.get(chunkKey);
        if (chunk && chunk.heightTextureData && chunk.textureSize) {
            // Convert world coords to local chunk coords (-chunkSize/2 to +chunkSize/2)
            const localX = x - chunkX;
            const localZ = z - chunkZ;

            // Convert to texture coordinates (accounting for -0.5 to +0.5 range in texture generation)
            const textureSize = chunk.textureSize;
            const texX = ((localX / chunkSize) + 0.5) * (textureSize - 1);
            const texZ = ((localZ / chunkSize) + 0.5) * (textureSize - 1);

            // Get integer and fractional parts for bilinear interpolation
            const x0 = Math.floor(texX);
            const z0 = Math.floor(texZ);
            const x1 = Math.min(x0 + 1, textureSize - 1);
            const z1 = Math.min(z0 + 1, textureSize - 1);

            const fx = texX - x0; // Fractional X (0 to 1)
            const fz = texZ - z0; // Fractional Z (0 to 1)

            // Sample 4 neighboring texels
            const h00 = chunk.heightTextureData[z0 * textureSize + x0];
            const h10 = chunk.heightTextureData[z0 * textureSize + x1];
            const h01 = chunk.heightTextureData[z1 * textureSize + x0];
            const h11 = chunk.heightTextureData[z1 * textureSize + x1];

            // Bilinear interpolation
            const h0 = h00 * (1 - fx) + h10 * fx; // Interpolate along X at z0
            const h1 = h01 * (1 - fx) + h11 * fx; // Interpolate along X at z1
            const normalizedHeight = h0 * (1 - fz) + h1 * fz; // Interpolate along Z

            // Denormalize back to actual height (matching worker normalization)
            const minHeight = -10;
            const maxHeight = 80;
            const heightRange = maxHeight - minHeight;

            // Denormalize the 4 sample heights for logging
            const actualHeight = normalizedHeight * heightRange + minHeight;

            return actualHeight;
        }

        // Fallback to noise calculation if chunk not loaded
        return this.heightCalculator.calculateHeight(x, z);
    }

    // Removed unused updateTerrain() method - functionality handled by ChunkManager in game.js

    dispose() {
        this.chunkMap.forEach((chunk, key) => {
            this.scene.remove(chunk.mesh);
            chunk.geometry.dispose();
        });
        this.chunkMap.clear();

        // Dispose all geometries in pool
        this.geometryPool.forEach(geometry => geometry.dispose());
        this.geometryPool = [];

        // Clear edge cache
        this.edgeCache.clear();

        this.material.dispose();
        Object.values(this.textures).forEach(texture => texture.dispose());
        this.workerManager.terminate();
        if (this.waterRenderer && typeof this.waterRenderer.dispose === 'function') {
            this.waterRenderer.dispose();
        }
    }
    // Add this function to SimpleTerrainRenderer class
}


================================================================================
FILE 7/11: public/ui.js
Location: C:\Users\colli\Desktop\test horses\horses\public\ui.js
Lines: 338
================================================================================

// File: public/ui.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\ui.js

// --- UI ELEMENTS ---
let connectionStatusEl;
let peerInfoEl;
let fpsCounterEl;
let addBtn;
let removeBtn;
let sawPlanksBtn;
let inventoryToggleBtn;

// Status line timer references for auto-hide
let statusLine1Timer = null;
let statusLine2Timer = null;

// This object will be exported and used by game.js
export const ui = {
    updateStatus(msg) {
        const timestamp = new Date().toLocaleTimeString();
        // Status element removed - only log to console
        console.log(`[${timestamp}] ${msg}`);
    },

    updateStatusLine1(message, duration = 3000) {
        const statusLine1 = document.getElementById('statusLine1');
        if (!statusLine1) return;

        if (message) {
            statusLine1.textContent = message;
            statusLine1.style.display = 'block';

            // Clear existing timer
            if (statusLine1Timer) {
                clearTimeout(statusLine1Timer);
            }

            // Auto-hide after duration (0 = don't hide)
            if (duration > 0) {
                statusLine1Timer = setTimeout(() => {
                    statusLine1.style.display = 'none';
                }, duration);
            }
        } else {
            // Clear message
            statusLine1.style.display = 'none';
            if (statusLine1Timer) {
                clearTimeout(statusLine1Timer);
                statusLine1Timer = null;
            }
        }
    },

    updateStatusLine2(message, duration = 3000) {
        const statusLine2 = document.getElementById('statusLine2');
        if (!statusLine2) return;

        if (message) {
            statusLine2.textContent = message;
            statusLine2.style.display = 'block';

            // Clear existing timer
            if (statusLine2Timer) {
                clearTimeout(statusLine2Timer);
            }

            // Auto-hide after duration (0 = don't hide)
            if (duration > 0) {
                statusLine2Timer = setTimeout(() => {
                    statusLine2.style.display = 'none';
                }, duration);
            }
        } else {
            // Clear message
            statusLine2.style.display = 'none';
            if (statusLine2Timer) {
                clearTimeout(statusLine2Timer);
                statusLine2Timer = null;
            }
        }
    },

    updateConnectionStatus(status, message) {
        connectionStatusEl.className = `status-${status}`;
        connectionStatusEl.innerHTML = message;
    },

    updatePeerInfo(peers, avatars) {
        const connectedPeers = Array.from(peers.values()).filter(p => p.state === 'connected');
        peerInfoEl.innerHTML = `P2P Connections: ${connectedPeers.length}/${peers.size}<br>Avatars: ${avatars.size}`;
    },

    updateNearestObject(objectName, toolCheck, quality, remainingResources, totalResources) {
        const nearestObjectEl = document.getElementById('nearestObject');
        if (!objectName) {
            nearestObjectEl.textContent = 'No object nearby';
        } else if (toolCheck && !toolCheck.hasRequiredTool) {
            // Show why they can't remove it
            const qualityText = quality ? ` (Quality: ${quality})` : '';
            const resourceText = (remainingResources != null && totalResources != null)
                ? ` (${remainingResources}/${totalResources})`
                : '';
            nearestObjectEl.textContent = `${objectName}${qualityText}${resourceText} - ${toolCheck.reason}`;
        } else {
            const qualityText = quality ? ` (Quality: ${quality})` : '';
            const resourceText = (remainingResources != null && totalResources != null)
                ? ` (${remainingResources}/${totalResources})`
                : '';
            nearestObjectEl.textContent = `${objectName}${qualityText}${resourceText}`;
        }
    },

    updateButtonStates(isInChunk, nearestObject, hasAxe, hasSaw, isOnCooldown = false, nearestConstructionSite = null, isMoving = false, nearestCrate = null) {
        // Always show inventory button (if it exists)
        if (inventoryToggleBtn) {
            inventoryToggleBtn.style.display = 'inline-block';
        }

        // Show/hide construction button based on nearby construction site (hide if moving)
        const constructionBtn = document.getElementById('constructionInventoryBtn');
        if (constructionBtn) {
            constructionBtn.style.display = (nearestConstructionSite && !isMoving) ? 'inline-block' : 'none';
        }

        // Show/hide crate button based on nearby crate (hide if moving)
        const crateBtn = document.getElementById('crateInventoryBtn');
        if (crateBtn) {
            crateBtn.style.display = (nearestCrate && !isMoving) ? 'inline-block' : 'none';
        }

        // Hide addBtn (temporarily disabled)
        addBtn.style.display = 'none';

        // Set button text and visibility based on object type
        if (nearestObject) {
            const treeTypes = ['oak', 'fir', 'pine', 'cypress'];
            const rockTypes = ['limestone', 'sandstone'];
            const structureTypes = ['construction', 'foundation', 'foundationcorner', 'foundationroundcorner'];
            const isLog = nearestObject.name.endsWith('_log') || nearestObject.name === 'log';

            if (treeTypes.includes(nearestObject.name)) {
                // Trees require axe
                removeBtn.textContent = 'Chop Tree';
                const canChop = isInChunk && hasAxe && !isMoving;
                removeBtn.style.display = canChop ? 'inline-block' : 'none';
                removeBtn.disabled = false;
                sawPlanksBtn.style.display = 'none';
            } else if (rockTypes.includes(nearestObject.name)) {
                // Rocks require pickaxe - display specific rock type
                const rockName = nearestObject.name.charAt(0).toUpperCase() + nearestObject.name.slice(1);
                removeBtn.textContent = `Mine ${rockName}`;
                const hasRequiredTool = nearestObject.toolCheck && nearestObject.toolCheck.hasRequiredTool;
                const hasResources = nearestObject.remainingResources > 0;
                const canMine = isInChunk && hasRequiredTool && hasResources && !isOnCooldown && !isMoving;
                removeBtn.style.display = canMine ? 'inline-block' : 'none';
                removeBtn.disabled = false;
                sawPlanksBtn.style.display = 'none';
            } else if (structureTypes.includes(nearestObject.name)) {
                // Structures require hammer to demolish
                removeBtn.textContent = `Demolish ${nearestObject.name}`;
                const hasHammer = nearestObject.toolCheck && nearestObject.toolCheck.hasRequiredTool;
                const canDemolish = isInChunk && hasHammer && !isMoving;
                removeBtn.style.display = canDemolish ? 'inline-block' : 'none';
                removeBtn.disabled = false;
                sawPlanksBtn.style.display = 'none';
            } else if (isLog) {
                // Logs show both buttons (oak_log, pine_log, etc.)
                removeBtn.textContent = 'Chop Firewood';
                const canChopFirewood = isInChunk && hasAxe && nearestObject.remainingResources > 0 && !isOnCooldown && !isMoving;
                removeBtn.style.display = canChopFirewood ? 'inline-block' : 'none';
                removeBtn.disabled = false;

                sawPlanksBtn.textContent = 'Saw Planks';
                const canSawPlanks = isInChunk && hasSaw && nearestObject.remainingResources > 0 && !isOnCooldown && !isMoving;
                sawPlanksBtn.style.display = canSawPlanks ? 'inline-block' : 'none';
                sawPlanksBtn.disabled = false;
            } else {
                removeBtn.textContent = `Remove ${nearestObject.name}`;
                const hasRequiredTool = nearestObject.toolCheck && nearestObject.toolCheck.hasRequiredTool;
                const canRemove = isInChunk && hasRequiredTool && !isMoving;
                removeBtn.style.display = canRemove ? 'inline-block' : 'none';
                removeBtn.disabled = false;
                sawPlanksBtn.style.display = 'none';
            }
        } else {
            // No object nearby - hide all buttons
            removeBtn.style.display = 'none';
            sawPlanksBtn.style.display = 'none';
        }
    },

    updateFPS(fps) {
        const color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffff00' : '#ff0000';
        fpsCounterEl.style.color = color;
        fpsCounterEl.textContent = `FPS: ${fps}`;
    },

    updateChoppingProgress(progress) {
        let progressEl = document.getElementById('choppingProgress');

        if (progress === 0) {
            // Hide progress bar
            if (progressEl) {
                progressEl.remove();
            }
            return;
        }

        // Create or update progress bar
        if (!progressEl) {
            progressEl = document.createElement('div');
            progressEl.id = 'choppingProgress';
            progressEl.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                width: 300px;
                height: 30px;
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid #00ff00;
                border-radius: 5px;
                overflow: hidden;
                z-index: 1000;
            `;
            const bar = document.createElement('div');
            bar.id = 'choppingProgressBar';
            bar.style.cssText = `
                height: 100%;
                background: linear-gradient(90deg, #00ff00, #00aa00);
                transition: width 0.1s linear;
                width: 0%;
            `;
            progressEl.appendChild(bar);
            document.body.appendChild(progressEl);
        }

        const bar = document.getElementById('choppingProgressBar');
        if (bar) {
            bar.style.width = `${progress * 100}%`;
        }
    },

    // Sets up event listeners, accepting callbacks for actions
    initializeUI(callbacks) {
        // Get UI elements from DOM
        connectionStatusEl = document.getElementById('connectionStatus');
        peerInfoEl = document.getElementById('peerInfo');
        fpsCounterEl = document.getElementById('fpsCounter');
        addBtn = document.getElementById('addBoxBtn');
        removeBtn = document.getElementById('removeBoxBtn');
        sawPlanksBtn = document.getElementById('sawPlanksBtn');
        inventoryToggleBtn = document.getElementById('inventoryToggleBtn');

        addBtn.onclick = () => {
            // Resume AudioContext on user interaction (browser requirement)
            if (callbacks.resumeAudio) callbacks.resumeAudio();

            const chunkX = callbacks.getCurrentChunkX();
            const chunkZ = callbacks.getCurrentChunkZ();
            callbacks.sendServerMessage('add_box_request', {  // Keep the message type the same for server compatibility
                chunkId: `chunk_${chunkX},${chunkZ}`,
                position: { x: 0, y: 0, z: -3 }
            });
        };

        removeBtn.onclick = () => {
            // Resume AudioContext on user interaction (browser requirement)
            if (callbacks.resumeAudio) callbacks.resumeAudio();

            callbacks.onRemoveObject(callbacks.getNearestObject());
        };

        sawPlanksBtn.onclick = () => {
            // Resume AudioContext on user interaction (browser requirement)
            if (callbacks.resumeAudio) callbacks.resumeAudio();

            callbacks.onHarvestLog(callbacks.getNearestObject(), 'planks');
        };

        if (inventoryToggleBtn) {
            inventoryToggleBtn.onclick = () => {
                // Resume AudioContext on user interaction (browser requirement)
                if (callbacks.resumeAudio) callbacks.resumeAudio();

                callbacks.toggleInventory();
            };
        }

        const buildMenuToggleBtn = document.getElementById('buildMenuToggleBtn');
        if (buildMenuToggleBtn) {
            buildMenuToggleBtn.onclick = () => {
                // Resume AudioContext on user interaction (browser requirement)
                if (callbacks.resumeAudio) callbacks.resumeAudio();

                callbacks.toggleBuildMenu();
            };
        }

        const constructionInventoryBtn = document.getElementById('constructionInventoryBtn');
        if (constructionInventoryBtn) {
            constructionInventoryBtn.onclick = () => {
                // Resume AudioContext on user interaction (browser requirement)
                if (callbacks.resumeAudio) callbacks.resumeAudio();

                // Open backpack (construction section will show automatically if near site and stopped)
                callbacks.toggleInventory();
            };
        }

        // Crate inventory button
        const crateInventoryBtn = document.getElementById('crateInventoryBtn');
        if (crateInventoryBtn) {
            crateInventoryBtn.onclick = () => {
                // Resume AudioContext on user interaction (browser requirement)
                if (callbacks.resumeAudio) callbacks.resumeAudio();

                // Open backpack (crate section will show automatically if near crate and stopped)
                callbacks.toggleInventory();
            };
        }

        // Construction build button
        const constructionBuildBtn = document.getElementById('constructionBuildBtn');
        if (constructionBuildBtn) {
            constructionBuildBtn.onclick = () => {
                // Resume AudioContext on user interaction (browser requirement)
                if (callbacks.resumeAudio) callbacks.resumeAudio();

                callbacks.onBuildConstruction();
            };
        }

        window.addEventListener('resize', () => {
            callbacks.onResize();
        });
    }
};


================================================================================
FILE 8/11: public/WaterRenderer.js
Location: C:\Users\colli\Desktop\test horses\horses\public\WaterRenderer.js
Lines: 1526
================================================================================

// File: public/WaterRenderer.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\WaterRenderer.js

import * as THREE from 'three';

// --- Simplified Water Vertex Shader (based on old version) ---
// Replace your existing waterVertexShader with this modified version:

const waterVertexShader = `
    precision mediump float;
    uniform float u_time;
    uniform float u_wave_height;
    uniform float u_wave_frequency;
    uniform float u_wave_speed;
    uniform vec2 u_chunk_offset;
    uniform float u_chunk_size;
    uniform float u_water_level;
    uniform sampler2D u_height_texture;
    uniform float u_wave_damp_min_depth;
    uniform float u_wave_damp_max_depth;
    uniform float u_deep_water_threshold;
    uniform int u_terrain_seed;

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    varying float vWaveHeight;
    varying float vWaveSlope;

    // Perlin noise implementation for GLSL
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

    float perlinNoise(vec3 P) {
        vec3 Pi0 = floor(P);
        vec3 Pi1 = Pi0 + vec3(1.0);
        Pi0 = mod289(Pi0);
        Pi1 = mod289(Pi1);
        vec3 Pf0 = fract(P);
        vec3 Pf1 = Pf0 - vec3(1.0);
        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
        vec4 iy = vec4(Pi0.yy, Pi1.yy);
        vec4 iz0 = Pi0.zzzz;
        vec4 iz1 = Pi1.zzzz;

        vec4 ixy = permute(permute(ix) + iy);
        vec4 ixy0 = permute(ixy + iz0);
        vec4 ixy1 = permute(ixy + iz1);

        vec4 gx0 = ixy0 * (1.0 / 7.0);
        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
        gx0 = fract(gx0);
        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
        vec4 sz0 = step(gz0, vec4(0.0));
        gx0 -= sz0 * (step(0.0, gx0) - 0.5);
        gy0 -= sz0 * (step(0.0, gy0) - 0.5);

        vec4 gx1 = ixy1 * (1.0 / 7.0);
        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
        gx1 = fract(gx1);
        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
        vec4 sz1 = step(gz1, vec4(0.0));
        gx1 -= sz1 * (step(0.0, gx1) - 0.5);
        gy1 -= sz1 * (step(0.0, gy1) - 0.5);

        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
        g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
        g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;

        float n000 = dot(g000, Pf0);
        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
        float n111 = dot(g111, Pf1);

        vec3 fade_xyz = fade(Pf0);
        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
        return n_xyz;
    }

    // Round coordinates for precision matching (like roundCoord in terrain.js)
    const float FLOAT_PRECISION = 1000000.0;
    float roundCoord(float coord) {
        return floor(coord * FLOAT_PRECISION + 0.5) / FLOAT_PRECISION;
    }

    // ⚠️ ============================================================================
    // ⚠️ CRITICAL SYNCHRONIZATION WARNING - TERRAIN GENERATION CODE
    // ⚠️ ============================================================================
    // ⚠️ This terrain generation algorithm is DUPLICATED in THREE locations:
    // ⚠️
    // ⚠️   1. terrain.js HeightCalculator.calculateHeight() (MAIN THREAD)
    // ⚠️   2. terrain.js worker calculateHeight() (WEB WORKER - line ~636)
    // ⚠️   3. WaterRenderer.js calculateTerrainHeight() (GPU VERTEX SHADER - line ~106)
    // ⚠️   4. WaterRenderer.js calculateTerrainHeight() (GPU FRAGMENT SHADER - line ~348)
    // ⚠️
    // ⚠️ ANY CHANGES TO THIS ALGORITHM MUST BE MANUALLY REPLICATED TO ALL LOCATIONS!
    // ⚠️
    // ⚠️ This includes: base terrain, mountains, jagged detail, terrain floor, ocean, river
    // ⚠️ ============================================================================
    float calculateTerrainHeight(vec2 worldPos) {
        // Round coordinates for precision (matches terrain.js roundCoord)
        float x = roundCoord(worldPos.x);
        float z = roundCoord(worldPos.y);

        // Base terrain
        float base = 0.0;
        float amplitude = 1.0;
        float frequency = 0.02;
        for (int octave = 0; octave < 3; octave++) {
            base += perlinNoise(vec3(x * frequency, z * frequency, 10.0 + float(octave) * 7.0)) * amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }

        // Mountain mask
        float maskRaw = perlinNoise(vec3(x * 0.006, z * 0.006, 400.0));
        float mask = pow((maskRaw + 1.0) * 0.5, 3.0);

        // Mountains
        float mountain = 0.0;
        amplitude = 1.0;
        frequency = 0.04;
        for (int octave = 0; octave < 4; octave++) {
            mountain += abs(perlinNoise(vec3(x * frequency, z * frequency, 500.0 + float(octave) * 11.0))) * amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }
        mountain *= 40.0 * mask;

        float heightBeforeJagged = base + mountain;

        // Jagged detail
        float elevNorm = clamp((heightBeforeJagged + 2.0) / 25.0, 0.0, 1.0);
        float jaggedScale = heightBeforeJagged < 1.5 ? max(0.1, (heightBeforeJagged + 0.5) / 10.0) : 1.0;
        float jagged = perlinNoise(vec3(x * 0.8, z * 0.8, 900.0)) * 1.2 * elevNorm * jaggedScale +
                      perlinNoise(vec3(x * 1.6, z * 1.6, 901.0)) * 0.6 * elevNorm * jaggedScale;

        float height = heightBeforeJagged + jagged;

        // ========== TERRAIN FLOOR START (DELETE FROM HERE TO REMOVE FLOOR) ==========
        // Exponential compression floor to prevent water puddles while preserving variation
        // Starts compressing at 1.9, asymptotically approaches 1.3 minimum
        if (height < 1.9) {
            float belowAmount = 1.9 - height;
            float maxCompression = 0.6; // (1.9 - 1.3) maximum drop
            float compressed = maxCompression * (1.0 - exp(-belowAmount * 0.5));
            height = 1.9 - compressed; // Approaches 1.3 but never quite reaches it
        }
        // ========== TERRAIN FLOOR END (DELETE TO HERE TO REMOVE FLOOR) ==========

        // ========== OCEAN GENERATION START (DELETE FROM HERE TO REMOVE OCEAN) ==========
        // Create ocean by lowering terrain smoothly and randomly
        // Coastline position varies between x=0 and x=20 based on z position
        float coastlineThreshold = 10.0 + perlinNoise(vec3(z * 0.01, 777.0, 0.0)) * 10.0;
        float transitionWidth = 8.0; // Units over which to blend from land to ocean

        // Calculate distance from threshold (positive = ocean side, negative = land side)
        float distanceFromThreshold = x - coastlineThreshold;

        // Create smooth transition using smoothstep function
        // t goes from 0 (before transition) to 1 (after transition)
        float t = clamp((distanceFromThreshold + transitionWidth) / (transitionWidth * 2.0), 0.0, 1.0);
        float smoothTransition = t * t * (3.0 - 2.0 * t); // Smoothstep S-curve

        if (smoothTransition > 0.0) {
            float oceanDistance = max(0.0, distanceFromThreshold);

            // Reduce noise intensity as distance from coast increases (smoother deep ocean)
            float noiseIntensity = 1.0 / (1.0 + oceanDistance * 0.05);

            // Add noise for varied coastline - intensity reduces with distance
            float coastlineNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 999.0)) * 5.0 * noiseIntensity;
            float adjustedDistance = max(0.0, oceanDistance + coastlineNoise);

            // Gradually deepen as distance increases - depth noise also reduces with distance
            float depthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 888.0)) * 2.0 * noiseIntensity;
            float depthFactor = (adjustedDistance * 0.5) + depthNoise;

            // Apply ocean effect gradually based on transition
            height -= depthFactor * smoothTransition;

            // Cap at ocean floor
            height = max(height, -3.0);
        }
        // ========== OCEAN GENERATION END (DELETE TO HERE TO REMOVE OCEAN) ==========

        // ========== RIVER GENERATION START (DELETE FROM HERE TO REMOVE RIVER) ==========
        // Create rivers at random intervals along the Z-axis (every 100-300 units)
        // Rivers run parallel to the coast, perpendicular to ocean

        float riverSegmentSize = 200.0; // Average spacing between rivers
        float riverTransitionWidth = 8.0; // Units over which to blend
        float riverWidth = 10.0; // Distance from first bank to center (and center to far bank)

        // Determine which river segment we're in
        float riverSegment = floor(z / riverSegmentSize);

        // Use segment number to generate deterministic random values for this segment
        float segmentSeed = riverSegment * 73856093.0; // Large prime for good distribution
        float segmentRandom = abs(sin(segmentSeed) * 43758.5453123);
        float hasRiver = mod(segmentRandom, 1.0) > 0.3 ? 1.0 : 0.0; // 70% chance of river in this segment

        if (hasRiver > 0.5) {
            // Random offset within segment (0-100 range gives 100-300 spacing variability)
            float riverOffsetInSegment = mod(segmentRandom * 7919.0, 1.0) * 100.0; // Use different multiplier for offset
            float riverCenterZ = riverSegment * riverSegmentSize + riverOffsetInSegment + 10.0;

            // River meanders based on x position
            float riverMeanderOffset = perlinNoise(vec3(x * 0.01, 666.0 + riverSegment, 0.0)) * 10.0;
            float riverThreshold = riverCenterZ + riverMeanderOffset;

            // Calculate distance from river threshold
            float riverDistanceFromThreshold = z - riverThreshold;

            // River occupies z = threshold to threshold + 20 (two 10-unit banks)
            if (riverDistanceFromThreshold >= -riverTransitionWidth && riverDistanceFromThreshold <= riverWidth * 2.0 + riverTransitionWidth) {
                float riverDepthFactor = 0.0;

                if (riverDistanceFromThreshold <= riverWidth) {
                    // First bank (z = threshold to threshold + 10)
                    float t = clamp((riverDistanceFromThreshold + riverTransitionWidth) / (riverTransitionWidth * 2.0), 0.0, 1.0);
                    float smoothTransition = t * t * (3.0 - 2.0 * t);

                    if (smoothTransition > 0.0) {
                        float riverDistance = max(0.0, riverDistanceFromThreshold);
                        float noiseIntensity = 1.0 / (1.0 + riverDistance * 0.05);
                        float riverBankNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 555.0)) * 5.0 * noiseIntensity;
                        float adjustedRiverDistance = max(0.0, riverDistance + riverBankNoise);
                        float riverDepthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 444.0)) * 2.0 * noiseIntensity;
                        riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                    }
                } else {
                    // Second bank (z = threshold + 10 to threshold + 20)
                    float reversedDistance = riverWidth * 2.0 - riverDistanceFromThreshold;
                    float t = clamp((reversedDistance + riverTransitionWidth) / (riverTransitionWidth * 2.0), 0.0, 1.0);
                    float smoothTransition = t * t * (3.0 - 2.0 * t);

                    if (smoothTransition > 0.0) {
                        float riverDistance = max(0.0, reversedDistance);
                        float noiseIntensity = 1.0 / (1.0 + riverDistance * 0.05);
                        float riverBankNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 555.0)) * 5.0 * noiseIntensity;
                        float adjustedRiverDistance = max(0.0, riverDistance + riverBankNoise);
                        float riverDepthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 444.0)) * 2.0 * noiseIntensity;
                        riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                    }
                }

                // Apply river effect
                height -= riverDepthFactor;
                height = max(height, -3.0);
            }
        }
        // ========== RIVER GENERATION END (DELETE TO HERE TO REMOVE RIVER) ==========

        return height;
    }

    float sampleTerrainHeight(vec2 worldPos) {
        // Convert world position to texture coordinates
        vec2 texCoord = (worldPos - u_chunk_offset) / u_chunk_size + 0.5;

        // Sample the height texture
        float normalizedHeight = texture2D(u_height_texture, texCoord).r;

        // Convert from normalized [0,1] back to world height range
        float minHeight = -10.0;
        float maxHeight = 80.0;
        return normalizedHeight * (maxHeight - minHeight) + minHeight;
    }

    // Simplified wave function (from old version)
    float wave(vec2 pos, float freq, float speed) {
        return sin(pos.x * freq + u_time * speed * u_wave_speed) * cos(pos.y * freq * 0.7 + u_time * speed * 0.8 * u_wave_speed);
    }

    float waveDerivativeX(vec2 pos, float freq, float speed) {
        return freq * cos(pos.x * freq + u_time * speed * u_wave_speed) * cos(pos.y * freq * 0.7 + u_time * speed * 0.8 * u_wave_speed);
    }

    float waveDerivativeZ(vec2 pos, float freq, float speed) {
        return -freq * 0.7 * sin(pos.x * freq + u_time * speed * u_wave_speed) * sin(pos.y * freq * 0.7 + u_time * speed * 0.8 * u_wave_speed);
    }

    void main() {
        vUv = uv;
        vec3 pos = position;

        // Get world position for this vertex (before wave displacement)
        // The plane is 50x50 units centered at origin, so pos ranges from -25 to +25
        // modelMatrix applies the chunk position (from mesh.position.set)
        vec4 worldPosVec4 = modelMatrix * vec4(pos, 1.0);
        vec2 worldXZ = worldPosVec4.xz;

        // Calculate water depth at this position
        float terrainHeight = sampleTerrainHeight(worldXZ);
        float waterDepth = u_water_level - terrainHeight;

        // Create depth-based wave damping factor (adjustable via GUI)
        // Shallow water uses inverted smoothstep for foam tuning
        float shallowDamping = smoothstep(u_wave_damp_min_depth, u_wave_damp_max_depth, waterDepth);

        // Deep water always has full waves
        float deepWaterFactor = smoothstep(u_deep_water_threshold - 0.2, u_deep_water_threshold, waterDepth);

        // Blend: shallow damping in shallow water, full waves in deep water
        float depthFactor = mix(shallowDamping, 1.0, deepWaterFactor);

        // Simplified 3-wave system (from old version)
        float waveDisplacement = 0.0;
        waveDisplacement += wave(worldXZ, u_wave_frequency, 1.5) * 0.5;
        waveDisplacement += wave(worldXZ * 1.8, u_wave_frequency * 1.7, 2.1) * 0.3;
        waveDisplacement += wave(worldXZ * 2.3, u_wave_frequency * 0.9, 1.8) * 0.2;

        // Apply depth-based damping to wave displacement
        pos.y += waveDisplacement * u_wave_height * depthFactor;
        vWaveHeight = waveDisplacement * depthFactor;

        // Calculate wave slopes for foam and normal calculations (also dampened)
        float slopeX = 0.0;
        float slopeZ = 0.0;
        slopeX += waveDerivativeX(worldXZ, u_wave_frequency, 1.5) * 0.5;
        slopeX += waveDerivativeX(worldXZ * 1.8, u_wave_frequency * 1.7, 2.1) * 0.3;
        slopeZ += waveDerivativeZ(worldXZ, u_wave_frequency, 1.5) * 0.5;
        slopeZ += waveDerivativeZ(worldXZ * 1.8, u_wave_frequency * 1.7, 2.1) * 0.3;
        vWaveSlope = length(vec2(slopeX, slopeZ)) * u_wave_height * depthFactor;

        // Transform to final world space with wave displacement applied
        vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
        vWorldPosition = worldPosition.xyz;
        vViewPosition = cameraPosition - worldPosition.xyz;
        
        // Calculate normal from wave slopes (also dampened)
        vec3 tangentX = vec3(1.0, slopeX * u_wave_height * depthFactor, 0.0);
        vec3 tangentZ = vec3(0.0, slopeZ * u_wave_height * depthFactor, 1.0);
        vWorldNormal = normalize(cross(tangentX, tangentZ));
        
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
`;

// --- Simplified Water Fragment Shader (based on old version) ---
const waterFragmentShader = `
    precision mediump float;

    uniform float u_time;
    uniform vec4 u_shallow_color;
    uniform vec4 u_deep_color;
    uniform vec4 u_foam_color;
    uniform sampler2D u_normal_texture;
    uniform sampler2D u_sky_reflection_texture;
    uniform sampler2D u_foam_texture;
    uniform sampler2D u_caustics_texture;
    uniform sampler2D u_height_texture;
    uniform float u_water_level;
    uniform float u_chunk_size;
    uniform vec2 u_chunk_offset;
    uniform vec3 u_sun_direction;
    uniform vec3 u_sun_color;
    uniform float u_shininess;
    uniform float u_foam_threshold;
    uniform float u_normal_scale;
    uniform float u_texture_scale;
    uniform float u_transparency;
    uniform float u_caustics_intensity;
    uniform bool u_enable_caustics;
    uniform bool u_enable_foam;
    uniform bool u_enable_reflections;
    uniform float u_wave_damp_min_depth;
    uniform float u_wave_damp_max_depth;
    uniform float u_foam_min_depth;
    uniform float u_foam_max_depth;
    uniform float u_foam_wave_influence;
    uniform int u_terrain_seed;

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    varying float vWaveHeight;
    varying float vWaveSlope;

    // Perlin noise implementation (same as vertex shader)
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

    float perlinNoise(vec3 P) {
        vec3 Pi0 = floor(P);
        vec3 Pi1 = Pi0 + vec3(1.0);
        Pi0 = mod289(Pi0);
        Pi1 = mod289(Pi1);
        vec3 Pf0 = fract(P);
        vec3 Pf1 = Pf0 - vec3(1.0);
        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
        vec4 iy = vec4(Pi0.yy, Pi1.yy);
        vec4 iz0 = Pi0.zzzz;
        vec4 iz1 = Pi1.zzzz;

        vec4 ixy = permute(permute(ix) + iy);
        vec4 ixy0 = permute(ixy + iz0);
        vec4 ixy1 = permute(ixy + iz1);

        vec4 gx0 = ixy0 * (1.0 / 7.0);
        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
        gx0 = fract(gx0);
        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
        vec4 sz0 = step(gz0, vec4(0.0));
        gx0 -= sz0 * (step(0.0, gx0) - 0.5);
        gy0 -= sz0 * (step(0.0, gy0) - 0.5);

        vec4 gx1 = ixy1 * (1.0 / 7.0);
        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
        gx1 = fract(gx1);
        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
        vec4 sz1 = step(gz1, vec4(0.0));
        gx1 -= sz1 * (step(0.0, gx1) - 0.5);
        gy1 -= sz1 * (step(0.0, gy1) - 0.5);

        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
        g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
        g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;

        float n000 = dot(g000, Pf0);
        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
        float n111 = dot(g111, Pf1);

        vec3 fade_xyz = fade(Pf0);
        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
        return n_xyz;
    }

    // Round coordinates for precision matching (like roundCoord in terrain.js)
    const float FLOAT_PRECISION = 1000000.0;
    float roundCoord(float coord) {
        return floor(coord * FLOAT_PRECISION + 0.5) / FLOAT_PRECISION;
    }

    // ⚠️ ============================================================================
    // ⚠️ CRITICAL SYNCHRONIZATION WARNING - TERRAIN GENERATION CODE
    // ⚠️ ============================================================================
    // ⚠️ This terrain generation algorithm is DUPLICATED in THREE locations:
    // ⚠️
    // ⚠️   1. terrain.js HeightCalculator.calculateHeight() (MAIN THREAD)
    // ⚠️   2. terrain.js worker calculateHeight() (WEB WORKER - line ~636)
    // ⚠️   3. WaterRenderer.js calculateTerrainHeight() (GPU VERTEX SHADER - line ~106)
    // ⚠️   4. WaterRenderer.js calculateTerrainHeight() (GPU FRAGMENT SHADER - line ~348)
    // ⚠️
    // ⚠️ ANY CHANGES TO THIS ALGORITHM MUST BE MANUALLY REPLICATED TO ALL LOCATIONS!
    // ⚠️
    // ⚠️ This includes: base terrain, mountains, jagged detail, terrain floor, ocean, river
    // ⚠️ ============================================================================
    float calculateTerrainHeight(vec2 worldPos) {
        // Round coordinates for precision (matches terrain.js roundCoord)
        float x = roundCoord(worldPos.x);
        float z = roundCoord(worldPos.y);

        // Base terrain
        float base = 0.0;
        float amplitude = 1.0;
        float frequency = 0.02;
        for (int octave = 0; octave < 3; octave++) {
            base += perlinNoise(vec3(x * frequency, z * frequency, 10.0 + float(octave) * 7.0)) * amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }

        // Mountain mask
        float maskRaw = perlinNoise(vec3(x * 0.006, z * 0.006, 400.0));
        float mask = pow((maskRaw + 1.0) * 0.5, 3.0);

        // Mountains
        float mountain = 0.0;
        amplitude = 1.0;
        frequency = 0.04;
        for (int octave = 0; octave < 4; octave++) {
            mountain += abs(perlinNoise(vec3(x * frequency, z * frequency, 500.0 + float(octave) * 11.0))) * amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }
        mountain *= 40.0 * mask;

        float heightBeforeJagged = base + mountain;

        // Jagged detail
        float elevNorm = clamp((heightBeforeJagged + 2.0) / 25.0, 0.0, 1.0);
        float jaggedScale = heightBeforeJagged < 1.5 ? max(0.1, (heightBeforeJagged + 0.5) / 10.0) : 1.0;
        float jagged = perlinNoise(vec3(x * 0.8, z * 0.8, 900.0)) * 1.2 * elevNorm * jaggedScale +
                      perlinNoise(vec3(x * 1.6, z * 1.6, 901.0)) * 0.6 * elevNorm * jaggedScale;

        float height = heightBeforeJagged + jagged;

        // ========== TERRAIN FLOOR START (DELETE FROM HERE TO REMOVE FLOOR) ==========
        // Exponential compression floor to prevent water puddles while preserving variation
        // Starts compressing at 1.9, asymptotically approaches 1.3 minimum
        if (height < 1.9) {
            float belowAmount = 1.9 - height;
            float maxCompression = 0.6; // (1.9 - 1.3) maximum drop
            float compressed = maxCompression * (1.0 - exp(-belowAmount * 0.5));
            height = 1.9 - compressed; // Approaches 1.3 but never quite reaches it
        }
        // ========== TERRAIN FLOOR END (DELETE TO HERE TO REMOVE FLOOR) ==========

        // ========== OCEAN GENERATION START (DELETE FROM HERE TO REMOVE OCEAN) ==========
        // Create ocean by lowering terrain smoothly and randomly
        // Coastline position varies between x=0 and x=20 based on z position
        float coastlineThreshold = 10.0 + perlinNoise(vec3(z * 0.01, 777.0, 0.0)) * 10.0;
        float transitionWidth = 8.0; // Units over which to blend from land to ocean

        // Calculate distance from threshold (positive = ocean side, negative = land side)
        float distanceFromThreshold = x - coastlineThreshold;

        // Create smooth transition using smoothstep function
        // t goes from 0 (before transition) to 1 (after transition)
        float t = clamp((distanceFromThreshold + transitionWidth) / (transitionWidth * 2.0), 0.0, 1.0);
        float smoothTransition = t * t * (3.0 - 2.0 * t); // Smoothstep S-curve

        if (smoothTransition > 0.0) {
            float oceanDistance = max(0.0, distanceFromThreshold);

            // Reduce noise intensity as distance from coast increases (smoother deep ocean)
            float noiseIntensity = 1.0 / (1.0 + oceanDistance * 0.05);

            // Add noise for varied coastline - intensity reduces with distance
            float coastlineNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 999.0)) * 5.0 * noiseIntensity;
            float adjustedDistance = max(0.0, oceanDistance + coastlineNoise);

            // Gradually deepen as distance increases - depth noise also reduces with distance
            float depthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 888.0)) * 2.0 * noiseIntensity;
            float depthFactor = (adjustedDistance * 0.5) + depthNoise;

            // Apply ocean effect gradually based on transition
            height -= depthFactor * smoothTransition;

            // Cap at ocean floor
            height = max(height, -3.0);
        }
        // ========== OCEAN GENERATION END (DELETE TO HERE TO REMOVE OCEAN) ==========

        // ========== RIVER GENERATION START (DELETE FROM HERE TO REMOVE RIVER) ==========
        // Create rivers at random intervals along the Z-axis (every 100-300 units)
        // Rivers run parallel to the coast, perpendicular to ocean

        float riverSegmentSize = 200.0; // Average spacing between rivers
        float riverTransitionWidth = 8.0; // Units over which to blend
        float riverWidth = 10.0; // Distance from first bank to center (and center to far bank)

        // Determine which river segment we're in
        float riverSegment = floor(z / riverSegmentSize);

        // Use segment number to generate deterministic random values for this segment
        float segmentSeed = riverSegment * 73856093.0; // Large prime for good distribution
        float segmentRandom = abs(sin(segmentSeed) * 43758.5453123);
        float hasRiver = mod(segmentRandom, 1.0) > 0.3 ? 1.0 : 0.0; // 70% chance of river in this segment

        if (hasRiver > 0.5) {
            // Random offset within segment (0-100 range gives 100-300 spacing variability)
            float riverOffsetInSegment = mod(segmentRandom * 7919.0, 1.0) * 100.0; // Use different multiplier for offset
            float riverCenterZ = riverSegment * riverSegmentSize + riverOffsetInSegment + 10.0;

            // River meanders based on x position
            float riverMeanderOffset = perlinNoise(vec3(x * 0.01, 666.0 + riverSegment, 0.0)) * 10.0;
            float riverThreshold = riverCenterZ + riverMeanderOffset;

            // Calculate distance from river threshold
            float riverDistanceFromThreshold = z - riverThreshold;

            // River occupies z = threshold to threshold + 20 (two 10-unit banks)
            if (riverDistanceFromThreshold >= -riverTransitionWidth && riverDistanceFromThreshold <= riverWidth * 2.0 + riverTransitionWidth) {
                float riverDepthFactor = 0.0;

                if (riverDistanceFromThreshold <= riverWidth) {
                    // First bank (z = threshold to threshold + 10)
                    float t = clamp((riverDistanceFromThreshold + riverTransitionWidth) / (riverTransitionWidth * 2.0), 0.0, 1.0);
                    float smoothTransition = t * t * (3.0 - 2.0 * t);

                    if (smoothTransition > 0.0) {
                        float riverDistance = max(0.0, riverDistanceFromThreshold);
                        float noiseIntensity = 1.0 / (1.0 + riverDistance * 0.05);
                        float riverBankNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 555.0)) * 5.0 * noiseIntensity;
                        float adjustedRiverDistance = max(0.0, riverDistance + riverBankNoise);
                        float riverDepthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 444.0)) * 2.0 * noiseIntensity;
                        riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                    }
                } else {
                    // Second bank (z = threshold + 10 to threshold + 20)
                    float reversedDistance = riverWidth * 2.0 - riverDistanceFromThreshold;
                    float t = clamp((reversedDistance + riverTransitionWidth) / (riverTransitionWidth * 2.0), 0.0, 1.0);
                    float smoothTransition = t * t * (3.0 - 2.0 * t);

                    if (smoothTransition > 0.0) {
                        float riverDistance = max(0.0, reversedDistance);
                        float noiseIntensity = 1.0 / (1.0 + riverDistance * 0.05);
                        float riverBankNoise = perlinNoise(vec3(x * 0.02, z * 0.02, 555.0)) * 5.0 * noiseIntensity;
                        float adjustedRiverDistance = max(0.0, riverDistance + riverBankNoise);
                        float riverDepthNoise = perlinNoise(vec3(x * 0.05, z * 0.05, 444.0)) * 2.0 * noiseIntensity;
                        riverDepthFactor = ((adjustedRiverDistance * 0.5) + riverDepthNoise) * smoothTransition;
                    }
                }

                // Apply river effect
                height -= riverDepthFactor;
                height = max(height, -3.0);
            }
        }
        // ========== RIVER GENERATION END (DELETE TO HERE TO REMOVE RIVER) ==========

        return height;
    }

    float sampleTerrainHeight(vec2 worldPos) {
        // Convert world position to texture coordinates
        vec2 texCoord = (worldPos - u_chunk_offset) / u_chunk_size + 0.5;

        // Sample the height texture
        float normalizedHeight = texture2D(u_height_texture, texCoord).r;

        // Convert from normalized [0,1] back to world height range
        float minHeight = -10.0;
        float maxHeight = 80.0;
        return normalizedHeight * (maxHeight - minHeight) + minHeight;
    }

    void main() {
        // Sample terrain height and calculate depth
        float terrainHeight = sampleTerrainHeight(vWorldPosition.xz);

        // Calculate water depth: positive where water should be, negative where terrain is above water
        float waterDepth = u_water_level - terrainHeight;

        // Discard fragments where terrain is above water level
        if (waterDepth < 0.0) discard;

        // Use waterDepth for all depth-based calculations
        float local_depth = waterDepth;
        
        // Simplified normal mapping (from old version approach)
        vec2 worldUV = vWorldPosition.xz * 0.02; // Scale world coordinates
vec2 scrolledUvA = worldUV * 8.0 * u_texture_scale + vec2(u_time * 0.003, u_time * 0.0024);
vec2 scrolledUvB = worldUV * 12.0 * u_texture_scale + vec2(u_time * -0.0018, u_time * 0.0036);
vec2 scrolledUvC = worldUV * 15.0 * u_texture_scale + vec2(u_time * 0.0012, u_time * -0.0021);
        
        vec3 normalSampleA = texture2D(u_normal_texture, scrolledUvA).rgb;
        vec3 normalSampleB = texture2D(u_normal_texture, scrolledUvB).rgb;
        vec3 normalSampleC = texture2D(u_normal_texture, scrolledUvC).rgb;

        // Fix: Ensure Z component is positive for tangent space normals
        vec3 normalA = vec3(normalSampleA.xy * 2.0 - 1.0, normalSampleA.z);
        vec3 normalB = vec3(normalSampleB.xy * 2.0 - 1.0, normalSampleB.z);
        vec3 normalC = vec3(normalSampleC.xy * 2.0 - 1.0, normalSampleC.z);

        normalA = normalize(normalA);
        normalB = normalize(normalB);
        normalC = normalize(normalC);
        
        vec3 blendedNormal = normalize(normalA + normalB * 0.5 + normalC * 0.3);
        vec3 perturbedNormal = normalize(mix(vWorldNormal, blendedNormal, u_normal_scale * 0.3));
        
        // Clear depth zones (from old version)
        // 0 - 1.5   : shallow
        // 1.5 - 2.0 : transition  
        // > 2.0     : deep
        float shallowFactor = clamp(local_depth / 1.5, 0.0, 1.0);
        float transitionFactor = smoothstep(1.5, 2.0, local_depth);
        
        // Base color with clean depth-based mixing
        vec3 waterBaseColor = mix(u_shallow_color.rgb, u_deep_color.rgb, transitionFactor);
        
        // Clean transparency zones (from old version)
        float alpha;
        if (local_depth <= 1.5) {
            alpha = mix(0.3, 0.8, shallowFactor);  // fade in shallow
        } else if (local_depth <= 2.0) {
            alpha = mix(0.8, 1.0, transitionFactor); // transition zone
        } else {
            alpha = 1.0; // full opacity deep
        }
        alpha *= u_transparency;
        
        // View direction and fresnel
        vec3 viewDir = normalize(vViewPosition);
        float fresnel = pow(1.0 - max(dot(viewDir, perturbedNormal), 0.0), 1.5);
        
        // Sky reflection
        vec3 skyColor = vec3(0.0);
        if (u_enable_reflections) {
            vec3 reflectedDir = reflect(-viewDir, perturbedNormal);
            vec2 skyUv = reflectedDir.xz * 0.5 + 0.5;
            skyColor = texture2D(u_sky_reflection_texture, skyUv).rgb;
        }
        
        // Specular highlights
        vec3 halfVector = normalize(u_sun_direction + viewDir);
        float specular = pow(max(dot(perturbedNormal, halfVector), 0.0), u_shininess);
        vec3 specularColor = u_sun_color * specular;
        
        // Foam calculation - depth-based with adjustable wave influence
        float foam = 0.0;
        if (u_enable_foam) {
            // Improved depth-based foam factor with smooth fades on BOTH sides
            float fadeInWidth = 0.05;   // Fade in from shore
            float fadeOutWidth = 0.15;  // Fade out toward ocean (wider for smoother transition)

            // Fade IN from shore side (depth increases from min)
            float fadeIn = smoothstep(u_foam_min_depth, u_foam_min_depth + fadeInWidth, local_depth);

            // Fade OUT on ocean side (depth increases past max) - FIXED: was backwards!
            float fadeOut = 1.0 - smoothstep(u_foam_max_depth, u_foam_max_depth + fadeOutWidth, local_depth);

            // Combine both fades
            float depthFoamFactor = fadeIn * fadeOut;

            // Wave slope influence (adjustable via GUI)
            float waveFoamFactor = smoothstep(0.001, 0.02, vWaveSlope);

            // Combine depth and wave influences
            foam = depthFoamFactor * mix(1.0, waveFoamFactor, u_foam_wave_influence);

            // Add time-based foam animation for variation
            float foamNoise = sin(local_depth * 50.0 + u_time * 2.0) * 0.5 + 0.5;
            foam *= foamNoise * 0.3 + 0.7; // Subtle variation

            foam *= 2.0; // Boost visibility
            foam = clamp(foam, 0.0, 1.0);
        }
        
        // Caustics (simplified from old version)
        vec3 causticsColor = vec3(0.0);
        if (u_enable_caustics && local_depth < 2.0) {
            vec2 causticsUv1 = vUv * 6.0 + vec2(u_time * 0.002, u_time * 0.0015);
            vec2 causticsUv2 = vUv * 8.5 + vec2(u_time * -0.0012, u_time * 0.0018);
            
            vec3 caustics1 = texture2D(u_caustics_texture, causticsUv1).rgb;
            vec3 caustics2 = texture2D(u_caustics_texture, causticsUv2).rgb;
            causticsColor = mix(caustics1, caustics2, 0.5);
            
            float causticsIntensity = (1.0 - local_depth) * u_caustics_intensity;
            causticsIntensity *= sin(u_time * 1.5) * 0.3 + 0.7;
            causticsColor *= causticsIntensity * vec3(0.8, 1.0, 0.9);
        }
        
        // Final color combination (from old version)
        vec3 finalColor = waterBaseColor;
        
        // Add sky reflection
        finalColor = mix(finalColor, skyColor, fresnel * 0.4);
        
        // Add specular highlights
        finalColor += specularColor * 0.6;
        
        // Add caustics
        finalColor += causticsColor;
        
        // Add foam
        if (u_enable_foam) {
            // Use pure white foam color to avoid pink tint
            vec3 pureWhiteFoam = vec3(1.0, 1.0, 1.0);
            finalColor = mix(finalColor, pureWhiteFoam, foam); // Full foam blend for maximum visibility
            alpha = mix(alpha, 1.0, foam); // Fully opaque foam
        }
        
        gl_FragColor = vec4(finalColor, alpha);
    }
`;

// --- Main Hybrid WaterRenderer Class ---
export class WaterRenderer {
    constructor(scene = null, waterLevel = 1.02, terrainRenderer = null) {  //requires change in game.js
        this.scene = scene || this.createTestScene();
        this.waterLevel = waterLevel;
        this.terrainRenderer = terrainRenderer;
        this.waterChunks = new Map();
        this.sharedMaterial = null;
        this.uniforms = {};
        this.heightTextures = new Map();
        this.gui = null;
        
        // Texture references
        this.normalTexture = null;
        this.causticsTexture = null;
        this.skyReflectionTexture = null;
        this.foamTexture = null;
        
        // Performance optimization
        this.lastUpdateTime = 0;
        this.updateInterval = 16; // ~60fps cap
        
        // Create fallback textures immediately
        this.createFallbackTextures();
        
        // Create material with fallback textures first
        this.createSharedMaterial();
        
        // Setup GUI
        this.setupGUI();
        
        // Then load better textures asynchronously
        this.init();
    }

    createTestScene() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5);
        scene.add(directionalLight);
        
        return scene;
    }

    async init() {
        await this.loadTextures();
        // Update the existing material with the loaded textures
        this.updateMaterialTextures();
    }

    async loadTextures() {
    const loader = new THREE.TextureLoader();
    
    try {
        console.log('Loading water textures...');
        
        // Load textures with fallback handling
        try {
            const newNormalTexture = await this.loadTexture(loader, './terrain/water_normal.png');
            this.setupTextureProperties(newNormalTexture, true);
            this.normalTexture = newNormalTexture;
        } catch (e) {
            console.warn('Failed to load normal texture, keeping fallback');
        }
        
        try {
            const newCausticsTexture = await this.loadTexture(loader, './terrain/caustics.png');
            this.setupTextureProperties(newCausticsTexture, true);
            this.causticsTexture = newCausticsTexture;
        } catch (e) {
            console.warn('Failed to load caustics texture, keeping fallback');
        }
        
        try {
            const newSkyTexture = await this.loadTexture(loader, './terrain/sky_reflection.png');
            this.setupTextureProperties(newSkyTexture, false);
            this.skyReflectionTexture = newSkyTexture;
        } catch (e) {
            console.warn('Failed to load sky reflection texture, keeping fallback');
        }
        
        try {
            const newFoamTexture = await this.loadTexture(loader, './terrain/foam.png');
            this.setupTextureProperties(newFoamTexture, true);
            this.foamTexture = newFoamTexture;
        } catch (e) {
            console.warn('Failed to load foam texture, keeping fallback');
        }
        
        console.log('Water texture loading completed');
    } catch (error) {
        console.warn('Texture loading error:', error);
    }
}

    loadTexture(loader, path) {
        return new Promise((resolve, reject) => {
            loader.load(path, resolve, undefined, reject);
        });
    }

setupTextureProperties(texture, repeat) {
    // Only set properties if texture hasn't been uploaded to GPU yet
    if (texture.image && texture.version === 0) {
        if (repeat) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        } else {
            texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        }
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
    }
}

    createFallbackTextures() {
        // Create fallback textures
        if (!this.normalTexture) {
            this.normalTexture = this.createFallbackNormalTexture(64);
        }
        
        if (!this.causticsTexture) {
            this.causticsTexture = this.createFallbackCausticsTexture(64);
        }
        
        if (!this.skyReflectionTexture) {
            this.skyReflectionTexture = this.createFallbackSkyTexture(128);
        }
        
        if (!this.foamTexture) {
            this.foamTexture = this.createFallbackFoamTexture(64);
        }
    }

    createFallbackNormalTexture(size = 64) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const imgData = ctx.createImageData(size, size);
        const data = imgData.data;
        
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const index = (y * size + x) * 4;
                const wave = Math.sin(x * 0.2) * Math.cos(y * 0.2);
                data[index] = 128 + wave * 30; // R (X normal)
                data[index + 1] = 128 - wave * 30; // G (Y normal) - inverted for correct direction
                data[index + 2] = 255;
                data[index + 3] = 255; // A
            }
        }
        
        ctx.putImageData(imgData, 0, 0);
        const texture = new THREE.CanvasTexture(canvas);
        this.setupTextureProperties(texture, true);
        return texture;
    }

    createFallbackCausticsTexture(size = 64) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, size, size);
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * (size / 8));
            for (let x = 0; x < size; x += 2) {
                const y = i * (size / 8) + Math.sin(x * 0.2 + i) * (size / 16);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        this.setupTextureProperties(texture, true);
        return texture;
    }

createFallbackSkyTexture(size = 64) {
            const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const gradient = ctx.createLinearGradient(0, 0, 0, size);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.7, '#98D8E8');
        gradient.addColorStop(1, '#B0E0E6');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        
        const texture = new THREE.CanvasTexture(canvas);
        this.setupTextureProperties(texture, false);
        return texture;
    }

    createFallbackFoamTexture(size = 64) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        // Add some texture
        for (let i = 0; i < 100; i++) {
            ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.5 + 0.5})`;
            ctx.beginPath();
            ctx.arc(Math.random() * size, Math.random() * size, Math.random() * 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        this.setupTextureProperties(texture, true);
        return texture;
    }

createDefaultHeightTexture() {
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    
    return texture;
}

    createSharedMaterial() {
        const defaultHeightTexture = this.createDefaultHeightTexture();
        
        // Use old version's appealing colors
        const shallowColor = new THREE.Color(0x00ba71); // Deep blue from old version
        const deepColor = new THREE.Color(0x00ba71);    // Deeper blue from old version
        const foamColor = new THREE.Color(0xffffff);
        
        this.uniforms = {
            // Time and animation
            u_time: { value: 0.0 },
            u_wave_speed: { value: 0.27 },
            
            // Wave parameters (old version defaults)
            u_wave_height: { value: 0.085 },
            u_wave_frequency: { value: 1.1 },
            
            // Colors (old version colors)
            u_shallow_color: { value: new THREE.Vector4(shallowColor.r, shallowColor.g, shallowColor.b, 1.0) },
            u_deep_color: { value: new THREE.Vector4(deepColor.r, deepColor.g, deepColor.b, 1.0) },
            u_foam_color: { value: new THREE.Vector4(foamColor.r, foamColor.g, foamColor.b, 1.0) },
            
            // Textures
            u_height_texture: { value: defaultHeightTexture },
            u_normal_texture: { value: this.normalTexture },
            u_caustics_texture: { value: this.causticsTexture },
            u_sky_reflection_texture: { value: this.skyReflectionTexture },
            u_foam_texture: { value: this.foamTexture },
            
            // Lighting (old version defaults)
            u_sun_direction: { value: new THREE.Vector3(0.5, 0.8, 0.3).normalize() },
            u_sun_color: { value: new THREE.Color(0xfff8dc) },
            
            // Material properties
            u_water_level: { value: this.waterLevel },
            u_chunk_size: { value: 50.0 },
            u_chunk_offset: { value: new THREE.Vector2(0, 0) },
            
            // GUI parameters (old version defaults)
            u_shininess: { value: 1.0 },
            u_foam_threshold: { value: 5.0 },
            u_normal_scale: { value: 0.0 },
            u_texture_scale: { value: 0.6 },
            u_transparency: { value: 1.0 },
            u_caustics_intensity: { value: 0.13 },
            u_enable_caustics: { value: true },
            u_enable_foam: { value: true },
            u_enable_reflections: { value: true },

            // Wave damping controls
            u_wave_damp_min_depth: { value: 0.1 },
            u_wave_damp_max_depth: { value: 0.01 },
            u_deep_water_threshold: { value: 0.7 },

            // Foam controls
            u_foam_min_depth: { value: 0.0 },
            u_foam_max_depth: { value: 0.15 },
            u_foam_wave_influence: { value: 1.0 }
        };
        
        this.sharedMaterial = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: waterVertexShader,
            fragmentShader: waterFragmentShader,
            transparent: true,
            depthWrite: true,  
            depthTest: true,  
            fog: false,
            side: THREE.FrontSide
        });
    }

    setupGUI() {
        // GUI removed - water settings are configured in constructor
        return;
        
        // Helper object to hold adjustable values
        this.controls = {
            waveHeight: this.uniforms.u_wave_height.value,
            waveFrequency: this.uniforms.u_wave_frequency.value,
            waveSpeed: this.uniforms.u_wave_speed.value,
            shallowColor: '#' + new THREE.Color(this.uniforms.u_shallow_color.value.x, this.uniforms.u_shallow_color.value.y, this.uniforms.u_shallow_color.value.z).getHexString(),
            deepColor: '#' + new THREE.Color(this.uniforms.u_deep_color.value.x, this.uniforms.u_deep_color.value.y, this.uniforms.u_deep_color.value.z).getHexString(),
            foamColor: '#' + new THREE.Color(this.uniforms.u_foam_color.value.x, this.uniforms.u_foam_color.value.y, this.uniforms.u_foam_color.value.z).getHexString(),
            shininess: this.uniforms.u_shininess.value,
            foamThreshold: this.uniforms.u_foam_threshold.value,
            normalScale: this.uniforms.u_normal_scale.value,
            textureScale: this.uniforms.u_texture_scale.value,
            transparency: this.uniforms.u_transparency.value,
            causticsIntensity: this.uniforms.u_caustics_intensity.value,
            sunDirectionX: this.uniforms.u_sun_direction.value.x,
            sunDirectionY: this.uniforms.u_sun_direction.value.y,
            sunDirectionZ: this.uniforms.u_sun_direction.value.z,
            waterLevel: this.waterLevel,
            enableCaustics: this.uniforms.u_enable_caustics.value,
            enableFoam: this.uniforms.u_enable_foam.value,
            enableReflections: this.uniforms.u_enable_reflections.value,
            waveDampMinDepth: this.uniforms.u_wave_damp_min_depth.value,
            waveDampMaxDepth: this.uniforms.u_wave_damp_max_depth.value,
            deepWaterThreshold: this.uniforms.u_deep_water_threshold.value,
            foamMinDepth: this.uniforms.u_foam_min_depth.value,
            foamMaxDepth: this.uniforms.u_foam_max_depth.value,
            foamWaveInfluence: this.uniforms.u_foam_wave_influence.value
        };
        
        // GUI Folders
        const wavesFolder = this.gui.addFolder('Waves & Animation');
        wavesFolder.add(this.controls, 'waveHeight', 0.001, 0.2).name('Wave Height').onChange((v) => { 
            this.uniforms.u_wave_height.value = v; 
            this.updateMaterials(); 
        });
        wavesFolder.add(this.controls, 'waveFrequency', 0.01, 2.0).name('Wave Frequency').onChange((v) => { 
            this.uniforms.u_wave_frequency.value = v; 
            this.updateMaterials(); 
        });
        wavesFolder.add(this.controls, 'waveSpeed', 0.0, 3.0).name('Wave Speed').onChange((v) => { 
            this.uniforms.u_wave_speed.value = v; 
            this.updateMaterials(); 
        });
        
        const colorsFolder = this.gui.addFolder('Colors & Appearance');
        colorsFolder.addColor(this.controls, 'shallowColor').name('Shallow Color').onChange((v) => { 
            this.updateColor(this.uniforms.u_shallow_color, v); 
        });
        colorsFolder.addColor(this.controls, 'deepColor').name('Deep Color').onChange((v) => { 
            this.updateColor(this.uniforms.u_deep_color, v); 
        });
        colorsFolder.addColor(this.controls, 'foamColor').name('Foam Color').onChange((v) => { 
            this.updateColor(this.uniforms.u_foam_color, v); 
        });
        colorsFolder.add(this.controls, 'transparency', 0.0, 1.0).name('Transparency').onChange((v) => { 
            this.uniforms.u_transparency.value = v; 
            this.updateMaterials(); 
        });
        
        const lightingFolder = this.gui.addFolder('Lighting & Effects');
        lightingFolder.add(this.controls, 'shininess', 1.0, 256.0).name('Shininess').onChange((v) => { 
            this.uniforms.u_shininess.value = v; 
            this.updateMaterials(); 
        });
        lightingFolder.add(this.controls, 'foamThreshold', 0.0, 10.0).name('Foam Threshold').onChange((v) => { 
            this.uniforms.u_foam_threshold.value = v; 
            this.updateMaterials(); 
        });
        lightingFolder.add(this.controls, 'normalScale', 0.0, 5.0).name('Normal Scale').onChange((v) => { 
            this.uniforms.u_normal_scale.value = v; 
            this.updateMaterials(); 
        });
        lightingFolder.add(this.controls, 'textureScale', 0.5, 5.0).name('Texture Scale').onChange((v) => { 
            this.uniforms.u_texture_scale.value = v; 
            this.updateMaterials(); 
        });
        lightingFolder.add(this.controls, 'causticsIntensity', 0.0, 1.0).name('Caustics Intensity').onChange((v) => { 
            this.uniforms.u_caustics_intensity.value = v; 
            this.updateMaterials(); 
        });
        lightingFolder.add(this.controls, 'sunDirectionX', -1, 1).name('Sun Dir X').onChange(() => this.updateSunDirection());
        lightingFolder.add(this.controls, 'sunDirectionY', -1, 1).name('Sun Dir Y').onChange(() => this.updateSunDirection());
        lightingFolder.add(this.controls, 'sunDirectionZ', -1, 1).name('Sun Dir Z').onChange(() => this.updateSunDirection());
        
        const globalFolder = this.gui.addFolder('Global Settings');
        globalFolder.add(this.controls, 'waterLevel', -5, 5).name('Water Level').onChange((v) => { 
            this.waterLevel = v; 
            this.uniforms.u_water_level.value = v; 
            this.waterChunks.forEach(m => m.position.y = v); 
            this.updateMaterials(); 
        });
        globalFolder.add(this.controls, 'enableCaustics').name('Enable Caustics').onChange((v) => { 
            this.uniforms.u_enable_caustics.value = v; 
            this.updateMaterials(); 
        });
        globalFolder.add(this.controls, 'enableFoam').name('Enable Foam').onChange((v) => { 
            this.uniforms.u_enable_foam.value = v; 
            this.updateMaterials(); 
        });
        globalFolder.add(this.controls, 'enableReflections').name('Enable Reflections').onChange((v) => {
            this.uniforms.u_enable_reflections.value = v;
            this.updateMaterials();
        });

        const foamFolder = this.gui.addFolder('Foam & Wave Damping');
        foamFolder.add(this.controls, 'waveDampMinDepth', 0.0, 1.0).name('Wave Damp Min Depth').onChange((v) => {
            this.uniforms.u_wave_damp_min_depth.value = v;
            this.updateMaterials();
        });
        foamFolder.add(this.controls, 'waveDampMaxDepth', 0.0, 2.0).name('Wave Damp Max Depth').onChange((v) => {
            this.uniforms.u_wave_damp_max_depth.value = v;
            this.updateMaterials();
        });
        foamFolder.add(this.controls, 'deepWaterThreshold', 0.0, 2.0).name('Deep Water Threshold').onChange((v) => {
            this.uniforms.u_deep_water_threshold.value = v;
            this.updateMaterials();
        });
        foamFolder.add(this.controls, 'foamMinDepth', 0.0, 0.5).name('Foam Min Depth').onChange((v) => {
            this.uniforms.u_foam_min_depth.value = v;
            this.updateMaterials();
        });
        foamFolder.add(this.controls, 'foamMaxDepth', 0.0, 1.0).name('Foam Max Depth').onChange((v) => {
            this.uniforms.u_foam_max_depth.value = v;
            this.updateMaterials();
        });
        foamFolder.add(this.controls, 'foamWaveInfluence', 0.0, 1.0).name('Foam Wave Influence').onChange((v) => {
            this.uniforms.u_foam_wave_influence.value = v;
            this.updateMaterials();
        });

        // Water chunks debug info
        const debugFolder = this.gui.addFolder('Debug Info');
        debugFolder.add({ count: () => this.waterChunks.size }, 'count').name('Active Chunks').listen();
    }

    updateColor(uniform, hex) {
        try {
            const color = new THREE.Color(hex);
            uniform.value.set(color.r, color.g, color.b, 1.0);
            this.updateMaterials();
        } catch (error) {
            console.error('Error updating color:', error);
        }
    }

    updateSunDirection() {
        try {
            this.uniforms.u_sun_direction.value.set(
                this.controls.sunDirectionX,
                this.controls.sunDirectionY,
                this.controls.sunDirectionZ
            ).normalize();
            this.updateMaterials();
        } catch (error) {
            console.error('Error updating sun direction:', error);
        }
    }

    updateMaterials() {
        this.waterChunks.forEach((mesh) => {
            if (mesh.material && mesh.material.uniforms) {
                // Copy all uniforms except chunk-specific ones
                Object.keys(this.uniforms).forEach(key => {
                    if (key !== 'u_chunk_offset' && key !== 'u_height_texture') {
                        if (mesh.material.uniforms[key]) {
                            if (this.uniforms[key].value.copy) {
                                mesh.material.uniforms[key].value.copy(this.uniforms[key].value);
                            } else {
                                mesh.material.uniforms[key].value = this.uniforms[key].value;
                            }
                        }
                    }
                });
                mesh.material.needsUpdate = true;
            }
        });
    }

    updateMaterialTextures() {
    // Dispose old textures before replacing them
    if (this.uniforms.u_normal_texture) {
        const old = this.uniforms.u_normal_texture.value;
        if (old && old.dispose && old !== this.normalTexture) old.dispose();
        this.uniforms.u_normal_texture.value = this.normalTexture;
    }
    if (this.uniforms.u_caustics_texture) {
        const old = this.uniforms.u_caustics_texture.value;
        if (old && old.dispose && old !== this.causticsTexture) old.dispose();
        this.uniforms.u_caustics_texture.value = this.causticsTexture;
    }
    if (this.uniforms.u_sky_reflection_texture) {
        const old = this.uniforms.u_sky_reflection_texture.value;
        if (old && old.dispose && old !== this.skyReflectionTexture) old.dispose();
        this.uniforms.u_sky_reflection_texture.value = this.skyReflectionTexture;
    }
    if (this.uniforms.u_foam_texture) {
        const old = this.uniforms.u_foam_texture.value;
        if (old && old.dispose && old !== this.foamTexture) old.dispose();
        this.uniforms.u_foam_texture.value = this.foamTexture;
    }
    
    // Force material updates
    if (this.sharedMaterial) {
        this.sharedMaterial.needsUpdate = true;
    }
    
    this.updateMaterials();
}

    generateHeightTexture(chunkX, chunkZ, heightCalculator) {
        const size = 128; // Higher resolution for better accuracy
        const chunkSize = 50;
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(size, size);
        const data = imgData.data;
        
        const minHeight = -10;
        const maxHeight = 80;
        const heightRange = maxHeight - minHeight;
        
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Calculate world coordinates matching terrain vertex positions
                // x/size gives 0 to 1, multiply by chunkSize for full range,
                // subtract chunkSize/2 to center at chunk position
                const worldX = chunkX + (x / (size - 1) - 0.5) * chunkSize;
                const worldZ = chunkZ + (y / (size - 1) - 0.5) * chunkSize;
                
                const height = heightCalculator.calculateHeight(worldX, worldZ);
                const normalizedHeight = Math.max(0, Math.min(1, (height - minHeight) / heightRange));
                const heightValue = Math.floor(normalizedHeight * 255);
                
                const index = (y * size + x) * 4;
                data[index] = heightValue;
                data[index + 1] = heightValue;
                data[index + 2] = heightValue;
                data[index + 3] = 255;
            }
        }
        
        ctx.putImageData(imgData, 0, 0);
        
        const texture = new THREE.CanvasTexture(canvas);
texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
texture.minFilter = THREE.LinearFilter;
texture.magFilter = THREE.LinearFilter;
texture.generateMipmaps = false;
texture.flipY = false;

return texture;
    }

    addWaterChunk(chunkX, chunkZ, heightTexture = null) {
        const key = `${chunkX},${chunkZ}`;
        if (this.waterChunks.has(key)) return;

        // Use old version's geometry settings
        const geometry = new THREE.PlaneGeometry(50, 50, 100, 100);
        geometry.rotateX(-Math.PI / 2);

        // Clone the shared material for each chunk
        const material = this.sharedMaterial.clone();

        // Set chunk-specific uniforms
        material.uniforms.u_chunk_offset.value.set(chunkX, chunkZ);

        // Set height texture if provided
        if (heightTexture) {
            material.uniforms.u_height_texture.value = heightTexture;
            this.heightTextures.set(key, heightTexture);
        }

        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(chunkX, this.waterLevel, chunkZ);
        
        this.scene.add(mesh);
        this.waterChunks.set(key, mesh);
        
        //console.log(`Hybrid water chunk added successfully at (${chunkX}, ${chunkZ})`);
    }

    removeWaterChunk(chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        const mesh = this.waterChunks.get(key);
        
        if (mesh) {
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
            this.waterChunks.delete(key);
            
            const heightTexture = this.heightTextures.get(key);
            if (heightTexture && heightTexture !== this.uniforms.u_height_texture.value) {
                heightTexture.dispose();
                this.heightTextures.delete(key);
            }
            
            console.log(`Hybrid water chunk removed at (${chunkX}, ${chunkZ})`);
        }
    }

    clearWaterChunks() {
        this.waterChunks.forEach((mesh, key) => {
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
        });
        this.waterChunks.clear();
        
        this.heightTextures.forEach((texture) => {
            if (texture !== this.uniforms.u_height_texture.value) {
                texture.dispose();
            }
        });
        this.heightTextures.clear();
    }

    update(time, camera = null) {
        if (time - this.lastUpdateTime < this.updateInterval) {
            return;
        }
        this.lastUpdateTime = time;
        
        const timeValue = time * 0.001;
        
        // Update time uniform for each water chunk's material
        this.waterChunks.forEach((mesh, key) => {
            if (mesh.material && mesh.material.uniforms) {
                if (mesh.material.uniforms.u_time) {
                    mesh.material.uniforms.u_time.value = timeValue;
                }
                
                // Update chunk-specific terrain height
                if (this.terrainRenderer) {
                    const [chunkX, chunkZ] = key.split(',').map(Number);
                    // This would need to be implemented in your terrain renderer
                    // const terrainHeight = this.terrainRenderer.getTerrainHeightAt(chunkX, chunkZ);
                    // mesh.material.uniforms.u_terrain_height.value = terrainHeight;
                }
            }
        });
    }

    getWaterHeightAt(x, z, time) {
        const freq = this.uniforms.u_wave_frequency.value;
        const height = this.uniforms.u_wave_height.value;
        const speed = this.uniforms.u_wave_speed.value;
        
        // Use old version's 3-wave system
        let waveHeight = 0;
        waveHeight += Math.sin(x * freq + time * 1.5 * speed) * Math.cos(z * freq * 0.7 + time * 1.2 * speed) * 0.5;
        waveHeight += Math.sin(x * freq * 1.8 + time * 2.1 * speed) * Math.cos(z * freq * 1.19 + time * 1.68 * speed) * 0.3;
        waveHeight += Math.sin(x * freq * 2.3 + time * 1.8 * speed) * Math.cos(z * freq * 1.61 + time * 1.44 * speed) * 0.2;
        
        return this.waterLevel + waveHeight * height;
    }

    getWaterChunks() {
        return Array.from(this.waterChunks.values());
    }

    // Compatibility methods from old version
    setupTestControls() {
        // This method exists for backward compatibility
        // The GUI is automatically set up in the constructor
        console.log('setupTestControls called - GUI already initialized');
    }

    getTestScene() {
        return this.scene;
    }

    dispose() {
        this.clearWaterChunks();
        
        if (this.sharedMaterial) {
            this.sharedMaterial.dispose();
        }
        
        // Dispose textures
        if (this.normalTexture) this.normalTexture.dispose();
        if (this.causticsTexture) this.causticsTexture.dispose();
        if (this.skyReflectionTexture) this.skyReflectionTexture.dispose();
        if (this.foamTexture) this.foamTexture.dispose();
        
        if (this.uniforms.u_height_texture && this.uniforms.u_height_texture.value.dispose) {
            this.uniforms.u_height_texture.value.dispose();
        }
        
        if (this.gui) {
            this.gui.destroy();
        }
        
        console.log('Hybrid WaterRenderer disposed');
    }
}


================================================================================
FILE 9/11: public/audio.js
Location: C:\Users\colli\Desktop\test horses\horses\public\audio.js
Lines: 262
================================================================================

// File: public/audio.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\audio.js
// Audio manager for game sounds using THREE.js Audio API

import * as THREE from 'three';

export class AudioManager {
    constructor(camera) {
        this.camera = camera;
        this.listener = new THREE.AudioListener();
        this.camera.add(this.listener);

        this.audioLoader = new THREE.AudioLoader();
        this.sounds = {};
        this.isInitialized = false;
        this.contextResumed = false;
    }

    /**
     * Resume AudioContext after user gesture (required by browsers)
     * Call this on first user interaction (click, touch, etc.)
     */
    resumeContext() {
        if (!this.contextResumed && this.listener.context) {
            if (this.listener.context.state === 'suspended') {
                this.listener.context.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                    this.contextResumed = true;
                });
            } else {
                this.contextResumed = true;
            }
        }
    }

    async loadSounds() {
        try {
            // Load axe sound
            const axeBuffer = await this.loadSound('sounds/axe.mp3');
            this.sounds.axe = axeBuffer;

            // Load saw sound
            const sawBuffer = await this.loadSound('sounds/saw.mp3');
            this.sounds.saw = sawBuffer;

            // Load pickaxe sound
            const pickaxeBuffer = await this.loadSound('sounds/pickaxe.mp3');
            this.sounds.pickaxe = pickaxeBuffer;

            // Load chisel sound
            const chiselBuffer = await this.loadSound('sounds/chisel.mp3');
            this.sounds.chisel = chiselBuffer;

            // Load hammer sound
            const hammerBuffer = await this.loadSound('sounds/hammer.mp3');
            this.sounds.hammer = hammerBuffer;

            this.isInitialized = true;
            console.log('Audio system initialized successfully');
        } catch (error) {
            console.error('Failed to load sounds:', error);
        }
    }

    loadSound(path) {
        return new Promise((resolve, reject) => {
            this.audioLoader.load(
                path,
                (buffer) => resolve(buffer),
                (progress) => {
                    // Loading progress
                },
                (error) => reject(error)
            );
        });
    }

    playAxeSound() {
        if (!this.isInitialized || !this.sounds.axe) {
            console.warn('Axe sound not loaded');
            return null;
        }

        const sound = new THREE.Audio(this.listener);
        sound.setBuffer(this.sounds.axe);
        sound.setLoop(true);
        sound.setVolume(0.5);
        sound.play();

        // Auto-stop after 10 seconds
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
        }, 10000);

        return sound;
    }

    playSawSound() {
        if (!this.isInitialized || !this.sounds.saw) {
            console.warn('Saw sound not loaded');
            return null;
        }

        const sound = new THREE.Audio(this.listener);
        sound.setBuffer(this.sounds.saw);
        sound.setLoop(false);  // Saw is 12s, we'll stop it at 10s
        sound.setVolume(0.5);
        sound.play();

        // Auto-stop after 10 seconds (original file is 12s)
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
        }, 10000);

        return sound;
    }

    playPickaxeSound() {
        if (!this.isInitialized || !this.sounds.pickaxe) {
            console.warn('Pickaxe sound not loaded');
            return null;
        }

        const sound = new THREE.Audio(this.listener);
        sound.setBuffer(this.sounds.pickaxe);
        sound.setLoop(true);  // Pickaxe is 1s, loop it for 10s
        sound.setVolume(0.5);
        sound.play();

        // Auto-stop after 10 seconds
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
        }, 10000);

        return sound;
    }

    playChiselSound() {
        if (!this.isInitialized || !this.sounds.chisel) {
            console.warn('Chisel sound not loaded');
            return null;
        }

        const sound = new THREE.Audio(this.listener);
        sound.setBuffer(this.sounds.chisel);
        sound.setLoop(false);  // Chisel plays once for 6s duration
        sound.setVolume(0.5);
        sound.play();

        // Auto-stop after 6 seconds
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
        }, 6000);

        return sound;
    }

    playHammerSound() {
        if (!this.isInitialized || !this.sounds.hammer) {
            console.warn('Hammer sound not loaded');
            return null;
        }

        const sound = new THREE.Audio(this.listener);
        sound.setBuffer(this.sounds.hammer);
        sound.setLoop(false);  // Hammer is 11s, we'll stop it at 6s
        sound.setVolume(0.5);
        sound.play();

        // Auto-stop after 6 seconds (original file is 11s)
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
        }, 6000);

        return sound;
    }

    /**
     * Play positional sound attached to an avatar (for other players)
     * @param {string} soundType - 'axe', 'saw', 'pickaxe', 'chisel', or 'hammer'
     * @param {THREE.Object3D} avatar - Avatar to attach sound to
     * @returns {THREE.PositionalAudio} The created sound object
     */
    playPositionalSound(soundType, avatar) {
        if (!this.isInitialized) {
            console.warn('Audio system not initialized');
            return null;
        }

        let buffer, duration;
        if (soundType === 'axe') {
            buffer = this.sounds.axe;
            duration = 10000;
        } else if (soundType === 'saw') {
            buffer = this.sounds.saw;
            duration = 10000;
        } else if (soundType === 'pickaxe') {
            buffer = this.sounds.pickaxe;
            duration = 10000;
        } else if (soundType === 'chisel') {
            buffer = this.sounds.chisel;
            duration = 6000;
        } else if (soundType === 'hammer') {
            buffer = this.sounds.hammer;
            duration = 6000;
        }

        if (!buffer) {
            console.warn(`${soundType} sound not loaded`);
            return null;
        }

        // Create positional audio (3D spatial sound)
        const sound = new THREE.PositionalAudio(this.listener);
        sound.setBuffer(buffer);
        sound.setRefDistance(5);  // Full volume within 5 units
        sound.setMaxDistance(50); // Silent at 50 units
        sound.setRolloffFactor(1); // Linear falloff
        sound.setDistanceModel('linear');

        // Set loop based on sound type (axe and pickaxe loop, saw and chisel don't)
        if (soundType === 'axe' || soundType === 'pickaxe') {
            sound.setLoop(true);
        } else {
            sound.setLoop(false);
        }

        sound.setVolume(0.5); // Base volume

        // Attach sound to avatar as child (moves with avatar)
        avatar.add(sound);
        sound.play();

        // Auto-stop and cleanup after duration
        setTimeout(() => {
            if (sound.isPlaying) {
                sound.stop();
            }
            avatar.remove(sound);
            sound.disconnect();
        }, duration);

        return sound;
    }

    cleanup() {
        if (this.listener) {
            this.camera.remove(this.listener);
        }
    }
}



================================================================================
FILE 10/11: public/config.js
Location: C:\Users\colli\Desktop\test horses\horses\public\config.js
Lines: 317
================================================================================

// File: public/config.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\config.js

/**
 * ==========================================
 * GAME CONFIGURATION AND CONSTANTS
 * ==========================================
 *
 * This file contains all game configuration values and constants.
 * Modify these values to adjust game balance, UI layout, and behavior.
 *
 * @file config.js
 * @description Centralized configuration for the multiplayer survival game
 *
 * USAGE:
 * - Import at the top of any file: import { CONFIG } from './config.js';
 * - Access values: CONFIG.INVENTORY.BACKPACK_COLS
 *
 * ORGANIZATION:
 * - Grouped by feature/system
 * - All times in milliseconds
 * - All sizes in pixels unless noted
 * - Comments explain impact of changing values
 */

export const CONFIG = {

    // ==========================================
    // INVENTORY SYSTEM
    // ==========================================
    INVENTORY: {
        // Backpack grid dimensions
        BACKPACK_COLS: 5,      // Width of backpack grid in slots
        BACKPACK_ROWS: 10,     // Height of backpack grid in slots
        BACKPACK_TOTAL_SLOTS: 50, // Total backpack capacity

        // Crate storage dimensions
        CRATE_COLS: 10,        // Width of crate grid in slots
        CRATE_ROWS: 10,        // Height of crate grid in slots
        CRATE_TOTAL_SLOTS: 100, // Total crate capacity

        // Visual settings (adjusted dynamically based on window size)
        DEFAULT_SLOT_SIZE: 60,  // Default slot size in pixels
        DEFAULT_GAP: 2,         // Default gap between slots in pixels

        // Item positioning offsets (accounts for border + padding)
        BACKPACK_ITEMS_OFFSET_TOP: 4,  // Pixels from top of grid
        BACKPACK_ITEMS_OFFSET_LEFT: 4, // Pixels from left of grid
        CRATE_ITEMS_OFFSET_TOP: 2,     // Pixels from top of grid
        CRATE_ITEMS_OFFSET_LEFT: 2,    // Pixels from left of grid
    },

    // ==========================================
    // BUILD MENU
    // ==========================================
    BUILD_MENU: {
        COLS: 5,               // Width of build menu grid
        ROWS: 10,              // Height of build menu grid
        TOTAL_SLOTS: 50,       // Total build menu slots

        // Visual settings
        TARGET_HEIGHT_PERCENT: 0.65, // Use 65% of screen height for 10 rows
    },

    // ==========================================
    // ACTION DURATIONS (all in milliseconds)
    // ==========================================
    ACTIONS: {
        // Tree chopping
        CHOP_TREE_DURATION: 10000,      // 10 seconds to chop a tree
        CHOP_STRUCTURE_DURATION: 5000,   // 5 seconds to demolish structure

        // Resource harvesting
        HARVEST_LOG_DURATION: 10000,     // 10 seconds to harvest from log
        HARVEST_STONE_DURATION: 10000,   // 10 seconds to mine stone

        // Building
        BUILD_DURATION: 6000,            // 6 seconds to build structure

        // Crafting
        CHISELING_DURATION: 6000,        // 6 seconds to chisel stone

        // Animation timings
        CHOPPING_ANIMATION_SPEED: 1.0,   // Playback speed for chopping animation
    },

    // ==========================================
    // TOOL DURABILITY
    // ==========================================
    TOOLS: {
        // Maximum durability for all tools
        MAX_DURABILITY: 100,

        // Durability loss per use
        AXE_DURABILITY_LOSS: 10,         // Loses 10 durability per tree
        SAW_DURABILITY_LOSS: 10,         // Loses 10 durability per plank batch
        PICKAXE_DURABILITY_LOSS: 10,     // Loses 10 durability per stone harvest
        HAMMER_DURABILITY_LOSS: 5,       // Loses 5 durability per build

        // Chisel durability loss is dynamic: Math.ceil(100 / stoneQuality)
        // So a quality 50 stone costs 2 durability, quality 25 costs 4
    },

    // ==========================================
    // HARVEST COOLDOWNS
    // ==========================================
    COOLDOWNS: {
        HARVEST_COOLDOWN: 2000,          // 2 second cooldown between harvests
    },

    // ==========================================
    // UI TIMINGS
    // ==========================================
    UI: {
        STATUS_LINE_DURATION: 3000,      // Status messages show for 3 seconds
        STATUS_LINE_LONG: 4000,          // Important messages show for 4 seconds
        STATUS_LINE_PERMANENT: 0,        // 0 = message stays until cleared

        TOOLTIP_DELAY: 0,                // Instant tooltip on hover
        DOUBLE_CLICK_TIME: 300,          // Max ms between clicks for double-click
    },

    // ==========================================
    // NETWORKING
    // ==========================================
    NETWORK: {
        // WebSocket reconnection
        RECONNECT_DELAY: 5000,           // Try reconnecting after 5 seconds
        MAX_RECONNECT_ATTEMPTS: 5,       // Maximum reconnection attempts

        // P2P Connection
        P2P_CONNECTION_TIMEOUT: 5000,    // 5 seconds to establish P2P connection
        P2P_STAGGER_DELAY: 100,          // 100ms between P2P connection attempts
        P2P_MAX_STAGGER_DELAY: 1000,     // Max 1 second stagger for multiple peers

        // Heartbeat/Keep-alive
        HEARTBEAT_INTERVAL: 30000,       // Send heartbeat every 30 seconds

        // Server message buffer
        MAX_MESSAGE_QUEUE: 100,          // Max queued messages during disconnect
    },

    // ==========================================
    // CAMERA AND CONTROLS
    // ==========================================
    CAMERA: {
        // Third person camera
        DEFAULT_DISTANCE: 10,            // Default camera distance from player
        MIN_DISTANCE: 5,                 // Minimum zoom distance
        MAX_DISTANCE: 30,                // Maximum zoom distance

        // Camera positioning
        HEIGHT_OFFSET: 5,                // Camera height above player
        LOOK_AT_OFFSET: 2,              // Height to look at on player model

        // Zoom controls
        ZOOM_SPEED: 2,                   // Zoom in/out increment
        ZOOM_SMOOTHING: 0.1,            // Camera movement smoothing (0-1)
    },

    // ==========================================
    // PLAYER MOVEMENT
    // ==========================================
    PLAYER: {
        MOVE_SPEED: 5,                   // Units per second
        ROTATION_SPEED: 0.2,             // Rotation lerp factor (0-1)

        // Pickup ranges
        OBJECT_PICKUP_RANGE: 5,          // Distance to interact with objects
        CONSTRUCTION_RANGE: 8,           // Distance to interact with construction
        CRATE_RANGE: 5,                  // Distance to access crate inventory
    },

    // ==========================================
    // OBJECT SPAWNING
    // ==========================================
    OBJECTS: {
        // Tree types and spawn weights
        TREE_TYPES: ['oak', 'pine', 'fir', 'cypress'],

        // Rock types
        ROCK_TYPES: ['limestone', 'sandstone'],

        // Quality ranges (affects durability/resources)
        MIN_QUALITY: 10,                 // Minimum quality for spawned objects
        MAX_QUALITY: 100,                // Maximum quality for spawned objects

        // Resource amounts for logs
        LOG_MIN_RESOURCES: 5,            // Minimum resources in a log
        LOG_MAX_RESOURCES: 20,           // Maximum resources in a log
    },

    // ==========================================
    // CHUNK SYSTEM
    // ==========================================
    CHUNKS: {
        CHUNK_SIZE: 100,                 // World units per chunk
        VIEW_DISTANCE: 2,                // Load chunks within 2 chunks of player
        UNLOAD_DISTANCE: 3,              // Unload chunks beyond 3 chunks

        // Chunk boundaries
        MIN_CHUNK_X: -15,                // Western boundary
        MAX_CHUNK_X: 15,                 // Eastern boundary
        MIN_CHUNK_Z: -15,                // Northern boundary
        MAX_CHUNK_Z: 15,                 // Southern boundary
    },

    // ==========================================
    // WATER SYSTEM
    // ==========================================
    WATER: {
        // Water rendering
        PLANE_SIZE: 3000,                // Size of water plane
        SEGMENTS: 512,                   // Water mesh resolution

        // Wave parameters
        WAVE_STRENGTH: 0.3,              // Wave height multiplier
        WAVE_SPEED: 0.5,                 // Wave animation speed
        WAVE_DAMPING_MIN: 0.2,           // Minimum wave damping
        WAVE_DAMPING_MAX: 1.0,           // Maximum wave damping

        // Foam parameters
        FOAM_DEPTH_START: 1.5,           // Depth where foam starts
        FOAM_DEPTH_MAX: 0.5,            // Depth of maximum foam
        FOAM_OPACITY: 0.6,               // Foam transparency

        // Deep water threshold
        DEEP_WATER_DEPTH: 2.0,           // Depth considered "deep water"
    },

    // ==========================================
    // CONSTRUCTION SYSTEM
    // ==========================================
    CONSTRUCTION: {
        // Material requirements for different structures
        MATERIALS: {
            foundation: {
                chiseledlimestone: 4,
                chiseledsandstone: 4
            },
            foundationcorner: {
                chiseledlimestone: 2,
                chiseledsandstone: 2
            },
            foundationroundcorner: {
                chiseledlimestone: 3,
                chiseledsandstone: 3
            },
            outpost: {
                oakplank: 1
            }
        },

        // Placement rules
        FOUNDATION_SNAP_DISTANCE: 2,     // Distance to snap foundations together
        REQUIRE_HAMMER: true,            // Hammer required to build
    },

    // ==========================================
    // AUDIO SETTINGS
    // ==========================================
    AUDIO: {
        // Volume levels (0.0 to 1.0)
        MASTER_VOLUME: 0.3,              // Overall volume

        // Sound effect volumes (relative to master)
        AXE_VOLUME: 1.0,
        SAW_VOLUME: 1.0,
        PICKAXE_VOLUME: 1.0,
        HAMMER_VOLUME: 1.0,
        CHISEL_VOLUME: 1.0,
        FOOTSTEP_VOLUME: 0.5,

        // Audio distances
        MIN_DISTANCE: 1,                 // Full volume within this distance
        MAX_DISTANCE: 20,                // No sound beyond this distance
        ROLLOFF_FACTOR: 1,              // How quickly sound fades with distance
    },

    // ==========================================
    // DEBUG SETTINGS
    // ==========================================
    DEBUG: {
        SHOW_CHUNK_BORDERS: false,       // Display chunk boundaries
        SHOW_COLLISION_BOXES: false,     // Display collision boxes
        SHOW_NETWORK_STATS: false,       // Display network statistics
        LOG_NETWORK_MESSAGES: false,     // Log all network traffic to console
        LOG_STATE_CHANGES: false,        // Log game state changes
        DISABLE_FOG: false,              // Disable fog for better visibility
    }
};

// ==========================================
// COMPUTED VALUES
// ==========================================
// These are derived from the base config values
// They're computed once at startup for efficiency

export const COMPUTED = {
    // Total inventory slots
    BACKPACK_TOTAL: CONFIG.INVENTORY.BACKPACK_COLS * CONFIG.INVENTORY.BACKPACK_ROWS,
    CRATE_TOTAL: CONFIG.INVENTORY.CRATE_COLS * CONFIG.INVENTORY.CRATE_ROWS,

    // Action durations in seconds (for display)
    CHOP_TREE_SECONDS: CONFIG.ACTIONS.CHOP_TREE_DURATION / 1000,
    BUILD_SECONDS: CONFIG.ACTIONS.BUILD_DURATION / 1000,

    // Chunk boundaries as coordinate range
    CHUNK_X_RANGE: CONFIG.CHUNKS.MAX_CHUNK_X - CONFIG.CHUNKS.MIN_CHUNK_X,
    CHUNK_Z_RANGE: CONFIG.CHUNKS.MAX_CHUNK_Z - CONFIG.CHUNKS.MIN_CHUNK_Z,
};

// ==========================================
// EXPORT AS DEFAULT TOO
// ==========================================
// This allows both named and default imports
export default CONFIG;


================================================================================
FILE 11/11: public/blobshadow.js
Location: C:\Users\colli\Desktop\test horses\horses\public\blobshadow.js
Lines: 198
================================================================================

// File: public/blobshadow.js
// Location: C:\Users\colli\Desktop\test Horses\Horses\public\blobshadow.js

import * as THREE from 'three';

/**
 * Shared shadow texture - created once and reused by all blob shadows
 */
class ShadowTextureManager {
    constructor() {
        this.texture = null;
    }

    getTexture() {
        if (!this.texture) {
            // Create a canvas to draw a radial gradient shadow
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Draw radial gradient (dark in center, transparent at edges)
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);

            // Create texture from canvas (shared by all shadows)
            this.texture = new THREE.CanvasTexture(canvas);
        }
        return this.texture;
    }

    dispose() {
        if (this.texture) {
            this.texture.dispose();
            this.texture = null;
        }
    }
}

// Singleton instance
const shadowTextureManager = new ShadowTextureManager();

/**
 * Simple blob shadow system - creates circular shadows under objects
 * No shadow mapping, no flickering, super fast
 * Uses shared texture for all instances (much more efficient!)
 */
export class BlobShadow {
    /**
     * Create a blob shadow for an object
     * @param {THREE.Object3D} targetObject - Object to attach shadow to
     * @param {THREE.Scene} scene - Scene to add shadow to
     * @param {number} size - Diameter of shadow circle
     * @param {number} opacity - Shadow opacity (0-1, default 0.3)
     */
    constructor(targetObject, scene, size = 2, opacity = 0.3) {
        this.targetObject = targetObject;
        this.scene = scene;
        this.size = size;
        this.opacity = opacity;

        // Create shadow sprite
        this.createShadowSprite();
    }

    createShadowSprite() {
        // Get shared texture (created once, reused by all shadows)
        const texture = shadowTextureManager.getTexture();

        // Create material (each shadow has its own material for opacity control)
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: this.opacity,
            depthWrite: false,
            color: 0x000000
        });

        // Create geometry (a flat circle)
        const geometry = new THREE.CircleGeometry(this.size / 2, 16);

        // Create mesh
        this.shadowMesh = new THREE.Mesh(geometry, material);
        this.shadowMesh.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
        this.shadowMesh.renderOrder = -1; // Render before other objects

        this.scene.add(this.shadowMesh);
    }

    /**
     * Update shadow position to follow target object
     * @param {Function} getTerrainHeight - Function to get terrain height at (x, z)
     * @param {THREE.Vector3} lightPosition - Position of the directional light (optional)
     * @param {Function} getTerrainNormal - Function to get terrain normal at (x, z) (optional)
     */
    update(getTerrainHeight, lightPosition = null, getTerrainNormal = null) {
        if (!this.targetObject || !this.shadowMesh) return;

        // Position shadow under the object
        const targetPos = this.targetObject.position;

        // Calculate shadow offset based on light direction
        let shadowX = targetPos.x;
        let shadowZ = targetPos.z;

        if (lightPosition) {
            // Calculate 2D direction from object to light (top-down view)
            const lightDirX = lightPosition.x - targetPos.x;
            const lightDirZ = lightPosition.z - targetPos.z;
            const lightDist = Math.sqrt(lightDirX * lightDirX + lightDirZ * lightDirZ);

            if (lightDist > 0.01) {
                // Normalize light direction
                const normX = lightDirX / lightDist;
                const normZ = lightDirZ / lightDist;

                // Shadow moves AWAY from light (opposite direction)
                // Small offset for the small scale of the game
                const offsetDistance = 0.1;
                shadowX = targetPos.x - normX * offsetDistance;
                shadowZ = targetPos.z - normZ * offsetDistance;
            }
        }

        // Get terrain height at shadow position
        const groundY = getTerrainHeight ? getTerrainHeight(shadowX, shadowZ) : 0;

        // Apply 0.25 unit left offset for more realistic shadow positioning
        const offsetX = shadowX - 0.25;

        // Place shadow slightly above terrain to avoid z-fighting
        this.shadowMesh.position.set(offsetX, groundY + 0.05, shadowZ);

        // Align shadow with terrain slope if normal is available
        if (getTerrainNormal) {
            const normal = getTerrainNormal(shadowX, shadowZ);
            if (normal) {
                // Create rotation to align with terrain normal
                // Default up vector is (0, 1, 0)
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, normal);

                // Apply rotation (keeping the flat orientation)
                this.shadowMesh.quaternion.copy(quaternion);
                this.shadowMesh.rotateX(-Math.PI / 2); // Still needs base rotation to lie flat
            }
        }
    }

    /**
     * Set shadow opacity
     * @param {number} opacity - New opacity (0-1)
     */
    setOpacity(opacity) {
        this.opacity = opacity;
        if (this.shadowMesh && this.shadowMesh.material) {
            this.shadowMesh.material.opacity = opacity;
        }
    }

    /**
     * Set shadow size
     * @param {number} size - New diameter
     */
    setSize(size) {
        this.size = size;
        if (this.shadowMesh) {
            this.shadowMesh.scale.set(size / 2, size / 2, 1);
        }
    }

    /**
     * Remove shadow from scene
     */
    dispose() {
        if (this.shadowMesh) {
            this.scene.remove(this.shadowMesh);
            if (this.shadowMesh.geometry) this.shadowMesh.geometry.dispose();
            if (this.shadowMesh.material) {
                // Don't dispose the shared texture, only the material
                this.shadowMesh.material.dispose();
            }
            this.shadowMesh = null;
        }
    }
}

/**
 * Export shadow texture manager for cleanup if needed
 */
export { shadowTextureManager };



================================================================================
                              END OF CODE DUMP
================================================================================
