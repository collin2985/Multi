<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Game - Server/P2P Hybrid</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; }
        canvas { display: block; }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        button {
            margin-right: 10px;
            padding: 10px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            max-width: 500px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        #connectionStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .status-connecting {
            background: #ff9800;
            color: white;
            animation: pulse 1.5s infinite;
        }
        .status-connected {
            background: #4caf50;
            color: white;
        }
        .status-disconnected {
            background: #f44336;
            color: white;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #peerInfo {
            position: absolute;
            top: 70px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="joinChunkBtn">Join Chunk</button>
        <button id="addBoxBtn" disabled>Add Box</button>
        <button id="removeBoxBtn" disabled>Remove Box</button>
    </div>
    <div id="connectionStatus" class="status-connecting">üîÑ Connecting...</div>
    <div id="peerInfo">P2P Connections: 0</div>
    <div id="status">Initializing...</div>
    
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { SimpleTerrainRenderer } from './terrain.js';

        // --- GLOBAL STATE ---
        const clientId = 'client_' + Math.random().toString(36).substr(2, 12);
        let isInChunk = false;
        let boxInScene = false;
        const peers = new Map();
        let terrainRenderer = null;
        const avatars = new Map();
        let currentPlayerChunkX = 0;
        let currentPlayerChunkZ = 0;
        const loadRadius = 2; // How many chunks to load around player
        let lastChunkUpdateTime = 0;
        const chunkUpdateInterval = 2000; // Check every second
        let chunkLoadQueue = [];
        let isProcessingChunks = false;
        
        // ADDED: Global state for terrain seed and initial load flag
        let terrainSeed = 0;
        let initialChunksLoaded = false;

        // Click-to-move state
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const playerTargetPosition = new THREE.Vector3();
        let isMoving = false;
        
        // --- WEBSOCKET RECONNECTION STATE ---
        let ws = null;
        let wsRetryAttempts = 0;
        const wsMaxRetries = 10;
        const wsRetryInterval = 5000;
        
        // --- UI ELEMENTS ---
        const statusEl = document.getElementById('status');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const peerInfoEl = document.getElementById('peerInfo');
        const joinBtn = document.getElementById('joinChunkBtn');
        const addBtn = document.getElementById('addBoxBtn');
        const removeBtn = document.getElementById('removeBoxBtn');

        function updateStatus(msg) {
            const timestamp = new Date().toLocaleTimeString();
            statusEl.innerHTML += `[${timestamp}] ${msg}<br>`;
            statusEl.scrollTop = statusEl.scrollHeight;
            console.log(`[${timestamp}] ${msg}`);
        }

        function updateConnectionStatus(status, message) {
            connectionStatusEl.className = `status-${status}`;
            connectionStatusEl.innerHTML = message;
        }

        function updatePeerInfo() {
            const connectedPeers = Array.from(peers.values()).filter(p => p.state === 'connected');
            peerInfoEl.innerHTML = `P2P Connections: ${connectedPeers.length}/${peers.size}<br>Avatars: ${avatars.size}`;
            updateButtonStates();
        }

        function updateButtonStates() {
            addBtn.disabled = !isInChunk || boxInScene;
            removeBtn.disabled = !isInChunk || !boxInScene;
        }

        // --- THREE.JS SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);
        
        const playerObject = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0x0000ff })
        );
        playerObject.position.set(0, 5, 0);
        scene.add(playerObject);
        
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshLambertMaterial({ color: 0x00ff00 })
        );
        box.position.set(0, 0, -3);
        box.name = 'serverBox';

        terrainRenderer = new SimpleTerrainRenderer(scene);

        // --- CLICK-TO-MOVE HANDLER ---
        window.addEventListener('pointerdown', onPointerDown);
        
        function onPointerDown(event) {
            if (event.target.tagName !== 'CANVAS') return;

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        
            raycaster.setFromCamera(pointer, camera);
        
            const terrainObjects = Array.from(terrainRenderer.terrainChunks.values());
            const intersects = raycaster.intersectObjects(terrainObjects, true);
        
            if (intersects.length > 0) {
                const intersect = intersects[0];
                playerTargetPosition.copy(intersect.point);
                isMoving = true;
                updateStatus(`üöÄ Moving to clicked position: (${playerTargetPosition.x.toFixed(2)}, ${playerTargetPosition.z.toFixed(2)})`);
                
                broadcastP2P({
                    type: 'player_move',
                    payload: {
                        start: playerObject.position.toArray(),
                        target: playerTargetPosition.toArray()
                    }
                });
            }
        }
        
        // --- WEBSOCKET CONNECTION ---
        function connectToServer() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            ws = new WebSocket('wss://multiplayer-game-dcwy.onrender.com');

            ws.onopen = () => {
                updateStatus("‚úÖ Connected to server");
                updateConnectionStatus('connected', '‚úÖ Server Connected');
                joinBtn.disabled = false;
                wsRetryAttempts = 0;
            };

            ws.onclose = (event) => {
                updateStatus(`‚ùå Server disconnected (${event.code})`);
                updateConnectionStatus('disconnected', '‚ùå Server Disconnected');
                isInChunk = false;
                updateButtonStates();
                attemptWsReconnect();
            };

            ws.onerror = (error) => {
                updateStatus(`‚ùå Server error: ${error}`);
                updateConnectionStatus('disconnected', '‚ùå Server Error');
            };

            ws.onmessage = async function(event) {
                let messageData;
                
                if (event.data instanceof Blob) {
                    messageData = await event.data.text();
                } else {
                    messageData = event.data;
                }
                
                let data;
                try {
                    data = JSON.parse(messageData);
                } catch (error) {
                    updateStatus(`‚ùå Invalid server message: ${error.message}`);
                    return;
                }

                updateStatus(`üì• Server: ${data.type}`);

                switch (data.type) {
                    case 'webrtc_offer':
                        await handleWebRTCOffer(data.payload);
                        break;
                    case 'webrtc_answer':
                        await handleWebRTCAnswer(data.payload);
                        break;
                    case 'webrtc_ice_candidate':
                        await handleWebRTCIceCandidate(data.payload);
                        break;
                    case 'chunk_state_change':
                        handleChunkStateChange(data.payload);
                        break;
                    default:
                        updateStatus(`‚ùì Unknown server message: ${data.type}`);
                }
            };
        }
        
        function attemptWsReconnect() {
            if (wsRetryAttempts < wsMaxRetries) {
                wsRetryAttempts++;
                updateStatus(`Attempting server reconnect... (${wsRetryAttempts}/${wsMaxRetries})`);
                setTimeout(connectToServer, wsRetryInterval);
            } else {
                updateStatus("‚ùå Max server reconnection attempts reached. Please refresh.");
            }
        }
        
        // --- P2P CONNECTION MANAGEMENT ---
        function createPeerConnection(peerId, isInitiator = false) {
            updateStatus(`Creating ${isInitiator ? 'outgoing' : 'incoming'} P2P connection to ${peerId}`);
            
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            const connection = new RTCPeerConnection(config);
            let dataChannel = null;

            const peerState = {
                connection,
                dataChannel: null,
                state: 'connecting',
                isInitiator,
                targetPosition: null,
                moveStartTime: null
            };

            peers.set(peerId, peerState);

            connection.onicecandidate = (event) => {
                if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
                    sendServerMessage('webrtc_ice_candidate', {
                        recipientId: peerId,
                        senderId: clientId,
                        candidate: event.candidate
                    });
                }
            };

            connection.onconnectionstatechange = () => {
                const state = connection.connectionState;
                updateStatus(`P2P ${peerId}: ${state}`);
                peerState.state = state;
                
                if (state === 'connected') {
                    updateStatus(`‚úÖ P2P connected to ${peerId}`);
                } else if (state === 'failed' || state === 'closed' || state === 'disconnected') {
                    updateStatus(`‚ùå P2P ${state} with ${peerId}`);
                }
                updatePeerInfo();
            };

            if (isInitiator) {
                dataChannel = connection.createDataChannel('game', { ordered: true });
                setupDataChannel(dataChannel, peerId);
                peerState.dataChannel = dataChannel;
            } else {
                connection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel, peerId);
                    peerState.dataChannel = dataChannel;
                };
            }

            return connection;
        }

        function setupDataChannel(channel, peerId) {
            channel.onopen = () => {
                updateStatus(`üì° Data channel open with ${peerId}`);
                const peer = peers.get(peerId);
                if (peer) peer.state = 'connected';
                updatePeerInfo();
            };

            channel.onclose = () => {
                updateStatus(`üì° Data channel closed with ${peerId}`);
                const peer = peers.get(peerId);
                if(peer) peer.state = 'disconnected';
            };

            channel.onerror = (error) => {
                updateStatus(`‚ùå Data channel error with ${peerId}: ${error}`);
            };

            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleP2PMessage(message, peerId);
                } catch (error) {
                    updateStatus(`‚ùå Invalid P2P message from ${peerId}`);
                }
            };
        }

        function cleanupPeer(peerId) {
            const peer = peers.get(peerId);
            if (peer) {
                if (peer.connection) {
                    peer.connection.close();
                }
                peers.delete(peerId);
                updateStatus(`üßπ Cleaned up peer ${peerId}`);
            }
            const avatar = avatars.get(peerId);
            if (avatar) {
                scene.remove(avatar);
                avatars.delete(peerId);
                updateStatus(`üëã Avatar for ${peerId} removed.`);
            }
            updatePeerInfo();
        }
        
        function handleP2PMessage(message, fromPeer) {
            switch (message.type) {
                case 'player_move':
                    const peer = peers.get(fromPeer);
                    const avatar = avatars.get(fromPeer);
                    if (peer && avatar) {
                        avatar.position.fromArray(message.payload.start);
                        peer.targetPosition = new THREE.Vector3().fromArray(message.payload.target);
                        peer.moveStartTime = performance.now();
                        updateStatus(`üï∫ Avatar for ${fromPeer} is now moving`);
                    }
                    break;
                default:
                    updateStatus(`‚ùì Unknown P2P message type: ${message.type}`);
            }
        }

        function broadcastP2P(message) {
            let sentCount = 0;
            peers.forEach((peer, peerId) => {
                if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                    try {
                        peer.dataChannel.send(JSON.stringify(message));
                        sentCount++;
                    } catch (error) {
                        updateStatus(`‚ùå Failed to send P2P to ${peerId}: ${error}`);
                    }
                }
            });
            return sentCount;
        }

        // --- SERVER MESSAGE HANDLING ---
        async function handleWebRTCOffer(payload) {
            const { senderId, offer } = payload;
            if (!senderId || !offer) return;
            
            const connection = createPeerConnection(senderId, false);
            
            try {
                await connection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await connection.createAnswer();
                await connection.setLocalDescription(answer);
                
                sendServerMessage('webrtc_answer', {
                    recipientId: senderId,
                    senderId: clientId,
                    answer: connection.localDescription
                });
            } catch (error) {
                updateStatus(`‚ùå WebRTC offer handling failed: ${error}`);
                cleanupPeer(senderId);
            }
        }

        async function handleWebRTCAnswer(payload) {
            const { senderId, answer } = payload;
            if (!senderId || !answer) return;
            
            const peer = peers.get(senderId);
            if (!peer) {
                updateStatus(`‚ùå No peer connection for answer from ${senderId}`);
                return;
            }
            
            try {
                await peer.connection.setRemoteDescription(new RTCSessionDescription(answer));
            } catch (error) {
                updateStatus(`‚ùå WebRTC answer handling failed: ${error}`);
                cleanupPeer(senderId);
            }
        }

        async function handleWebRTCIceCandidate(payload) {
            const { senderId, candidate } = payload;
            if (!senderId || !candidate) return;
            
            const peer = peers.get(senderId);
            if (!peer) {
                updateStatus(`‚ùå No peer connection for ICE from ${senderId}`);
                return;
            }
            
            try {
                await peer.connection.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (error) {
                updateStatus(`‚ùå ICE candidate failed: ${error}`);
            }
        }

        async function handleChunkStateChange(payload) {
            updateStatus(`üîÑ Chunk update received for ${payload.chunkId}`);
            
            const chunkState = payload.state;
            
            // SET THE GLOBAL TERRAIN SEED from the server
            if (chunkState.seed) {
                terrainSeed = chunkState.seed;
                
                // TRIGGER INITIAL CHUNK LOADING ONLY ONCE, AFTER RECEIVING THE SEED
                if (!initialChunksLoaded) {
                    updateChunksAroundPlayer(
                        Math.floor(playerObject.position.x / 50),
                        Math.floor(playerObject.position.z / 50)
                    );
                    initialChunksLoaded = true;
                }
            }

            // Reconcile player list
            const existingPlayers = new Set(payload.state.players.map(p => p.id));
            const playersToKeep = new Set();
            for (const [peerId, peer] of peers) {
                if (existingPlayers.has(peerId)) {
                    playersToKeep.add(peerId);
                } else {
                    cleanupPeer(peerId);
                }
            }
            
            // Check for new players and establish P2P connections
            for (const player of chunkState.players) {
                if (player.id !== clientId && !peers.has(player.id)) {
                    updateStatus(`New player detected: ${player.id}. Establishing P2P...`);
                    // Initiate P2P connection
                    initiateConnection(player.id);
                }
            }

            // Remove box changes for players who have left
            // Note: This assumes box changes are synchronized
            const boxChanges = Object.keys(chunkState.boxes);
            const boxChangesToRemove = [];

            for (const boxId of boxChanges) {
                const box = chunkState.boxes[boxId];
                if (!existingPlayers.has(box.player) && box.player !== clientId) {
                    boxChangesToRemove.push(box.id);
                }
            }

            // Ensure our local boxes match the server's state
            const serverBoxKeys = Object.keys(chunkState.boxes);
            const serverBoxSet = new Set(serverBoxKeys);
            
            // Remove local boxes that are not in the server state
            for (const [key, mesh] of boxMeshMap) {
                if (!serverBoxSet.has(key)) {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    boxMeshMap.delete(key);
                }
            }
            
            // Add or update boxes from the server state
            for (const key of serverBoxKeys) {
                const serverBox = chunkState.boxes[key];
                const boxMesh = boxMeshMap.get(key);
                if (!boxMesh) {
                    // This is a new box, add it
                    const newMesh = createBoxMesh(serverBox.x, serverBox.y, serverBox.z, serverBox.color);
                    boxMeshMap.set(key, newMesh);
                }
            }
            
            // Handle terrain changes
            if (chunkState.removedPoints.length > 0 || chunkState.addedPoints.length > 0) {
                terrainRenderer.updateTerrain(chunkState.removedPoints, chunkState.addedPoints, terrainSeed, playerAvatar.position);
            } else if (payload.chunkId.includes(currentChunk)) {
                // If it's a full state update, remove existing terrain and re-add
                const [chunkX, chunkZ] = payload.chunkId.split('_').slice(1).map(Number);
                terrainRenderer.removeTerrainChunk({ chunkX: chunkX * 50, chunkZ: chunkZ * 50 });
                terrainRenderer.addTerrainChunk({ chunkX: chunkX * 50, chunkZ: chunkZ * 50, seed: terrainSeed });
            }
        }

        async function initiateConnection(peerId) {
            updateStatus(`ü§ù Initiating connection to ${peerId}`);
            
            const connection = createPeerConnection(peerId, true);
            
            try {
                const offer = await connection.createOffer();
                await connection.setLocalDescription(offer);
                
                sendServerMessage('webrtc_offer', {
                    recipientId: peerId,
                    senderId: clientId,
                    offer: connection.localDescription
                });
            } catch (error) {
                updateStatus(`‚ùå Failed to create offer for ${peerId}: ${error}`);
                cleanupPeer(peerId);
            }
        }

        // --- SERVER COMMUNICATION ---
        function sendServerMessage(type, payload) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                updateStatus("‚ùå Cannot send - server disconnected");
                updateConnectionStatus('disconnected', '‚ùå Server Disconnected');
                return false;
            }
            
            try {
                ws.send(JSON.stringify({ type, payload }));
                updateStatus(`üì§ Sent to server: ${type}`);
                return true;
            } catch (error) {
                updateStatus(`‚ùå Failed to send message: ${error}`);
                return false;
            }
        }

        // --- BUTTON HANDLERS ---
        joinBtn.onclick = () => {
            if (sendServerMessage('join_chunk', { chunkId: 'chunk_0_0', clientId })) {
                isInChunk = true;
                joinBtn.disabled = true;
                updateButtonStates();
            }
        };

        addBtn.onclick = () => {
            sendServerMessage('add_box_request', { 
                chunkId: 'chunk_0_0',
                position: { x: 0, y: 0, z: -3 }
            });
        };

        removeBtn.onclick = () => {
            sendServerMessage('remove_box_request', { chunkId: 'chunk_0_0' });
        };
        
        // --- CHUNK LOADING MANAGEMENT ---
        const currentChunks = new Set();
        const chunkSize = 50;

        function updateChunksAroundPlayer(playerChunkX, playerChunkZ) {
            const shouldLoad = new Set();
            for (let x = playerChunkX - loadRadius; x <= playerChunkX + loadRadius; x++) {
                for (let z = playerChunkZ - loadRadius; z <= playerChunkZ + loadRadius; z++) {
                    shouldLoad.add(`${x},${z}`);
                }
            }
            
            // Remove chunks that are no longer in range
            for (const chunkKey of currentChunks) {
                if (!shouldLoad.has(chunkKey)) {
                    currentChunks.delete(chunkKey);
                    const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
                    terrainRenderer.removeTerrainChunk({ 
                        chunkX: chunkX * chunkSize, 
                        chunkZ: chunkZ * chunkSize 
                    });
                    updateStatus(`Unloaded chunk (${chunkX}, ${chunkZ})`);
                }
            }
            
            // Add new chunks that have entered the range
            for (const chunkKey of shouldLoad) {
                if (!currentChunks.has(chunkKey)) {
                    const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
                    currentChunks.add(chunkKey);
                    
                    // Queue chunk for loading
                    chunkLoadQueue.push({ 
                        chunkX: chunkX * chunkSize, 
                        chunkZ: chunkZ * chunkSize, 
                        seed: terrainSeed // Use the global seed
                    });
                }
            }
        }

        function processChunkQueue() {
            if (chunkLoadQueue.length > 0 && !isProcessingChunks) {
                isProcessingChunks = true;
                const chunk = chunkLoadQueue.shift();
                
                terrainRenderer.addTerrainChunk(chunk);
                updateStatus(`Loaded chunk at (${chunk.chunkX/50}, ${chunk.chunkZ/50})`);
                
                // Allow one frame before processing next chunk
                setTimeout(() => {
                    isProcessingChunks = false;
                }, 16);
            }
        }

        // --- ANIMATION LOOP ---
        const playerSpeed = 0.05;
        const stopThreshold = 0.01;
        let lastFrameTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaTime = now - lastFrameTime;

            // Player movement
            if (isMoving) {
                const distance = playerObject.position.distanceTo(playerTargetPosition);
                
                if (distance <= stopThreshold) {
                    playerObject.position.copy(playerTargetPosition);
                    isMoving = false;
                    updateStatus("üèÅ Arrived at destination.");
                } else {
                    const moveStep = playerSpeed * deltaTime;
                    const alpha = Math.min(1, moveStep / distance);
                    playerObject.position.lerp(playerTargetPosition, alpha);
                }
            }

            // Avatar movement
            avatars.forEach((avatar, peerId) => {
                const peer = peers.get(peerId);
                if (peer && peer.targetPosition) {
                    const distance = avatar.position.distanceTo(peer.targetPosition);

                    if (distance <= stopThreshold) {
                        avatar.position.copy(peer.targetPosition);
                        peer.targetPosition = null;
                        updateStatus(`‚úÖ Avatar for ${peerId} arrived at destination.`);
                    } else {
                        const moveStep = playerSpeed * deltaTime;
                        const alpha = Math.min(1, moveStep / distance);
                        avatar.position.lerp(peer.targetPosition, alpha);
                    }
                }
            });

            // Chunk loading check
            if (now - lastChunkUpdateTime > chunkUpdateInterval) {
                const newChunkX = Math.floor((playerObject.position.x + chunkSize/2) / chunkSize);
                const newChunkZ = Math.floor((playerObject.position.z + chunkSize/2) / chunkSize);
                
                if (newChunkX !== currentPlayerChunkX || newChunkZ !== currentPlayerChunkZ) {
                    currentPlayerChunkX = newChunkX;
                    currentPlayerChunkZ = newChunkZ;
                    updateChunksAroundPlayer(newChunkX, newChunkZ);
                    updateStatus(`Player moved to chunk (${newChunkX}, ${newChunkZ})`);
                }
                lastChunkUpdateTime = now;
            }

            checkAndReconnectPeers(); 
            processChunkQueue(); 

            const cameraOffset = new THREE.Vector3(-15, 40, 20);
            const cameraTargetPosition = playerObject.position.clone().add(cameraOffset);
            const smoothedCameraPosition = camera.position.lerp(cameraTargetPosition, 0.1);
            camera.position.copy(smoothedCameraPosition);
            camera.lookAt(playerObject.position);

            const serverBox = scene.getObjectByName('serverBox');
            if (serverBox) {
                box.rotation.x += 0.005;
                box.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
            lastFrameTime = now;
        }
        
        // --- P2P RECONNECTION LOGIC ---
        let lastPeerCheckTime = 0;
        const peerCheckInterval = 5000;
        
        function checkAndReconnectPeers() {
            const now = performance.now();
            if (now - lastPeerCheckTime < peerCheckInterval) {
                return;
            }
            lastPeerCheckTime = now;

            const otherPlayers = Array.from(peers.keys());
            for (const peerId of otherPlayers) {
                const peer = peers.get(peerId);
                if (peer && (peer.state === 'disconnected' || peer.state === 'failed')) {
                    const shouldInitiate = clientId < peerId;
                    if (shouldInitiate) {
                        updateStatus(`Attempting P2P reconnect to ${peerId}...`);
                        initiateConnection(peerId);
                    }
                }
            }
        }

        // --- RESIZE HANDLING ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INITIALIZATION ---
        updateStatus("üéÆ Game initialized");
        updateStatus("üìã Click 'Join Chunk' to start");
        updateConnectionStatus('connecting', 'üîÑ Connecting...');
        connectToServer();
        animate();
    </script>
</body>
</html>